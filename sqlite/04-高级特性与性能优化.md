# 高级特性与性能优化

## 目录
1. [WAL模式与并发控制](#wal模式与并发控制)
2. [索引优化策略](#索引优化策略)
3. [查询性能优化](#查询性能优化)
4. [内存管理优化](#内存管理优化)
5. [预编译语句优化](#预编译语句优化)
6. [批量操作优化](#批量操作优化)
7. [连接池管理](#连接池管理)
8. [监控与调试](#监控与调试)

---

## WAL模式与并发控制

### 1. WAL模式原理

**Write-Ahead Logging (WAL)模式**是SQLite提供的一种日志模式，它提供了更好的并发性能。

**传统模式 vs WAL模式**：
```
传统模式 (DELETE/TRUNCATE):
┌─────────────┐    ┌─────────────┐
│   主数据库   │ ←→ │  回滚日志   │
└─────────────┘    └─────────────┘

WAL模式:
┌─────────────┐    ┌─────────────┐
│   主数据库   │ ←→ │   WAL文件   │
└─────────────┘    └─────────────┘
```

**启用WAL模式**：
```javascript
// sqlite3方式
db.run('PRAGMA journal_mode = WAL', (err) => {
    if (err) {
        console.error('启用WAL模式失败:', err.message);
    } else {
        console.log('WAL模式已启用');
    }
});

// better-sqlite3方式
db.pragma('journal_mode = WAL');
console.log('WAL模式已启用');
```

### 2. WAL模式优势

**并发读写性能**：
```javascript
// 测试并发性能
const fs = require('fs');
const path = require('path');

class WALPerformanceTest {
    constructor() {
        this.db = new sqlite3.Database('./test.db');
        this.setupDatabase();
    }
    
    setupDatabase() {
        this.db.serialize(() => {
            // 启用WAL模式
            this.db.run('PRAGMA journal_mode = WAL');
            
            // 创建测试表
            this.db.run(`
                CREATE TABLE IF NOT EXISTS test_data (
                    id INTEGER PRIMARY KEY,
                    value TEXT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);
        });
    }
    
    async testConcurrentOperations() {
        const startTime = Date.now();
        const promises = [];
        
        // 并发写入
        for (let i = 0; i < 100; i++) {
            promises.push(this.insertData(i));
        }
        
        // 并发读取
        for (let i = 0; i < 100; i++) {
            promises.push(this.readData());
        }
        
        await Promise.all(promises);
        const duration = Date.now() - startTime;
        
        console.log(`并发操作完成，耗时: ${duration}ms`);
    }
    
    insertData(id) {
        return new Promise((resolve, reject) => {
            this.db.run(
                'INSERT INTO test_data (value) VALUES (?)',
                [`data_${id}`],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.lastID);
                }
            );
        });
    }
    
    readData() {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM test_data ORDER BY timestamp DESC LIMIT 10', (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
}
```

### 3. WAL检查点管理

**自动检查点**：
```javascript
// 监控WAL文件大小
const fs = require('fs');

class WALManager {
    constructor(dbPath) {
        this.dbPath = dbPath;
        this.walPath = `${dbPath}-wal`;
        this.maxWALSize = 10 * 1024 * 1024; // 10MB
    }
    
    startMonitoring() {
        setInterval(() => {
            this.checkWALSize();
        }, 5000); // 每5秒检查一次
    }
    
    checkWALSize() {
        try {
            if (fs.existsSync(this.walPath)) {
                const stats = fs.statSync(this.walPath);
                if (stats.size > this.maxWALSize) {
                    this.performCheckpoint();
                }
            }
        } catch (error) {
            console.error('WAL检查失败:', error.message);
        }
    }
    
    performCheckpoint() {
        db.run('PRAGMA wal_checkpoint(RESTART)', (err) => {
            if (err) {
                console.error('检查点失败:', err.message);
            } else {
                console.log('WAL检查点完成');
            }
        });
    }
}
```

---

## 索引优化策略

### 1. 索引类型与选择

**单列索引**：
```javascript
// 创建单列索引
db.run('CREATE INDEX IF NOT EXISTS idx_users_email ON users (email)');
db.run('CREATE INDEX IF NOT EXISTS idx_posts_created ON posts (created_at)');
db.run('CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments (post_id)');
```

**复合索引**：
```javascript
// 创建复合索引
db.run('CREATE INDEX IF NOT EXISTS idx_posts_author_status ON posts (author_id, status)');
db.run('CREATE INDEX IF NOT EXISTS idx_comments_post_created ON comments (post_id, created_at)');
```

**唯一索引**：
```javascript
// 创建唯一索引
db.run('CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users (username)');
db.run('CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users (email)');
```

### 2. 索引性能分析

**查询计划分析**：
```javascript
// 分析查询计划
function analyzeQuery(sql, params = []) {
    const explainQuery = `EXPLAIN QUERY PLAN ${sql}`;
    
    db.all(explainQuery, params, (err, rows) => {
        if (err) {
            console.error('查询计划分析失败:', err.message);
        } else {
            console.log('查询计划:');
            rows.forEach(row => {
                console.log(`  ${row.detail}`);
            });
        }
    });
}

// 使用示例
analyzeQuery('SELECT * FROM posts WHERE author_id = ? AND status = ?', [1, 'published']);
```

**索引使用情况统计**：
```javascript
// 获取索引使用统计
function getIndexStats() {
    const query = `
        SELECT 
            name,
            sql,
            (SELECT COUNT(*) FROM sqlite_master WHERE type = 'index' AND tbl_name = m.name) as index_count
        FROM sqlite_master m
        WHERE type = 'table' AND name NOT LIKE 'sqlite_%'
    `;
    
    db.all(query, (err, rows) => {
        if (err) {
            console.error('获取索引统计失败:', err.message);
        } else {
            console.log('表索引统计:');
            rows.forEach(row => {
                console.log(`表: ${row.name}, 索引数量: ${row.index_count}`);
            });
        }
    });
}
```

### 3. 索引优化建议

**选择性高的列优先**：
```javascript
// 分析列的选择性
function analyzeColumnSelectivity(tableName, columnName) {
    const query = `
        SELECT 
            COUNT(DISTINCT ${columnName}) as distinct_count,
            COUNT(*) as total_count,
            ROUND(COUNT(DISTINCT ${columnName}) * 100.0 / COUNT(*), 2) as selectivity
        FROM ${tableName}
    `;
    
    db.get(query, (err, row) => {
        if (err) {
            console.error('选择性分析失败:', err.message);
        } else {
            console.log(`${tableName}.${columnName} 选择性: ${row.selectivity}%`);
            if (row.selectivity > 10) {
                console.log('建议创建索引');
            }
        }
    });
}
```

---

## 查询性能优化

### 1. 查询优化技巧

**避免SELECT ***：
```javascript
// 不推荐
db.all('SELECT * FROM users WHERE id = ?', [1], (err, rows) => {
    // 返回所有列，包括不需要的
});

// 推荐
db.all('SELECT id, username, email FROM users WHERE id = ?', [1], (err, rows) => {
    // 只返回需要的列
});
```

**使用LIMIT限制结果**：
```javascript
// 分页查询
function getUsersPage(page = 1, pageSize = 10) {
    const offset = (page - 1) * pageSize;
    const query = `
        SELECT id, username, email, created_at
        FROM users
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
    `;
    
    db.all(query, [pageSize, offset], (err, rows) => {
        if (err) {
            console.error('分页查询失败:', err.message);
        } else {
            console.log(`第${page}页用户:`, rows);
        }
    });
}
```

**优化JOIN查询**：
```javascript
// 优化JOIN查询
function getPostsWithAuthors() {
    const query = `
        SELECT 
            p.id,
            p.title,
            p.created_at,
            u.username as author_name
        FROM posts p
        INNER JOIN users u ON p.author_id = u.id
        WHERE p.status = 'published'
        ORDER BY p.created_at DESC
        LIMIT 20
    `;
    
    db.all(query, (err, rows) => {
        if (err) {
            console.error('JOIN查询失败:', err.message);
        } else {
            console.log('文章列表:', rows);
        }
    });
}
```

### 2. 查询缓存

**简单查询缓存**：
```javascript
class QueryCache {
    constructor(maxSize = 1000, ttl = 300000) { // 5分钟TTL
        this.cache = new Map();
        this.maxSize = maxSize;
        this.ttl = ttl;
    }
    
    get(key) {
        const item = this.cache.get(key);
        if (!item) return null;
        
        if (Date.now() - item.timestamp > this.ttl) {
            this.cache.delete(key);
            return null;
        }
        
        return item.data;
    }
    
    set(key, data) {
        if (this.cache.size >= this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(key, {
            data: data,
            timestamp: Date.now()
        });
    }
    
    clear() {
        this.cache.clear();
    }
}

// 使用缓存
const queryCache = new QueryCache();

function getCachedUsers() {
    const cacheKey = 'all_users';
    let users = queryCache.get(cacheKey);
    
    if (!users) {
        db.all('SELECT id, username, email FROM users', (err, rows) => {
            if (!err) {
                queryCache.set(cacheKey, rows);
                console.log('用户数据已缓存');
            }
        });
    } else {
        console.log('从缓存获取用户数据');
    }
    
    return users;
}
```

---

## 内存管理优化

### 1. 内存使用监控

**监控内存使用**：
```javascript
class MemoryMonitor {
    constructor() {
        this.startMemory = process.memoryUsage();
        this.peakMemory = this.startMemory;
    }
    
    getMemoryUsage() {
        const current = process.memoryUsage();
        
        return {
            rss: Math.round(current.rss / 1024 / 1024), // MB
            heapTotal: Math.round(current.heapTotal / 1024 / 1024), // MB
            heapUsed: Math.round(current.heapUsed / 1024 / 1024), // MB
            external: Math.round(current.external / 1024 / 1024), // MB
            arrayBuffers: Math.round(current.arrayBuffers / 1024 / 1024) // MB
        };
    }
    
    updatePeakMemory() {
        const current = process.memoryUsage();
        if (current.heapUsed > this.peakMemory.heapUsed) {
            this.peakMemory = current;
        }
    }
    
    logMemoryUsage(label = '') {
        const usage = this.getMemoryUsage();
        console.log(`${label} 内存使用:`, usage);
    }
}

// 使用示例
const monitor = new MemoryMonitor();

// 在关键操作前后监控内存
monitor.logMemoryUsage('操作前');
// 执行数据库操作
monitor.logMemoryUsage('操作后');
```

### 2. 内存优化策略

**流式处理大数据**：
```javascript
// 流式处理大量数据
function processLargeDataset() {
    const batchSize = 1000;
    let offset = 0;
    
    function processBatch() {
        const query = `
            SELECT * FROM large_table
            ORDER BY id
            LIMIT ? OFFSET ?
        `;
        
        db.all(query, [batchSize, offset], (err, rows) => {
            if (err) {
                console.error('批量处理失败:', err.message);
                return;
            }
            
            if (rows.length === 0) {
                console.log('数据处理完成');
                return;
            }
            
            // 处理当前批次
            rows.forEach(row => {
                // 处理每一行数据
                processRow(row);
            });
            
            offset += batchSize;
            
            // 使用setImmediate避免阻塞事件循环
            setImmediate(processBatch);
        });
    }
    
    processBatch();
}

function processRow(row) {
    // 处理单行数据的逻辑
    console.log('处理行:', row.id);
}
```

**及时释放资源**：
```javascript
// 及时关闭数据库连接
class DatabaseManager {
    constructor() {
        this.connections = new Map();
    }
    
    getConnection(name) {
        if (!this.connections.has(name)) {
            const db = new sqlite3.Database(`./${name}.db`);
            this.connections.set(name, db);
        }
        return this.connections.get(name);
    }
    
    closeConnection(name) {
        const db = this.connections.get(name);
        if (db) {
            db.close((err) => {
                if (err) {
                    console.error('关闭连接失败:', err.message);
                } else {
                    console.log(`连接 ${name} 已关闭`);
                    this.connections.delete(name);
                }
            });
        }
    }
    
    closeAllConnections() {
        for (const [name, db] of this.connections) {
            this.closeConnection(name);
        }
    }
}
```

---

## 预编译语句优化

### 1. 预编译语句的优势

**性能提升**：
```javascript
// 不使用预编译语句（每次都要解析SQL）
function insertUserWithoutPrepare(userData) {
    const sql = 'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)';
    
    db.run(sql, [userData.username, userData.email, userData.password_hash], function(err) {
        if (err) {
            console.error('插入失败:', err.message);
        } else {
            console.log('用户插入成功, ID:', this.lastID);
        }
    });
}

// 使用预编译语句（SQL只解析一次）
const insertUserStmt = db.prepare('INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)');

function insertUserWithPrepare(userData) {
    insertUserStmt.run([userData.username, userData.email, userData.password_hash], function(err) {
        if (err) {
            console.error('插入失败:', err.message);
        } else {
            console.log('用户插入成功, ID:', this.lastID);
        }
    });
}
```

### 2. 预编译语句管理

**语句池管理**：
```javascript
class StatementPool {
    constructor() {
        this.statements = new Map();
    }
    
    getStatement(sql) {
        if (!this.statements.has(sql)) {
            const stmt = db.prepare(sql);
            this.statements.set(sql, stmt);
        }
        return this.statements.get(sql);
    }
    
    finalizeStatement(sql) {
        const stmt = this.statements.get(sql);
        if (stmt) {
            stmt.finalize();
            this.statements.delete(sql);
        }
    }
    
    finalizeAll() {
        for (const [sql, stmt] of this.statements) {
            stmt.finalize();
        }
        this.statements.clear();
    }
}

// 使用示例
const stmtPool = new StatementPool();

function insertUser(userData) {
    const sql = 'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)';
    const stmt = stmtPool.getStatement(sql);
    
    stmt.run([userData.username, userData.email, userData.password_hash], function(err) {
        if (err) {
            console.error('插入失败:', err.message);
        } else {
            console.log('用户插入成功, ID:', this.lastID);
        }
    });
}
```

---

## 批量操作优化

### 1. 批量插入优化

**事务批量插入**：
```javascript
// 高效的批量插入
function batchInsertUsers(users) {
    return new Promise((resolve, reject) => {
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            const stmt = db.prepare('INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)');
            
            let successCount = 0;
            let errorCount = 0;
            
            users.forEach((user, index) => {
                stmt.run([user.username, user.email, user.password_hash], function(err) {
                    if (err) {
                        errorCount++;
                        console.error(`用户 ${index} 插入失败:`, err.message);
                    } else {
                        successCount++;
                    }
                });
            });
            
            stmt.finalize();
            
            db.run('COMMIT', (err) => {
                if (err) {
                    console.error('批量插入提交失败:', err.message);
                    reject(err);
                } else {
                    console.log(`批量插入完成: 成功 ${successCount}, 失败 ${errorCount}`);
                    resolve({ success: successCount, failed: errorCount });
                }
            });
        });
    });
}
```

### 2. 批量更新优化

**批量更新**：
```javascript
// 批量更新用户状态
function batchUpdateUserStatus(updates) {
    return new Promise((resolve, reject) => {
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            const stmt = db.prepare('UPDATE users SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?');
            
            let successCount = 0;
            
            updates.forEach(update => {
                stmt.run([update.status, update.id], function(err) {
                    if (err) {
                        console.error(`用户 ${update.id} 更新失败:`, err.message);
                    } else {
                        successCount += this.changes;
                    }
                });
            });
            
            stmt.finalize();
            
            db.run('COMMIT', (err) => {
                if (err) {
                    console.error('批量更新提交失败:', err.message);
                    reject(err);
                } else {
                    console.log(`批量更新完成: 影响 ${successCount} 行`);
                    resolve(successCount);
                }
            });
        });
    });
}
```

---

## 连接池管理

### 1. 简单连接池

**基础连接池**：
```javascript
class SimpleConnectionPool {
    constructor(maxConnections = 5) {
        this.maxConnections = maxConnections;
        this.connections = [];
        this.available = [];
        this.busy = new Set();
    }
    
    createConnection() {
        return new sqlite3.Database('./app.db');
    }
    
    getConnection() {
        return new Promise((resolve, reject) => {
            if (this.available.length > 0) {
                const connection = this.available.pop();
                this.busy.add(connection);
                resolve(connection);
            } else if (this.connections.length < this.maxConnections) {
                const connection = this.createConnection();
                this.connections.push(connection);
                this.busy.add(connection);
                resolve(connection);
            } else {
                // 等待可用连接
                setTimeout(() => {
                    this.getConnection().then(resolve).catch(reject);
                }, 100);
            }
        });
    }
    
    releaseConnection(connection) {
        if (this.busy.has(connection)) {
            this.busy.delete(connection);
            this.available.push(connection);
        }
    }
    
    closeAll() {
        this.connections.forEach(conn => {
            conn.close();
        });
        this.connections = [];
        this.available = [];
        this.busy.clear();
    }
}
```

### 2. 高级连接池

**带健康检查的连接池**：
```javascript
class AdvancedConnectionPool {
    constructor(maxConnections = 5, healthCheckInterval = 30000) {
        this.maxConnections = maxConnections;
        this.connections = new Map();
        this.available = [];
        this.busy = new Set();
        this.healthCheckInterval = healthCheckInterval;
        
        this.startHealthCheck();
    }
    
    createConnection() {
        const id = Date.now() + Math.random();
        const connection = new sqlite3.Database('./app.db');
        
        this.connections.set(id, {
            connection: connection,
            createdAt: Date.now(),
            lastUsed: Date.now(),
            isHealthy: true
        });
        
        return { id, connection };
    }
    
    async getConnection() {
        // 尝试获取可用连接
        for (let i = 0; i < this.available.length; i++) {
            const connInfo = this.available[i];
            if (connInfo.isHealthy) {
                this.available.splice(i, 1);
                this.busy.add(connInfo);
                connInfo.lastUsed = Date.now();
                return connInfo;
            }
        }
        
        // 创建新连接
        if (this.connections.size < this.maxConnections) {
            const { id, connection } = this.createConnection();
            const connInfo = this.connections.get(id);
            this.busy.add(connInfo);
            return connInfo;
        }
        
        // 等待可用连接
        return new Promise((resolve) => {
            setTimeout(() => {
                this.getConnection().then(resolve);
            }, 100);
        });
    }
    
    releaseConnection(connInfo) {
        if (this.busy.has(connInfo)) {
            this.busy.delete(connInfo);
            this.available.push(connInfo);
        }
    }
    
    startHealthCheck() {
        setInterval(() => {
            this.healthCheck();
        }, this.healthCheckInterval);
    }
    
    healthCheck() {
        for (const [id, connInfo] of this.connections) {
            if (!connInfo.isHealthy) continue;
            
            // 简单的健康检查
            connInfo.connection.get('SELECT 1', (err) => {
                if (err) {
                    console.error(`连接 ${id} 健康检查失败:`, err.message);
                    connInfo.isHealthy = false;
                }
            });
        }
    }
}
```

---

## 监控与调试

### 1. 性能监控

**查询性能监控**：
```javascript
class QueryMonitor {
    constructor() {
        this.queries = new Map();
        this.slowQueryThreshold = 100; // 100ms
    }
    
    startQuery(sql, params) {
        const queryId = Date.now() + Math.random();
        this.queries.set(queryId, {
            sql: sql,
            params: params,
            startTime: Date.now()
        });
        return queryId;
    }
    
    endQuery(queryId) {
        const query = this.queries.get(queryId);
        if (!query) return;
        
        const duration = Date.now() - query.startTime;
        query.duration = duration;
        
        if (duration > this.slowQueryThreshold) {
            console.warn('慢查询 detected:', {
                sql: query.sql,
                params: query.params,
                duration: duration + 'ms'
            });
        }
        
        this.queries.delete(queryId);
        return query;
    }
    
    getStats() {
        const stats = {
            totalQueries: 0,
            slowQueries: 0,
            averageDuration: 0
        };
        
        for (const query of this.queries.values()) {
            stats.totalQueries++;
            if (query.duration > this.slowQueryThreshold) {
                stats.slowQueries++;
            }
            stats.averageDuration += query.duration;
        }
        
        if (stats.totalQueries > 0) {
            stats.averageDuration = Math.round(stats.averageDuration / stats.totalQueries);
        }
        
        return stats;
    }
}

// 使用示例
const monitor = new QueryMonitor();

function monitoredQuery(sql, params, callback) {
    const queryId = monitor.startQuery(sql, params);
    
    db.all(sql, params, (err, rows) => {
        const query = monitor.endQuery(queryId);
        if (query) {
            console.log(`查询耗时: ${query.duration}ms`);
        }
        callback(err, rows);
    });
}
```

### 2. 调试工具

**SQL调试器**：
```javascript
class SQLDebugger {
    constructor() {
        this.enabled = false;
        this.logLevel = 'info'; // debug, info, warn, error
    }
    
    enable(level = 'info') {
        this.enabled = true;
        this.logLevel = level;
    }
    
    disable() {
        this.enabled = false;
    }
    
    log(level, message, data = null) {
        if (!this.enabled) return;
        
        const levels = { debug: 0, info: 1, warn: 2, error: 3 };
        if (levels[level] < levels[this.logLevel]) return;
        
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`);
        
        if (data) {
            console.log(JSON.stringify(data, null, 2));
        }
    }
    
    debug(message, data) {
        this.log('debug', message, data);
    }
    
    info(message, data) {
        this.log('info', message, data);
    }
    
    warn(message, data) {
        this.log('warn', message, data);
    }
    
    error(message, data) {
        this.log('error', message, data);
    }
}

// 使用示例
const debugger = new SQLDebugger();
debugger.enable('debug');

function debugQuery(sql, params) {
    debugger.debug('执行SQL查询', { sql, params });
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            debugger.error('查询失败', { error: err.message, sql, params });
        } else {
            debugger.info('查询成功', { rowCount: rows.length });
        }
    });
}
```

---

## 总结

通过本章的学习，您已经掌握了SQLite的高级特性和性能优化技巧：

1. **WAL模式**：提升并发性能，支持读写并发
2. **索引优化**：合理创建索引，提升查询性能
3. **查询优化**：避免低效查询，使用缓存机制
4. **内存管理**：监控内存使用，及时释放资源
5. **预编译语句**：提升重复查询性能
6. **批量操作**：使用事务提升批量操作效率
7. **连接池**：管理数据库连接，提升并发能力
8. **监控调试**：实时监控性能，快速定位问题

这些优化技巧将帮助您构建高性能的SQLite应用。

---

*下一章：[最佳实践与实际应用案例](./05-最佳实践与实际应用案例.md)*
