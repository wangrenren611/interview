# 最佳实践与实际应用案例

## 目录
1. [项目架构设计](#项目架构设计)
2. [数据模型设计](#数据模型设计)
3. [API设计规范](#api设计规范)
4. [安全最佳实践](#安全最佳实践)
5. [实际应用案例](#实际应用案例)
6. [部署与运维](#部署与运维)
7. [测试策略](#测试策略)

---

## 项目架构设计

### 1. 分层架构设计

**标准分层架构**：
```
┌─────────────────────────────────────┐
│           表现层 (Presentation)     │
│         Routes, Controllers         │
├─────────────────────────────────────┤
│           业务层 (Business)         │
│         Services, Models           │
├─────────────────────────────────────┤
│           数据层 (Data)             │
│         Database, Repositories     │
├─────────────────────────────────────┤
│           基础设施层 (Infrastructure)│
│         Config, Utils, Middleware  │
└─────────────────────────────────────┘
```

**项目结构示例**：
```
src/
├── controllers/          # 控制器层
│   ├── userController.js
│   ├── postController.js
│   └── authController.js
├── services/            # 业务逻辑层
│   ├── userService.js
│   ├── postService.js
│   └── authService.js
├── models/              # 数据模型层
│   ├── User.js
│   ├── Post.js
│   └── Comment.js
├── repositories/        # 数据访问层
│   ├── userRepository.js
│   ├── postRepository.js
│   └── baseRepository.js
├── database/            # 数据库层
│   ├── connection.js
│   ├── migrations/
│   └── seeds/
├── middleware/          # 中间件
│   ├── auth.js
│   ├── validation.js
│   └── errorHandler.js
├── routes/              # 路由层
│   ├── userRoutes.js
│   ├── postRoutes.js
│   └── authRoutes.js
├── utils/               # 工具类
│   ├── logger.js
│   ├── validator.js
│   └── crypto.js
└── config/              # 配置文件
    ├── database.js
    ├── app.js
    └── env.js
```

### 2. 依赖注入模式

**服务容器**：
```javascript
// config/container.js
class ServiceContainer {
    constructor() {
        this.services = new Map();
        this.singletons = new Map();
    }
    
    register(name, factory, singleton = false) {
        this.services.set(name, { factory, singleton });
    }
    
    get(name) {
        const service = this.services.get(name);
        if (!service) {
            throw new Error(`Service ${name} not found`);
        }
        
        if (service.singleton) {
            if (!this.singletons.has(name)) {
                this.singletons.set(name, service.factory(this));
            }
            return this.singletons.get(name);
        }
        
        return service.factory(this);
    }
}

// 注册服务
const container = new ServiceContainer();

// 数据库连接
container.register('database', () => {
    const sqlite3 = require('sqlite3').verbose();
    return new sqlite3.Database('./app.db');
}, true);

// 用户仓库
container.register('userRepository', (container) => {
    const UserRepository = require('../repositories/userRepository');
    return new UserRepository(container.get('database'));
});

// 用户服务
container.register('userService', (container) => {
    const UserService = require('../services/userService');
    return new UserService(container.get('userRepository'));
});

module.exports = container;
```

---

## 数据模型设计

### 1. 实体关系设计

**用户系统ER图**：
```javascript
// models/User.js
class User {
    constructor(data) {
        this.id = data.id;
        this.username = data.username;
        this.email = data.email;
        this.passwordHash = data.password_hash;
        this.status = data.status || 'active';
        this.createdAt = data.created_at;
        this.updatedAt = data.updated_at;
    }
    
    // 验证方法
    validate() {
        const errors = [];
        
        if (!this.username || this.username.length < 3) {
            errors.push('用户名至少3个字符');
        }
        
        if (!this.email || !this.isValidEmail(this.email)) {
            errors.push('邮箱格式不正确');
        }
        
        return errors;
    }
    
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    // 转换为数据库格式
    toDatabase() {
        return {
            username: this.username,
            email: this.email,
            password_hash: this.passwordHash,
            status: this.status
        };
    }
    
    // 从数据库创建实例
    static fromDatabase(data) {
        return new User(data);
    }
}

module.exports = User;
```

**文章系统模型**：
```javascript
// models/Post.js
class Post {
    constructor(data) {
        this.id = data.id;
        this.title = data.title;
        this.content = data.content;
        this.authorId = data.author_id;
        this.status = data.status || 'draft';
        this.viewCount = data.view_count || 0;
        this.createdAt = data.created_at;
        this.updatedAt = data.updated_at;
        
        // 关联数据
        this.author = data.author;
        this.comments = data.comments || [];
        this.tags = data.tags || [];
    }
    
    validate() {
        const errors = [];
        
        if (!this.title || this.title.trim().length === 0) {
            errors.push('标题不能为空');
        }
        
        if (!this.content || this.content.trim().length === 0) {
            errors.push('内容不能为空');
        }
        
        if (!this.authorId) {
            errors.push('作者ID不能为空');
        }
        
        return errors;
    }
    
    // 发布文章
    publish() {
        this.status = 'published';
        this.updatedAt = new Date().toISOString();
    }
    
    // 增加浏览量
    incrementViewCount() {
        this.viewCount++;
        this.updatedAt = new Date().toISOString();
    }
    
    toDatabase() {
        return {
            title: this.title,
            content: this.content,
            author_id: this.authorId,
            status: this.status,
            view_count: this.viewCount
        };
    }
    
    static fromDatabase(data) {
        return new Post(data);
    }
}

module.exports = Post;
```

### 2. 数据访问层设计

**基础仓库类**：
```javascript
// repositories/baseRepository.js
class BaseRepository {
    constructor(db, tableName) {
        this.db = db;
        this.tableName = tableName;
    }
    
    // 查找所有记录
    async findAll(conditions = {}, options = {}) {
        return new Promise((resolve, reject) => {
            let sql = `SELECT * FROM ${this.tableName}`;
            const params = [];
            
            if (Object.keys(conditions).length > 0) {
                const whereClause = Object.keys(conditions)
                    .map(key => `${key} = ?`)
                    .join(' AND ');
                sql += ` WHERE ${whereClause}`;
                params.push(...Object.values(conditions));
            }
            
            if (options.orderBy) {
                sql += ` ORDER BY ${options.orderBy}`;
            }
            
            if (options.limit) {
                sql += ` LIMIT ${options.limit}`;
                if (options.offset) {
                    sql += ` OFFSET ${options.offset}`;
                }
            }
            
            this.db.all(sql, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
    
    // 根据ID查找
    async findById(id) {
        return new Promise((resolve, reject) => {
            const sql = `SELECT * FROM ${this.tableName} WHERE id = ?`;
            this.db.get(sql, [id], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }
    
    // 创建记录
    async create(data) {
        return new Promise((resolve, reject) => {
            const columns = Object.keys(data);
            const placeholders = columns.map(() => '?').join(', ');
            const values = Object.values(data);
            
            const sql = `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            
            this.db.run(sql, values, function(err) {
                if (err) reject(err);
                else resolve({ id: this.lastID, changes: this.changes });
            });
        });
    }
    
    // 更新记录
    async update(id, data) {
        return new Promise((resolve, reject) => {
            const columns = Object.keys(data);
            const setClause = columns.map(col => `${col} = ?`).join(', ');
            const values = [...Object.values(data), id];
            
            const sql = `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`;
            
            this.db.run(sql, values, function(err) {
                if (err) reject(err);
                else resolve({ changes: this.changes });
            });
        });
    }
    
    // 删除记录
    async delete(id) {
        return new Promise((resolve, reject) => {
            const sql = `DELETE FROM ${this.tableName} WHERE id = ?`;
            this.db.run(sql, [id], function(err) {
                if (err) reject(err);
                else resolve({ changes: this.changes });
            });
        });
    }
}

module.exports = BaseRepository;
```

**用户仓库**：
```javascript
// repositories/userRepository.js
const BaseRepository = require('./baseRepository');
const User = require('../models/User');

class UserRepository extends BaseRepository {
    constructor(db) {
        super(db, 'users');
    }
    
    // 根据用户名查找
    async findByUsername(username) {
        return new Promise((resolve, reject) => {
            const sql = 'SELECT * FROM users WHERE username = ?';
            this.db.get(sql, [username], (err, row) => {
                if (err) reject(err);
                else resolve(row ? User.fromDatabase(row) : null);
            });
        });
    }
    
    // 根据邮箱查找
    async findByEmail(email) {
        return new Promise((resolve, reject) => {
            const sql = 'SELECT * FROM users WHERE email = ?';
            this.db.get(sql, [email], (err, row) => {
                if (err) reject(err);
                else resolve(row ? User.fromDatabase(row) : null);
            });
        });
    }
    
    // 创建用户
    async createUser(userData) {
        const user = new User(userData);
        const errors = user.validate();
        
        if (errors.length > 0) {
            throw new Error(`验证失败: ${errors.join(', ')}`);
        }
        
        const result = await this.create(user.toDatabase());
        return { ...user, id: result.id };
    }
    
    // 更新用户
    async updateUser(id, userData) {
        const user = new User({ ...userData, id });
        const errors = user.validate();
        
        if (errors.length > 0) {
            throw new Error(`验证失败: ${errors.join(', ')}`);
        }
        
        return await this.update(id, user.toDatabase());
    }
}

module.exports = UserRepository;
```

---

## API设计规范

### 1. RESTful API设计

**用户API路由**：
```javascript
// routes/userRoutes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const authMiddleware = require('../middleware/auth');
const validationMiddleware = require('../middleware/validation');

// 获取用户列表
router.get('/', 
    validationMiddleware.validatePagination,
    userController.getUsers
);

// 获取单个用户
router.get('/:id', 
    validationMiddleware.validateId,
    userController.getUser
);

// 创建用户
router.post('/', 
    validationMiddleware.validateUser,
    userController.createUser
);

// 更新用户
router.put('/:id', 
    authMiddleware.authenticate,
    validationMiddleware.validateId,
    validationMiddleware.validateUserUpdate,
    userController.updateUser
);

// 删除用户
router.delete('/:id', 
    authMiddleware.authenticate,
    authMiddleware.authorize('admin'),
    validationMiddleware.validateId,
    userController.deleteUser
);

module.exports = router;
```

**用户控制器**：
```javascript
// controllers/userController.js
class UserController {
    constructor(userService) {
        this.userService = userService;
    }
    
    // 获取用户列表
    async getUsers(req, res) {
        try {
            const { page = 1, limit = 10, search } = req.query;
            const result = await this.userService.getUsers({
                page: parseInt(page),
                limit: parseInt(limit),
                search
            });
            
            res.json({
                success: true,
                data: result.users,
                pagination: {
                    page: result.page,
                    limit: result.limit,
                    total: result.total,
                    pages: result.pages
                }
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: '获取用户列表失败',
                error: error.message
            });
        }
    }
    
    // 获取单个用户
    async getUser(req, res) {
        try {
            const { id } = req.params;
            const user = await this.userService.getUserById(id);
            
            if (!user) {
                return res.status(404).json({
                    success: false,
                    message: '用户不存在'
                });
            }
            
            res.json({
                success: true,
                data: user
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: '获取用户失败',
                error: error.message
            });
        }
    }
    
    // 创建用户
    async createUser(req, res) {
        try {
            const userData = req.body;
            const user = await this.userService.createUser(userData);
            
            res.status(201).json({
                success: true,
                message: '用户创建成功',
                data: user
            });
        } catch (error) {
            res.status(400).json({
                success: false,
                message: '创建用户失败',
                error: error.message
            });
        }
    }
    
    // 更新用户
    async updateUser(req, res) {
        try {
            const { id } = req.params;
            const userData = req.body;
            const user = await this.userService.updateUser(id, userData);
            
            res.json({
                success: true,
                message: '用户更新成功',
                data: user
            });
        } catch (error) {
            res.status(400).json({
                success: false,
                message: '更新用户失败',
                error: error.message
            });
        }
    }
    
    // 删除用户
    async deleteUser(req, res) {
        try {
            const { id } = req.params;
            await this.userService.deleteUser(id);
            
            res.json({
                success: true,
                message: '用户删除成功'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: '删除用户失败',
                error: error.message
            });
        }
    }
}

module.exports = UserController;
```

### 2. 错误处理中间件

**统一错误处理**：
```javascript
// middleware/errorHandler.js
class ErrorHandler {
    static handle(err, req, res, next) {
        console.error('Error:', err);
        
        // 数据库错误
        if (err.code && err.code.startsWith('SQLITE_')) {
            return res.status(400).json({
                success: false,
                message: '数据库操作失败',
                error: this.getDatabaseErrorMessage(err)
            });
        }
        
        // 验证错误
        if (err.name === 'ValidationError') {
            return res.status(400).json({
                success: false,
                message: '数据验证失败',
                errors: err.errors
            });
        }
        
        // 认证错误
        if (err.name === 'AuthenticationError') {
            return res.status(401).json({
                success: false,
                message: '认证失败',
                error: err.message
            });
        }
        
        // 授权错误
        if (err.name === 'AuthorizationError') {
            return res.status(403).json({
                success: false,
                message: '权限不足',
                error: err.message
            });
        }
        
        // 默认错误
        res.status(500).json({
            success: false,
            message: '服务器内部错误',
            error: process.env.NODE_ENV === 'development' ? err.message : '未知错误'
        });
    }
    
    static getDatabaseErrorMessage(err) {
        const messages = {
            'SQLITE_CONSTRAINT': '数据约束错误',
            'SQLITE_BUSY': '数据库忙碌，请稍后重试',
            'SQLITE_LOCKED': '数据库被锁定',
            'SQLITE_NOTFOUND': '数据不存在'
        };
        
        return messages[err.code] || '数据库操作失败';
    }
}

module.exports = ErrorHandler;
```

---

## 安全最佳实践

### 1. 输入验证

**数据验证中间件**：
```javascript
// middleware/validation.js
const Joi = require('joi');

class ValidationMiddleware {
    // 用户数据验证
    static validateUser(req, res, next) {
        const schema = Joi.object({
            username: Joi.string().alphanum().min(3).max(30).required(),
            email: Joi.string().email().required(),
            password: Joi.string().min(6).required()
        });
        
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({
                success: false,
                message: '数据验证失败',
                errors: error.details.map(detail => detail.message)
            });
        }
        
        next();
    }
    
    // 分页参数验证
    static validatePagination(req, res, next) {
        const schema = Joi.object({
            page: Joi.number().integer().min(1).default(1),
            limit: Joi.number().integer().min(1).max(100).default(10),
            search: Joi.string().max(100).optional()
        });
        
        const { error, value } = schema.validate(req.query);
        if (error) {
            return res.status(400).json({
                success: false,
                message: '分页参数验证失败',
                errors: error.details.map(detail => detail.message)
            });
        }
        
        req.query = value;
        next();
    }
    
    // ID参数验证
    static validateId(req, res, next) {
        const schema = Joi.object({
            id: Joi.number().integer().positive().required()
        });
        
        const { error } = schema.validate(req.params);
        if (error) {
            return res.status(400).json({
                success: false,
                message: 'ID参数验证失败',
                errors: error.details.map(detail => detail.message)
            });
        }
        
        next();
    }
}

module.exports = ValidationMiddleware;
```

### 2. 密码安全

**密码加密服务**：
```javascript
// services/passwordService.js
const bcrypt = require('bcrypt');
const crypto = require('crypto');

class PasswordService {
    constructor() {
        this.saltRounds = 12;
    }
    
    // 加密密码
    async hashPassword(password) {
        try {
            const salt = await bcrypt.genSalt(this.saltRounds);
            const hash = await bcrypt.hash(password, salt);
            return hash;
        } catch (error) {
            throw new Error('密码加密失败');
        }
    }
    
    // 验证密码
    async verifyPassword(password, hash) {
        try {
            return await bcrypt.compare(password, hash);
        } catch (error) {
            throw new Error('密码验证失败');
        }
    }
    
    // 生成随机密码
    generateRandomPassword(length = 12) {
        const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
        let password = '';
        
        for (let i = 0; i < length; i++) {
            const randomIndex = crypto.randomInt(0, charset.length);
            password += charset[randomIndex];
        }
        
        return password;
    }
    
    // 密码强度检查
    checkPasswordStrength(password) {
        const checks = {
            length: password.length >= 8,
            lowercase: /[a-z]/.test(password),
            uppercase: /[A-Z]/.test(password),
            numbers: /\d/.test(password),
            symbols: /[!@#$%^&*(),.?":{}|<>]/.test(password)
        };
        
        const score = Object.values(checks).filter(Boolean).length;
        
        return {
            score,
            strength: score < 3 ? 'weak' : score < 5 ? 'medium' : 'strong',
            checks
        };
    }
}

module.exports = new PasswordService();
```

### 3. 认证与授权

**JWT认证中间件**：
```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');

class AuthMiddleware {
    constructor() {
        this.secretKey = process.env.JWT_SECRET || 'your-secret-key';
        this.tokenExpiry = process.env.JWT_EXPIRY || '24h';
    }
    
    // 生成JWT令牌
    generateToken(payload) {
        return jwt.sign(payload, this.secretKey, { expiresIn: this.tokenExpiry });
    }
    
    // 验证JWT令牌
    verifyToken(token) {
        try {
            return jwt.verify(token, this.secretKey);
        } catch (error) {
            throw new Error('令牌无效或已过期');
        }
    }
    
    // 认证中间件
    authenticate(req, res, next) {
        try {
            const authHeader = req.headers.authorization;
            
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                return res.status(401).json({
                    success: false,
                    message: '缺少认证令牌'
                });
            }
            
            const token = authHeader.substring(7);
            const decoded = this.verifyToken(token);
            
            req.user = decoded;
            next();
        } catch (error) {
            res.status(401).json({
                success: false,
                message: '认证失败',
                error: error.message
            });
        }
    }
    
    // 授权中间件
    authorize(requiredRole) {
        return (req, res, next) => {
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: '未认证'
                });
            }
            
            if (req.user.role !== requiredRole && req.user.role !== 'admin') {
                return res.status(403).json({
                    success: false,
                    message: '权限不足'
                });
            }
            
            next();
        };
    }
}

module.exports = new AuthMiddleware();
```

---

## 实际应用案例

### 1. 博客系统

**完整的博客系统实现**：
```javascript
// 博客系统主应用
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

const app = express();

// 安全中间件
app.use(helmet());
app.use(cors());

// 限流中间件
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100 // 限制每个IP 15分钟内最多100个请求
});
app.use(limiter);

// 路由
app.use('/api/auth', require('./routes/authRoutes'));
app.use('/api/users', require('./routes/userRoutes'));
app.use('/api/posts', require('./routes/postRoutes'));
app.use('/api/comments', require('./routes/commentRoutes'));

// 错误处理
app.use(require('./middleware/errorHandler'));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`博客系统运行在端口 ${PORT}`);
});
```

### 2. 任务管理系统

**任务管理API**：
```javascript
// services/taskService.js
class TaskService {
    constructor(taskRepository, userRepository) {
        this.taskRepository = taskRepository;
        this.userRepository = userRepository;
    }
    
    // 创建任务
    async createTask(userId, taskData) {
        const task = {
            ...taskData,
            user_id: userId,
            status: 'pending',
            created_at: new Date().toISOString()
        };
        
        return await this.taskRepository.create(task);
    }
    
    // 获取用户任务
    async getUserTasks(userId, filters = {}) {
        const conditions = { user_id: userId };
        
        if (filters.status) {
            conditions.status = filters.status;
        }
        
        if (filters.priority) {
            conditions.priority = filters.priority;
        }
        
        return await this.taskRepository.findAll(conditions, {
            orderBy: 'created_at DESC',
            limit: filters.limit || 20,
            offset: filters.offset || 0
        });
    }
    
    // 更新任务状态
    async updateTaskStatus(taskId, status, userId) {
        const task = await this.taskRepository.findById(taskId);
        
        if (!task) {
            throw new Error('任务不存在');
        }
        
        if (task.user_id !== userId) {
            throw new Error('无权操作此任务');
        }
        
        return await this.taskRepository.update(taskId, {
            status,
            updated_at: new Date().toISOString()
        });
    }
    
    // 获取任务统计
    async getTaskStats(userId) {
        const tasks = await this.taskRepository.findAll({ user_id: userId });
        
        const stats = {
            total: tasks.length,
            pending: tasks.filter(t => t.status === 'pending').length,
            in_progress: tasks.filter(t => t.status === 'in_progress').length,
            completed: tasks.filter(t => t.status === 'completed').length,
            overdue: tasks.filter(t => 
                t.due_date && new Date(t.due_date) < new Date() && t.status !== 'completed'
            ).length
        };
        
        return stats;
    }
}

module.exports = TaskService;
```

### 3. 数据分析系统

**数据分析服务**：
```javascript
// services/analyticsService.js
class AnalyticsService {
    constructor(db) {
        this.db = db;
    }
    
    // 用户行为分析
    async getUserBehaviorAnalytics(startDate, endDate) {
        const query = `
            SELECT 
                DATE(created_at) as date,
                COUNT(*) as user_count,
                COUNT(CASE WHEN status = 'active' THEN 1 END) as active_users
            FROM users
            WHERE created_at BETWEEN ? AND ?
            GROUP BY DATE(created_at)
            ORDER BY date
        `;
        
        return new Promise((resolve, reject) => {
            this.db.all(query, [startDate, endDate], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
    
    // 内容分析
    async getContentAnalytics() {
        const query = `
            SELECT 
                p.status,
                COUNT(*) as post_count,
                AVG(p.view_count) as avg_views,
                COUNT(c.id) as comment_count
            FROM posts p
            LEFT JOIN comments c ON p.id = c.post_id
            GROUP BY p.status
        `;
        
        return new Promise((resolve, reject) => {
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
    
    // 性能分析
    async getPerformanceMetrics() {
        const queries = [
            'SELECT COUNT(*) as total_users FROM users',
            'SELECT COUNT(*) as total_posts FROM posts',
            'SELECT COUNT(*) as total_comments FROM comments',
            'SELECT AVG(view_count) as avg_views FROM posts WHERE status = "published"'
        ];
        
        const results = {};
        
        for (const query of queries) {
            const result = await new Promise((resolve, reject) => {
                this.db.get(query, [], (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                });
            });
            
            Object.assign(results, result);
        }
        
        return results;
    }
}

module.exports = AnalyticsService;
```

---

## 部署与运维

### 1. Docker部署

**Dockerfile**：
```dockerfile
FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# 设置权限
RUN chown -R nodejs:nodejs /app
USER nodejs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node healthcheck.js

# 启动应用
CMD ["node", "app.js"]
```

**docker-compose.yml**：
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
    volumes:
      - ./data:/app/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
```

### 2. 监控与日志

**日志配置**：
```javascript
// utils/logger.js
const winston = require('winston');
const path = require('path');

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
    ),
    defaultMeta: { service: 'sqlite-app' },
    transports: [
        new winston.transports.File({ 
            filename: path.join('logs', 'error.log'), 
            level: 'error' 
        }),
        new winston.transports.File({ 
            filename: path.join('logs', 'combined.log') 
        })
    ]
});

if (process.env.NODE_ENV !== 'production') {
    logger.add(new winston.transports.Console({
        format: winston.format.simple()
    }));
}

module.exports = logger;
```

**健康检查**：
```javascript
// healthcheck.js
const http = require('http');
const sqlite3 = require('sqlite3').verbose();

const options = {
    hostname: 'localhost',
    port: process.env.PORT || 3000,
    path: '/health',
    method: 'GET',
    timeout: 2000
};

const req = http.request(options, (res) => {
    if (res.statusCode === 200) {
        console.log('Health check passed');
        process.exit(0);
    } else {
        console.log('Health check failed');
        process.exit(1);
    }
});

req.on('error', (err) => {
    console.error('Health check error:', err.message);
    process.exit(1);
});

req.on('timeout', () => {
    console.error('Health check timeout');
    req.destroy();
    process.exit(1);
});

req.end();
```

---

## 测试策略

### 1. 单元测试

**用户服务测试**：
```javascript
// tests/services/userService.test.js
const assert = require('assert');
const UserService = require('../../src/services/userService');
const UserRepository = require('../../src/repositories/userRepository');

describe('UserService', () => {
    let userService;
    let mockRepository;
    
    beforeEach(() => {
        mockRepository = {
            create: () => Promise.resolve({ id: 1 }),
            findById: () => Promise.resolve(null),
            findByUsername: () => Promise.resolve(null),
            findByEmail: () => Promise.resolve(null)
        };
        
        userService = new UserService(mockRepository);
    });
    
    describe('createUser', () => {
        it('should create a user successfully', async () => {
            const userData = {
                username: 'testuser',
                email: 'test@example.com',
                password: 'password123'
            };
            
            const result = await userService.createUser(userData);
            
            assert(result.id === 1);
            assert(result.username === 'testuser');
        });
        
        it('should throw error for invalid email', async () => {
            const userData = {
                username: 'testuser',
                email: 'invalid-email',
                password: 'password123'
            };
            
            try {
                await userService.createUser(userData);
                assert.fail('Should have thrown an error');
            } catch (error) {
                assert(error.message.includes('邮箱格式不正确'));
            }
        });
    });
});
```

### 2. 集成测试

**API集成测试**：
```javascript
// tests/integration/userApi.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('User API', () => {
    describe('POST /api/users', () => {
        it('should create a new user', async () => {
            const userData = {
                username: 'testuser',
                email: 'test@example.com',
                password: 'password123'
            };
            
            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(201);
            
            assert(response.body.success === true);
            assert(response.body.data.username === 'testuser');
        });
        
        it('should return 400 for invalid data', async () => {
            const userData = {
                username: 'ab', // 太短
                email: 'invalid-email',
                password: '123' // 太短
            };
            
            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(400);
            
            assert(response.body.success === false);
        });
    });
});
```

---

## 总结

通过本章的学习，您已经掌握了Node.js与SQLite开发的最佳实践：

1. **项目架构**：分层架构设计，依赖注入模式
2. **数据模型**：实体关系设计，数据访问层
3. **API设计**：RESTful规范，统一错误处理
4. **安全实践**：输入验证，密码安全，认证授权
5. **实际应用**：博客系统，任务管理，数据分析
6. **部署运维**：Docker部署，监控日志
7. **测试策略**：单元测试，集成测试

这些最佳实践将帮助您构建高质量、可维护的SQLite应用。

---

*下一章：[错误处理与故障排除](./06-错误处理与故障排除.md)*
