# 错误处理与故障排除

## 目录
1. [常见错误类型](#常见错误类型)
2. [数据库连接错误](#数据库连接错误)
3. [SQL执行错误](#sql执行错误)
4. [性能问题诊断](#性能问题诊断)
5. [数据完整性问题](#数据完整性问题)
6. [调试工具与技巧](#调试工具与技巧)
7. [预防措施](#预防措施)

---

## 常见错误类型

### 1. 连接错误

**数据库文件权限错误**：
```javascript
// 错误示例
const db = new sqlite3.Database('./app.db', (err) => {
    if (err) {
        console.error('连接失败:', err.message);
        // 输出: SQLITE_CANTOPEN: unable to open database file
    }
});

// 解决方案
const fs = require('fs');
const path = require('path');

function ensureDatabaseDirectory(dbPath) {
    const dir = path.dirname(dbPath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
}

// 使用
ensureDatabaseDirectory('./data/app.db');
const db = new sqlite3.Database('./data/app.db');
```

**数据库锁定错误**：
```javascript
// 错误处理
function handleDatabaseError(err, operation) {
    if (err.code === 'SQLITE_BUSY') {
        console.log('数据库忙碌，等待重试...');
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(retryOperation(operation));
            }, 100);
        });
    }
    throw err;
}

async function retryOperation(operation, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await operation();
        } catch (error) {
            if (error.code === 'SQLITE_BUSY' && i < maxRetries - 1) {
                await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
                continue;
            }
            throw error;
        }
    }
}
```

### 2. SQL语法错误

**参数绑定错误**：
```javascript
// 错误示例
db.run('INSERT INTO users (name, email) VALUES (?, ?)', ['John'], (err) => {
    // 错误: SQLITE_MISUSE: number of parameters (1) must match number of placeholders (2)
});

// 正确做法
db.run('INSERT INTO users (name, email) VALUES (?, ?)', ['John', 'john@example.com'], (err) => {
    if (err) {
        console.error('插入失败:', err.message);
    }
});
```

**表不存在错误**：
```javascript
// 错误处理
function safeQuery(sql, params, callback) {
    db.all(sql, params, (err, rows) => {
        if (err) {
            if (err.code === 'SQLITE_ERROR' && err.message.includes('no such table')) {
                console.error('表不存在，请先创建表');
                return callback(new Error('表不存在'));
            }
            return callback(err);
        }
        callback(null, rows);
    });
}
```

---

## 数据库连接错误

### 1. 连接超时

**连接超时处理**：
```javascript
class DatabaseManager {
    constructor(dbPath, options = {}) {
        this.dbPath = dbPath;
        this.timeout = options.timeout || 5000;
        this.retries = options.retries || 3;
        this.db = null;
    }
    
    async connect() {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error('数据库连接超时'));
            }, this.timeout);
            
            this.db = new sqlite3.Database(this.dbPath, (err) => {
                clearTimeout(timeoutId);
                if (err) {
                    reject(err);
                } else {
                    resolve(this.db);
                }
            });
        });
    }
    
    async connectWithRetry() {
        for (let i = 0; i < this.retries; i++) {
            try {
                return await this.connect();
            } catch (error) {
                console.log(`连接尝试 ${i + 1} 失败:`, error.message);
                if (i === this.retries - 1) {
                    throw error;
                }
                await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
            }
        }
    }
}
```

### 2. 连接池管理

**连接池错误处理**：
```javascript
class ConnectionPool {
    constructor(maxConnections = 5) {
        this.maxConnections = maxConnections;
        this.connections = [];
        this.available = [];
        this.busy = new Set();
    }
    
    createConnection() {
        return new Promise((resolve, reject) => {
            const db = new sqlite3.Database('./app.db', (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(db);
                }
            });
        });
    }
    
    async getConnection() {
        if (this.available.length > 0) {
            const connection = this.available.pop();
            this.busy.add(connection);
            return connection;
        }
        
        if (this.connections.length < this.maxConnections) {
            try {
                const connection = await this.createConnection();
                this.connections.push(connection);
                this.busy.add(connection);
                return connection;
            } catch (error) {
                throw new Error(`创建连接失败: ${error.message}`);
            }
        }
        
        throw new Error('连接池已满');
    }
    
    releaseConnection(connection) {
        if (this.busy.has(connection)) {
            this.busy.delete(connection);
            this.available.push(connection);
        }
    }
}
```

---

## SQL执行错误

### 1. 约束违反错误

**唯一约束错误**：
```javascript
function handleUniqueConstraintError(err, operation) {
    if (err.code === 'SQLITE_CONSTRAINT' && err.message.includes('UNIQUE constraint failed')) {
        console.error('数据重复，违反唯一约束');
        return { success: false, error: '数据已存在' };
    }
    throw err;
}

// 使用示例
async function createUser(userData) {
    try {
        const result = await db.run(
            'INSERT INTO users (username, email) VALUES (?, ?)',
            [userData.username, userData.email]
        );
        return { success: true, id: result.lastID };
    } catch (error) {
        return handleUniqueConstraintError(error);
    }
}
```

**外键约束错误**：
```javascript
function handleForeignKeyError(err) {
    if (err.code === 'SQLITE_CONSTRAINT' && err.message.includes('FOREIGN KEY constraint failed')) {
        console.error('外键约束失败，引用的记录不存在');
        return { success: false, error: '引用的数据不存在' };
    }
    throw err;
}
```

### 2. 数据类型错误

**类型转换错误**：
```javascript
function validateAndConvertData(data, schema) {
    const converted = {};
    
    for (const [key, type] of Object.entries(schema)) {
        const value = data[key];
        
        try {
            switch (type) {
                case 'integer':
                    converted[key] = parseInt(value);
                    if (isNaN(converted[key])) {
                        throw new Error(`无效的整数: ${value}`);
                    }
                    break;
                case 'real':
                    converted[key] = parseFloat(value);
                    if (isNaN(converted[key])) {
                        throw new Error(`无效的浮点数: ${value}`);
                    }
                    break;
                case 'text':
                    converted[key] = String(value);
                    break;
                default:
                    converted[key] = value;
            }
        } catch (error) {
            throw new Error(`字段 ${key} 类型转换失败: ${error.message}`);
        }
    }
    
    return converted;
}

// 使用示例
const userSchema = {
    id: 'integer',
    username: 'text',
    age: 'integer',
    score: 'real'
};

try {
    const convertedData = validateAndConvertData(userData, userSchema);
    // 使用转换后的数据
} catch (error) {
    console.error('数据验证失败:', error.message);
}
```

---

## 性能问题诊断

### 1. 慢查询诊断

**查询性能监控**：
```javascript
class QueryProfiler {
    constructor() {
        this.queries = new Map();
        this.slowThreshold = 100; // 100ms
    }
    
    startQuery(sql, params) {
        const queryId = Date.now() + Math.random();
        this.queries.set(queryId, {
            sql,
            params,
            startTime: Date.now()
        });
        return queryId;
    }
    
    endQuery(queryId) {
        const query = this.queries.get(queryId);
        if (!query) return;
        
        const duration = Date.now() - query.startTime;
        query.duration = duration;
        
        if (duration > this.slowThreshold) {
            console.warn('慢查询检测:', {
                sql: query.sql,
                params: query.params,
                duration: `${duration}ms`
            });
        }
        
        this.queries.delete(queryId);
        return query;
    }
    
    getSlowQueries() {
        const slowQueries = [];
        for (const query of this.queries.values()) {
            if (query.duration > this.slowThreshold) {
                slowQueries.push(query);
            }
        }
        return slowQueries;
    }
}

// 使用示例
const profiler = new QueryProfiler();

function profiledQuery(sql, params, callback) {
    const queryId = profiler.startQuery(sql, params);
    
    db.all(sql, params, (err, rows) => {
        const query = profiler.endQuery(queryId);
        if (query && query.duration > 100) {
            console.log(`慢查询: ${query.duration}ms - ${query.sql}`);
        }
        callback(err, rows);
    });
}
```

### 2. 内存泄漏诊断

**内存使用监控**：
```javascript
class MemoryMonitor {
    constructor() {
        this.initialMemory = process.memoryUsage();
        this.peakMemory = this.initialMemory;
    }
    
    checkMemory() {
        const current = process.memoryUsage();
        
        if (current.heapUsed > this.peakMemory.heapUsed) {
            this.peakMemory = current;
        }
        
        const heapGrowth = current.heapUsed - this.initialMemory.heapUsed;
        
        if (heapGrowth > 100 * 1024 * 1024) { // 100MB增长
            console.warn('内存使用增长过多:', {
                initial: Math.round(this.initialMemory.heapUsed / 1024 / 1024) + 'MB',
                current: Math.round(current.heapUsed / 1024 / 1024) + 'MB',
                growth: Math.round(heapGrowth / 1024 / 1024) + 'MB'
            });
        }
        
        return current;
    }
    
    forceGC() {
        if (global.gc) {
            global.gc();
            console.log('强制垃圾回收完成');
        } else {
            console.log('垃圾回收不可用，使用 --expose-gc 启动');
        }
    }
}

// 使用示例
const monitor = new MemoryMonitor();

setInterval(() => {
    monitor.checkMemory();
}, 30000); // 每30秒检查一次
```

---

## 数据完整性问题

### 1. 事务回滚

**事务错误处理**：
```javascript
async function executeTransaction(operations) {
    return new Promise((resolve, reject) => {
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            let completed = 0;
            let hasError = false;
            
            operations.forEach((operation, index) => {
                operation((err, result) => {
                    if (hasError) return;
                    
                    if (err) {
                        hasError = true;
                        console.error(`操作 ${index} 失败:`, err.message);
                        db.run('ROLLBACK', (rollbackErr) => {
                            if (rollbackErr) {
                                console.error('回滚失败:', rollbackErr.message);
                            }
                            reject(err);
                        });
                        return;
                    }
                    
                    completed++;
                    if (completed === operations.length) {
                        db.run('COMMIT', (commitErr) => {
                            if (commitErr) {
                                console.error('提交失败:', commitErr.message);
                                reject(commitErr);
                            } else {
                                resolve('事务执行成功');
                            }
                        });
                    }
                });
            });
        });
    });
}
```

### 2. 数据一致性检查

**数据完整性验证**：
```javascript
class DataIntegrityChecker {
    constructor(db) {
        this.db = db;
    }
    
    async checkIntegrity() {
        const checks = [
            this.checkOrphanedRecords(),
            this.checkDuplicateRecords(),
            this.checkInvalidReferences()
        ];
        
        const results = await Promise.all(checks);
        return results;
    }
    
    async checkOrphanedRecords() {
        const query = `
            SELECT p.id, p.title
            FROM posts p
            LEFT JOIN users u ON p.author_id = u.id
            WHERE u.id IS NULL
        `;
        
        return new Promise((resolve, reject) => {
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve({
                    name: '孤立记录检查',
                    issues: rows.length,
                    details: rows
                });
            });
        });
    }
    
    async checkDuplicateRecords() {
        const query = `
            SELECT username, COUNT(*) as count
            FROM users
            GROUP BY username
            HAVING COUNT(*) > 1
        `;
        
        return new Promise((resolve, reject) => {
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve({
                    name: '重复记录检查',
                    issues: rows.length,
                    details: rows
                });
            });
        });
    }
    
    async checkInvalidReferences() {
        const query = `
            SELECT c.id, c.post_id
            FROM comments c
            LEFT JOIN posts p ON c.post_id = p.id
            WHERE p.id IS NULL
        `;
        
        return new Promise((resolve, reject) => {
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve({
                    name: '无效引用检查',
                    issues: rows.length,
                    details: rows
                });
            });
        });
    }
}
```

---

## 调试工具与技巧

### 1. SQL调试

**SQL调试器**：
```javascript
class SQLDebugger {
    constructor(db) {
        this.db = db;
        this.enabled = false;
    }
    
    enable() {
        this.enabled = true;
        console.log('SQL调试模式已启用');
    }
    
    disable() {
        this.enabled = false;
        console.log('SQL调试模式已禁用');
    }
    
    debug(sql, params) {
        if (!this.enabled) return;
        
        console.log('SQL:', sql);
        console.log('参数:', params);
        console.log('时间:', new Date().toISOString());
    }
    
    execute(sql, params, callback) {
        this.debug(sql, params);
        
        const startTime = Date.now();
        
        this.db.all(sql, params, (err, rows) => {
            const duration = Date.now() - startTime;
            
            if (this.enabled) {
                console.log('执行时间:', duration + 'ms');
                console.log('结果数量:', rows ? rows.length : 0);
                if (err) {
                    console.error('错误:', err.message);
                }
            }
            
            callback(err, rows);
        });
    }
}

// 使用示例
const debugger = new SQLDebugger(db);
debugger.enable();

debugger.execute('SELECT * FROM users WHERE id = ?', [1], (err, rows) => {
    if (err) {
        console.error('查询失败:', err.message);
    } else {
        console.log('查询结果:', rows);
    }
});
```

### 2. 错误日志

**错误日志系统**：
```javascript
const fs = require('fs');
const path = require('path');

class ErrorLogger {
    constructor(logDir = './logs') {
        this.logDir = logDir;
        this.ensureLogDirectory();
    }
    
    ensureLogDirectory() {
        if (!fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }
    }
    
    logError(error, context = {}) {
        const timestamp = new Date().toISOString();
        const errorInfo = {
            timestamp,
            message: error.message,
            stack: error.stack,
            code: error.code,
            context
        };
        
        const logFile = path.join(this.logDir, `error-${new Date().toISOString().split('T')[0]}.log`);
        const logEntry = JSON.stringify(errorInfo) + '\n';
        
        fs.appendFile(logFile, logEntry, (err) => {
            if (err) {
                console.error('写入错误日志失败:', err.message);
            }
        });
        
        console.error('错误已记录:', error.message);
    }
    
    getErrorStats() {
        const logFiles = fs.readdirSync(this.logDir)
            .filter(file => file.startsWith('error-') && file.endsWith('.log'));
        
        const stats = {
            totalErrors: 0,
            errorsByCode: {},
            errorsByDate: {}
        };
        
        logFiles.forEach(file => {
            const content = fs.readFileSync(path.join(this.logDir, file), 'utf8');
            const lines = content.trim().split('\n');
            
            lines.forEach(line => {
                try {
                    const error = JSON.parse(line);
                    stats.totalErrors++;
                    
                    if (error.code) {
                        stats.errorsByCode[error.code] = (stats.errorsByCode[error.code] || 0) + 1;
                    }
                    
                    const date = error.timestamp.split('T')[0];
                    stats.errorsByDate[date] = (stats.errorsByDate[date] || 0) + 1;
                } catch (parseError) {
                    console.error('解析错误日志失败:', parseError.message);
                }
            });
        });
        
        return stats;
    }
}

// 使用示例
const errorLogger = new ErrorLogger();

try {
    // 数据库操作
} catch (error) {
    errorLogger.logError(error, {
        operation: 'createUser',
        userId: 123
    });
}
```

---

## 预防措施

### 1. 输入验证

**数据验证中间件**：
```javascript
const Joi = require('joi');

class DataValidator {
    static validateUser(data) {
        const schema = Joi.object({
            username: Joi.string().alphanum().min(3).max(30).required(),
            email: Joi.string().email().required(),
            password: Joi.string().min(6).required()
        });
        
        const { error, value } = schema.validate(data);
        if (error) {
            throw new Error(`数据验证失败: ${error.details.map(d => d.message).join(', ')}`);
        }
        
        return value;
    }
    
    static sanitizeInput(input) {
        if (typeof input === 'string') {
            return input.trim().replace(/[<>]/g, '');
        }
        return input;
    }
}
```

### 2. 资源管理

**资源清理**：
```javascript
class ResourceManager {
    constructor() {
        this.resources = new Set();
    }
    
    register(resource) {
        this.resources.add(resource);
    }
    
    cleanup() {
        for (const resource of this.resources) {
            try {
                if (resource.close) {
                    resource.close();
                } else if (resource.destroy) {
                    resource.destroy();
                }
            } catch (error) {
                console.error('清理资源失败:', error.message);
            }
        }
        this.resources.clear();
    }
}

// 使用示例
const resourceManager = new ResourceManager();

process.on('SIGINT', () => {
    console.log('正在清理资源...');
    resourceManager.cleanup();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('正在清理资源...');
    resourceManager.cleanup();
    process.exit(0);
});
```

---

## 总结

通过本章的学习，您已经掌握了Node.js与SQLite开发中的错误处理和故障排除技巧：

1. **错误类型识别**：连接错误、SQL错误、性能问题
2. **错误处理策略**：重试机制、错误分类、优雅降级
3. **性能诊断**：慢查询监控、内存泄漏检测
4. **数据完整性**：事务管理、一致性检查
5. **调试工具**：SQL调试器、错误日志系统
6. **预防措施**：输入验证、资源管理

这些技能将帮助您构建稳定、可靠的SQLite应用。

---

*学习资料完成！您现在已经掌握了Node.js调用SQLite的完整知识体系。*
