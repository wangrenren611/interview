# 高频面试真题解析

本文档精选了2025年前端面试中出现频率较高的算法题目，并提供详细的解析和实现。

## 数组类高频题

### 1. 两数之和（Two Sum）

**题目描述**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**解题思路**：
- 使用哈希表优化，时间复杂度从O(n²)降低到O(n)

```javascript
function twoSum(nums, target) {
  const map = new Map();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    map.set(nums[i], i);
  }
  
  return [];
}
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 2. 三数之和（3Sum）

**题目描述**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

**解题思路**：
- 排序 + 双指针
- 固定一个数，用双指针寻找另外两个数
- 注意去重处理

```javascript
function threeSum(nums) {
  const result = [];
  nums.sort((a, b) => a - b); // 排序
  
  for (let i = 0; i < nums.length - 2; i++) {
    // 跳过重复元素
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    let left = i + 1, right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        
        // 跳过重复元素
        while (left < right && nums[left] === nums[left + 1]) left++;
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return result;
}
// 时间复杂度：O(n²)
// 空间复杂度：O(1)
```

### 3. 盛最多水的容器（Container With Most Water）

**题目描述**：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**解题思路**：
- 双指针技术
- 每次移动较短的那根垂线

```javascript
function maxArea(height) {
  let left = 0, right = height.length - 1;
  let maxArea = 0;
  
  while (left < right) {
    const area = Math.min(height[left], height[right]) * (right - left);
    maxArea = Math.max(maxArea, area);
    
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  
  return maxArea;
}
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

## 链表类高频题

### 1. 反转链表（Reverse Linked List）

**题目描述**：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

**解题思路**：
- 迭代法：使用三个指针逐个反转
- 递归法：从后往前反转

```javascript
// 迭代法
function reverseList(head) {
  let prev = null;
  let curr = head;
  
  while (curr !== null) {
    const next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  
  return prev;
}
// 时间复杂度：O(n)
// 空间复杂度：O(1)

// 递归法
function reverseListRecursive(head) {
  if (head === null || head.next === null) {
    return head;
  }
  
  const newHead = reverseListRecursive(head.next);
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 2. 合并两个有序链表（Merge Two Sorted Lists）

**题目描述**：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**解题思路**：
- 双指针技术
- 创建虚拟头节点简化边界处理

```javascript
function mergeTwoLists(list1, list2) {
  const dummy = new ListNode(0);
  let current = dummy;
  
  while (list1 !== null && list2 !== null) {
    if (list1.val <= list2.val) {
      current.next = list1;
      list1 = list1.next;
    } else {
      current.next = list2;
      list2 = list2.next;
    }
    current = current.next;
  }
  
  current.next = list1 !== null ? list1 : list2;
  
  return dummy.next;
}
// 时间复杂度：O(m + n)
// 空间复杂度：O(1)
```

## 树类高频题

### 1. 二叉树的层序遍历（Binary Tree Level Order Traversal）

**题目描述**：给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）

**解题思路**：
- BFS广度优先搜索
- 使用队列存储每一层的节点

```javascript
function levelOrder(root) {
  if (root === null) return [];
  
  const queue = [root];
  const result = [];
  
  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);
      
      if (node.left !== null) {
        queue.push(node.left);
      }
      if (node.right !== null) {
        queue.push(node.right);
      }
    }
    
    result.push(currentLevel);
  }
  
  return result;
}
// 时间复杂度：O(n)
// 空间复杂度：O(w)，w为树的最大宽度
```

### 2. 二叉树的最大深度（Maximum Depth of Binary Tree）

**题目描述**：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**解题思路**：
- DFS深度优先搜索
- 递归计算左右子树的最大深度

```javascript
function maxDepth(root) {
  if (root === null) return 0;
  
  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);
  
  return Math.max(leftDepth, rightDepth) + 1;
}
// 时间复杂度：O(n)
// 空间复杂度：O(h)，h为树的高度
```

## 动态规划类高频题

### 1. 爬楼梯（Climbing Stairs）

**题目描述**：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**解题思路**：
- 动态规划
- dp[i] = dp[i-1] + dp[i-2]

```javascript
function climbStairs(n) {
  if (n <= 2) return n;
  
  let prev2 = 1, prev1 = 2;
  
  for (let i = 3; i <= n; i++) {
    const current = prev1 + prev2;
    prev2 = prev1;
    prev1 = current;
  }
  
  return prev1;
}
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 2. 最大子数组和（Maximum Subarray）

**题目描述**：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**解题思路**：
- Kadane算法
- dp[i] = max(nums[i], dp[i-1] + nums[i])

```javascript
function maxSubArray(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  
  for (let i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }
  
  return maxSum;
}
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

## 字符串类高频题

### 1. 最长公共前缀（Longest Common Prefix）

**题目描述**：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

**解题思路**：
- 纵向扫描
- 逐列比较每个字符串的相同位置字符

```javascript
function longestCommonPrefix(strs) {
  if (strs.length === 0) return "";
  
  // 以第一个字符串为基准
  for (let i = 0; i < strs[0].length; i++) {
    const char = strs[0][i];
    
    // 检查其他字符串在位置i是否也是char
    for (let j = 1; j < strs.length; j++) {
      // 如果到达字符串末尾或字符不匹配
      if (i === strs[j].length || strs[j][i] !== char) {
        return strs[0].substring(0, i);
      }
    }
  }
  
  return strs[0];
}
// 时间复杂度：O(S)，S是所有字符串的字符总数
// 空间复杂度：O(1)
```

### 2. 有效的括号（Valid Parentheses）

**题目描述**：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

**解题思路**：
- 使用栈数据结构
- 遇到左括号入栈，遇到右括号检查栈顶是否匹配

```javascript
function isValid(s) {
  const stack = [];
  const map = {
    ')': '(',
    '}': '{',
    ']': '['
  };
  
  for (const char of s) {
    // 如果是右括号
    if (map[char]) {
      // 检查栈顶是否匹配
      if (stack.length === 0 || stack.pop() !== map[char]) {
        return false;
      }
    } else {
      // 左括号入栈
      stack.push(char);
    }
  }
  
  // 栈空则有效
  return stack.length === 0;
}
// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 搜索类高频题

### 1. 搜索旋转排序数组（Search in Rotated Sorted Array）

**题目描述**：整数数组 nums 按升序排列，数组中的值互不相同。在传递给函数之前，nums 在某个未知的下标 k 上进行了旋转。给你旋转后的数组 nums 和一个整数 target，如果 nums 中存在这个目标值 target，则返回它的下标，否则返回 -1。

**解题思路**：
- 二分查找
- 判断哪一部分是有序的，在有序部分判断target是否在范围内

```javascript
function search(nums, target) {
  let left = 0, right = nums.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (nums[mid] === target) {
      return mid;
    }
    
    // 判断左半部分是否有序
    if (nums[left] <= nums[mid]) {
      // 左半部分有序
      if (nums[left] <= target && target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else {
      // 右半部分有序
      if (nums[mid] < target && target <= nums[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }
  
  return -1;
}
// 时间复杂度：O(log n)
// 空间复杂度：O(1)
```

### 2. 岛屿数量（Number of Islands）

**题目描述**：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算其中岛屿的数量。

**解题思路**：
- BFS或DFS遍历
- 遇到'1'时进行搜索，将相连的'1'都标记为'0'

```javascript
function numIslands(grid) {
  if (grid.length === 0 || grid[0].length === 0) return 0;
  
  const rows = grid.length;
  const cols = grid[0].length;
  let count = 0;
  
  // 遍历网格
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === '1') {
        // 发现新岛屿，使用BFS标记所有相连的陆地
        bfs(grid, i, j, rows, cols);
        count++;
      }
    }
  }
  
  return count;
}

function bfs(grid, startRow, startCol, rows, cols) {
  const queue = [[startRow, startCol]];
  grid[startRow][startCol] = '0';  // 标记为已访问
  
  // 四个方向：上、下、左、右
  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  
  while (queue.length > 0) {
    const [row, col] = queue.shift();
    
    // 检查四个方向的邻居
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      
      // 检查边界和是否为陆地
      if (newRow >= 0 && newRow < rows && 
          newCol >= 0 && newCol < cols && 
          grid[newRow][newCol] === '1') {
        grid[newRow][newCol] = '0';  // 标记为已访问
        queue.push([newRow, newCol]);
      }
    }
  }
}
// 时间复杂度：O(m×n)
// 空间复杂度：O(min(m,n))
```

## 设计类高频题

### 1. LRU缓存（LRU Cache）

**题目描述**：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。

**解题思路**：
- 哈希表 + 双向链表
- 哈希表提供O(1)的查找，双向链表维护访问顺序

```javascript
// 双向链表节点
class ListNode {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
    
    // 创建虚拟头尾节点
    this.head = new ListNode(0, 0);
    this.tail = new ListNode(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  
  // 获取数据
  get(key) {
    if (this.map.has(key)) {
      const node = this.map.get(key);
      // 移除节点
      this.removeNode(node);
      // 移到头部
      this.moveToHead(node);
      return node.value;
    }
    return -1;
  }
  
  // 插入数据
  put(key, value) {
    if (this.map.has(key)) {
      // 更新现有节点
      const node = this.map.get(key);
      node.value = value;
      this.removeNode(node);
      this.moveToHead(node);
    } else {
      // 插入新节点
      const newNode = new ListNode(key, value);
      
      if (this.map.size >= this.capacity) {
        // 容量已满，删除尾部节点
        const tail = this.tail.prev;
        this.removeNode(tail);
        this.map.delete(tail.key);
      }
      
      this.map.set(key, newNode);
      this.moveToHead(newNode);
    }
  }
  
  // 移除节点
  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  
  // 移到头部
  moveToHead(node) {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
  }
}
// 时间复杂度：get和put都是O(1)
// 空间复杂度：O(capacity)
```

## 高频题总结

这些高频面试题涵盖了数据结构和算法的核心知识点：

1. **数组**：双指针、哈希表优化
2. **链表**：指针操作、虚拟头节点
3. **树**：遍历、递归
4. **动态规划**：状态定义、状态转移
5. **字符串**：栈、双指针
6. **搜索**：BFS、DFS、二分查找
7. **设计**：数据结构组合

掌握这些题目和解题思路，能够帮助我们在前端面试中应对大部分算法问题。在实际面试中，还需要注意：
- 理解题目要求，确认边界条件
- 选择合适的数据结构和算法
- 编写清晰、正确的代码
- 分析时间和空间复杂度
- 考虑代码的可扩展性和优化空间

祝愿每一位读者都能在前端面试中取得优异的成绩！