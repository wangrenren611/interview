# 09-缓存与性能优化

## 1. 缓存策略概述

### 1.0 TypeScript在缓存系统中的优势

在缓存与性能优化中，TypeScript提供了强大的类型安全保障，特别是在处理复杂的缓存策略和性能监控时：

#### 1.0.1 类型安全的缓存接口
```typescript
// 缓存键类型
type CacheKey = string;

// 缓存值类型
type CacheValue = string | number | boolean | object | null;

// 缓存配置接口
interface CacheConfig {
  ttl?: number;           // 生存时间（秒）
  maxSize?: number;       // 最大缓存大小
  strategy?: CacheStrategy; // 缓存策略
  serialize?: boolean;    // 是否序列化
}

// 缓存策略类型
type CacheStrategy = 'LRU' | 'LFU' | 'FIFO' | 'TTL';

// 缓存操作结果接口
interface CacheResult<T = CacheValue> {
  success: boolean;
  data?: T;
  error?: string;
  hit?: boolean;
  miss?: boolean;
}

// 缓存统计接口
interface CacheStats {
  hits: number;
  misses: number;
  hitRate: number;
  size: number;
  maxSize: number;
  memoryUsage: number;
}
```

#### 1.0.2 缓存管理器类型定义
```typescript
// 缓存管理器接口
interface CacheManager {
  get<T = CacheValue>(key: CacheKey): Promise<CacheResult<T>>;
  set(key: CacheKey, value: CacheValue, config?: CacheConfig): Promise<CacheResult>;
  delete(key: CacheKey): Promise<CacheResult>;
  clear(): Promise<CacheResult>;
  has(key: CacheKey): Promise<boolean>;
  keys(): Promise<CacheKey[]>;
  size(): Promise<number>;
  stats(): Promise<CacheStats>;
}

// 缓存装饰器类型
type CacheDecorator = (
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) => PropertyDescriptor;

// 缓存键生成器类型
type CacheKeyGenerator = (...args: any[]) => CacheKey;
```

### 1.1 缓存的重要性

在企业级应用中，缓存是提升系统性能、降低数据库负载和改善用户体验的关键技术。合理的缓存策略能够：

1. **提升响应速度**：减少数据库查询和计算时间，TypeScript提供类型安全的缓存操作
2. **降低系统负载**：减轻数据库和应用服务器压力，类型化的负载监控
3. **提高并发能力**：支持更多并发用户访问，类型安全的并发控制
4. **改善用户体验**：提供更快的页面加载速度，类型化的性能指标

### 1.2 缓存类型

#### 1.2.1 应用层缓存

应用层缓存直接在应用程序中存储数据，访问速度最快但容量有限：

```typescript
// 内存缓存示例
interface CacheItem<T = CacheValue> {
  data: T;
  timestamp: number;
  ttl?: number;
  accessCount: number;
  lastAccess: number;
}

class MemoryCache<T = CacheValue> implements CacheManager {
  private cache = new Map<CacheKey, CacheItem<T>>();
  private maxSize: number;
  private defaultTTL: number;

  constructor(maxSize: number = 1000, defaultTTL: number = 300000) {
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;
  }

  /**
   * 获取缓存数据
   * @param key 缓存键
   * @returns 缓存结果
   */
  async get<K extends CacheKey>(key: K): Promise<CacheResult<T>> {
    try {
      const item = this.cache.get(key);
      
      if (!item) {
        return { success: true, miss: true };
      }

      // 检查是否过期
      const now = Date.now();
      const ttl = item.ttl || this.defaultTTL;
      
      if (now - item.timestamp > ttl) {
        this.cache.delete(key);
        return { success: true, miss: true };
      }

      // 更新访问统计
      item.accessCount++;
      item.lastAccess = now;

      return {
        success: true,
        data: item.data,
        hit: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * 设置缓存数据
   * @param key 缓存键
   * @param value 缓存值
   * @param config 缓存配置
   * @returns 缓存结果
   */
  async set(key: CacheKey, value: T, config: CacheConfig = {}): Promise<CacheResult> {
    try {
      // 检查缓存大小限制
      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.evictLRU();
      }

      const item: CacheItem<T> = {
        data: value,
        timestamp: Date.now(),
        ttl: config.ttl ? config.ttl * 1000 : this.defaultTTL,
        accessCount: 1,
        lastAccess: Date.now()
      };

      this.cache.set(key, item);

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * 删除缓存数据
   * @param key 缓存键
   * @returns 缓存结果
   */
  async delete(key: CacheKey): Promise<CacheResult> {
    try {
      const deleted = this.cache.delete(key);
      return { success: deleted };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * 清空所有缓存
   * @returns 缓存结果
   */
  async clear(): Promise<CacheResult> {
    try {
      this.cache.clear();
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * 检查缓存是否存在
   * @param key 缓存键
   * @returns 是否存在
   */
  async has(key: CacheKey): Promise<boolean> {
    const item = this.cache.get(key);
    if (!item) return false;

    // 检查是否过期
    const now = Date.now();
    const ttl = item.ttl || this.defaultTTL;
    
    if (now - item.timestamp > ttl) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  /**
   * 获取所有缓存键
   * @returns 缓存键列表
   */
  async keys(): Promise<CacheKey[]> {
    return Array.from(this.cache.keys());
  }

  /**
   * 获取缓存大小
   * @returns 缓存大小
   */
  async size(): Promise<number> {
    return this.cache.size;
  }

  /**
   * 获取缓存统计信息
   * @returns 缓存统计
   */
  async stats(): Promise<CacheStats> {
    const items = Array.from(this.cache.values());
    const hits = items.reduce((sum, item) => sum + item.accessCount, 0);
    const misses = 0; // 内存缓存无法统计misses
    
    return {
      hits,
      misses,
      hitRate: hits / (hits + misses) || 0,
      size: this.cache.size,
      maxSize: this.maxSize,
      memoryUsage: this.estimateMemoryUsage()
    };
  }

  /**
   * LRU淘汰策略
   */
  private evictLRU(): void {
    let oldestKey: CacheKey | null = null;
    let oldestTime = Date.now();

    for (const [key, item] of this.cache.entries()) {
      if (item.lastAccess < oldestTime) {
        oldestTime = item.lastAccess;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  /**
   * 估算内存使用量
   * @returns 内存使用量（字节）
   */
  private estimateMemoryUsage(): number {
    let totalSize = 0;
    
    for (const [key, item] of this.cache.entries()) {
      totalSize += key.length * 2; // 字符串长度 * 2字节
      totalSize += JSON.stringify(item).length * 2;
    }
    
    return totalSize;
  }
}
```

#### 1.2.2 分布式缓存

分布式缓存如Redis、Memcached等，支持跨多个应用实例共享缓存数据：

```javascript
// Redis缓存示例
const redis = require('redis');
const client = redis.createClient();

async function getFromCache(key) {
  try {
    const data = await client.get(key);
    return data ? JSON.parse(data) : null;
  } catch (error) {
    console.error('Cache read error:', error);
    return null;
  }
}

async function setToCache(key, data, ttl = 300) {
  try {
    await client.setex(key, ttl, JSON.stringify(data));
  } catch (error) {
    console.error('Cache write error:', error);
  }
}
```

## 2. Redis缓存实现

### 2.1 Redis集成配置

#### 2.1.1 Redis客户端配置

```typescript
// src/config/redis.ts
import Redis from 'ioredis';
import { config } from './index';

// Redis配置接口
interface RedisConfig {
  host: string;
  port: number;
  password?: string;
  db: number;
  retryStrategy: (times: number) => number;
  reconnectOnError: (err: Error) => boolean;
  maxRetriesPerRequest: number;
  connectTimeout: number;
  lazyConnect: boolean;
}

const redisConfig: RedisConfig = {
  host: config.redis.host || 'localhost',
  port: config.redis.port || 6379,
  password: config.redis.password || undefined,
  db: config.redis.db || 0,
  retryStrategy: (times: number): number => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  reconnectOnError: (err: Error): boolean => {
    const targetError = 'READONLY';
    if (err.message.includes(targetError)) {
      // 只有在遇到只读错误时才重新连接
      return true;
    }
  },
  maxRetriesPerRequest: 3,
  connectTimeout: 10000,
  lazyConnect: true
};

// 创建Redis客户端实例
const redisClient = new redis(redisConfig);

// 错误处理
redisClient.on('error', (error) => {
  console.error('Redis connection error:', error);
});

redisClient.on('connect', () => {
  console.log('Redis connected successfully');
});

redisClient.on('ready', () => {
  console.log('Redis client is ready');
});

redisClient.on('close', () => {
  console.log('Redis connection closed');
});

module.exports = redisClient;
```

#### 2.1.2 Redis连接池

```typescript
// src/utils/redis-pool.ts
import Redis from 'ioredis';
import { config } from '../config';

// Redis连接池接口
interface RedisPoolConfig {
  maxPoolSize: number;
  minPoolSize: number;
  acquireTimeoutMillis: number;
  createTimeoutMillis: number;
  destroyTimeoutMillis: number;
  idleTimeoutMillis: number;
  reapIntervalMillis: number;
  createRetryIntervalMillis: number;
}

// Redis连接池类
class RedisPool {
  private pool: Redis[] = [];
  private maxPoolSize: number;
  private currentPoolSize: number = 0;
  private config: RedisPoolConfig;

  constructor() {
    this.config = {
      maxPoolSize: config.redis.poolSize || 10,
      minPoolSize: config.redis.minPoolSize || 2,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 200
    };
    
    this.maxPoolSize = this.config.maxPoolSize;
  }
  
  /**
   * 获取Redis连接
   * @returns Redis连接实例
   */
  async getConnection(): Promise<Redis> {
    // 如果池中有空闲连接，直接返回
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    
    // 如果池未满，创建新连接
    if (this.currentPoolSize < this.maxPoolSize) {
      const client = new Redis(config.redis);
      this.currentPoolSize++;
      return client;
    }
    
    // 如果池已满，等待空闲连接
    return new Promise((resolve) => {
      const check = () => {
        if (this.pool.length > 0) {
          resolve(this.pool.pop());
        } else {
          setTimeout(check, 10);
        }
      };
      check();
    });
  }
  
  releaseConnection(client) {
    if (this.pool.length < this.maxPoolSize) {
      this.pool.push(client);
    } else {
      client.quit();
      this.currentPoolSize--;
    }
  }
  
  async closeAll() {
    for (const client of this.pool) {
      await client.quit();
    }
    this.pool = [];
    this.currentPoolSize = 0;
  }
}

module.exports = new RedisPool();
```

### 2.2 缓存策略实现

#### 2.2.1 缓存装饰器

```typescript
// src/utils/cache-decorator.ts
import { redisClient } from '../config/redis';
import crypto from 'crypto';

// 缓存装饰器选项接口
interface CacheableOptions {
  prefix?: string;
  ttl?: number;
  keyGenerator?: (...args: any[]) => string;
  condition?: (...args: any[]) => boolean;
  serialize?: (value: any) => string;
  deserialize?: (value: string) => any;
}

// 生成缓存键
function generateCacheKey(prefix: string, ...args: any[]): string {
  const hash = crypto.createHash('md5');
  hash.update(JSON.stringify(args));
  return `${prefix}:${hash.digest('hex')}`;
}

// 缓存装饰器
function cacheable(options: CacheableOptions = {}) {
  const {
    prefix = 'cache',
    ttl = 300, // 默认5分钟
    keyGenerator = null,
    condition = null // 缓存条件
  } = options;
  
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      // 检查缓存条件
      if (condition && !condition.apply(this, args)) {
        return await originalMethod.apply(this, args);
      }
      
      // 生成缓存键
      const cacheKey = keyGenerator 
        ? keyGenerator.apply(this, args)
        : generateCacheKey(prefix, propertyKey, ...args);
      
      try {
        // 尝试从缓存获取
        const cached = await redisClient.get(cacheKey);
        if (cached) {
          console.log(`Cache HIT: ${cacheKey}`);
          return JSON.parse(cached);
        }
        
        // 执行原方法
        console.log(`Cache MISS: ${cacheKey}`);
        const result = await originalMethod.apply(this, args);
        
        // 存储到缓存
        if (result !== undefined && result !== null) {
          await redisClient.setex(cacheKey, ttl, JSON.stringify(result));
        }
        
        return result;
      } catch (error) {
        console.error('Cache error:', error);
        // 缓存失败时直接调用原方法
        return await originalMethod.apply(this, args);
      }
    };
    
    return descriptor;
  };
}

module.exports = { cacheable, generateCacheKey };
```

#### 2.2.2 使用缓存装饰器

```javascript
// src/app/services/user.service.js
const { cacheable } = require('../../utils/cache-decorator');
const { User } = require('../models');

class UserService {
  // 缓存用户信息（10分钟）
  @cacheable({
    prefix: 'user',
    ttl: 600,
    keyGenerator: (id) => `user:${id}`
  })
  async getUserById(id) {
    console.log(`Fetching user ${id} from database`);
    return await User.findByPk(id);
  }
  
  // 条件缓存：只缓存活跃用户
  @cacheable({
    prefix: 'active_users',
    ttl: 300,
    condition: (status) => status === 'active'
  })
  async getUsersByStatus(status) {
    console.log(`Fetching users with status ${status} from database`);
    return await User.findAll({ where: { status } });
  }
  
  // 缓存用户列表（带分页）
  @cacheable({
    prefix: 'user_list',
    ttl: 120,
    keyGenerator: (page, limit) => `user_list:${page}:${limit}`
  })
  async getUserList(page = 1, limit = 10) {
    console.log(`Fetching user list page ${page}`);
    const offset = (page - 1) * limit;
    return await User.findAndCountAll({
      limit,
      offset,
      order: [['created_at', 'DESC']]
    });
  }
}

module.exports = new UserService();
```

### 2.3 缓存模式

#### 2.3.1 Cache-Aside模式

```javascript
// src/middleware/cache-aside.middleware.js
const redisClient = require('../config/redis');

const cacheAsideMiddleware = (options = {}) => {
  const {
    keyGenerator,
    ttl = 300
  } = options;
  
  return async (ctx, next) => {
    const cacheKey = keyGenerator(ctx);
    
    // 尝试从缓存获取
    try {
      const cached = await redisClient.get(cacheKey);
      if (cached) {
        ctx.body = JSON.parse(cached);
        ctx.set('X-Cache', 'HIT');
        return;
      }
    } catch (error) {
      console.error('Cache read error:', error);
    }
    
    // 执行后续中间件
    await next();
    
    // 缓存响应结果
    if (ctx.status === 200 && ctx.body) {
      try {
        await redisClient.setex(cacheKey, ttl, JSON.stringify(ctx.body));
        ctx.set('X-Cache', 'MISS');
      } catch (error) {
        console.error('Cache write error:', error);
      }
    }
  };
};

module.exports = cacheAsideMiddleware;
```

#### 2.3.2 Write-Through模式

```javascript
// src/utils/cache-manager.js
const redisClient = require('../config/redis');

class CacheManager {
  // 写透缓存：同时写入缓存和数据库
  async writeThrough(key, data, ttl = 300) {
    try {
      // 先写入数据库
      // const result = await database.save(data);
      
      // 再写入缓存
      await redisClient.setex(key, ttl, JSON.stringify(data));
      
      return data;
    } catch (error) {
      console.error('Write-through cache error:', error);
      throw error;
    }
  }
  
  // 读取缓存，如果缓存不存在则从数据库加载
  async readThrough(key, loader, ttl = 300) {
    try {
      // 尝试从缓存获取
      const cached = await redisClient.get(key);
      if (cached) {
        return JSON.parse(cached);
      }
      
      // 缓存不存在，从数据源加载
      const data = await loader();
      
      // 写入缓存
      if (data) {
        await redisClient.setex(key, ttl, JSON.stringify(data));
      }
      
      return data;
    } catch (error) {
      console.error('Read-through cache error:', error);
      throw error;
    }
  }
  
  // 删除缓存
  async invalidate(key) {
    try {
      await redisClient.del(key);
    } catch (error) {
      console.error('Cache invalidation error:', error);
    }
  }
  
  // 批量删除缓存
  async invalidatePattern(pattern) {
    try {
      const keys = await redisClient.keys(pattern);
      if (keys.length > 0) {
        await redisClient.del(...keys);
      }
    } catch (error) {
      console.error('Cache pattern invalidation error:', error);
    }
  }
}

module.exports = new CacheManager();
```

### 2.4 缓存失效策略

#### 2.4.1 主动失效

```javascript
// src/services/cache-invalidation.service.js
const redisClient = require('../config/redis');
const { EventEmitter } = require('events');

class CacheInvalidationService extends EventEmitter {
  constructor() {
    super();
    this.invalidationRules = new Map();
  }
  
  // 注册失效规则
  registerInvalidationRule(event, pattern) {
    if (!this.invalidationRules.has(event)) {
      this.invalidationRules.set(event, []);
    }
    this.invalidationRules.get(event).push(pattern);
  }
  
  // 触发缓存失效
  async invalidateCache(event, data) {
    const patterns = this.invalidationRules.get(event);
    if (!patterns) return;
    
    for (const pattern of patterns) {
      try {
        // 替换模式中的变量
        const resolvedPattern = pattern.replace(/\{(\w+)\}/g, (match, key) => {
          return data[key] || match;
        });
        
        // 删除匹配的缓存键
        const keys = await redisClient.keys(resolvedPattern);
        if (keys.length > 0) {
          await redisClient.del(...keys);
          console.log(`Invalidated ${keys.length} cache keys for pattern: ${resolvedPattern}`);
        }
      } catch (error) {
        console.error(`Cache invalidation error for pattern ${pattern}:`, error);
      }
    }
    
    // 触发事件
    this.emit('cacheInvalidated', { event, data });
  }
}

// 创建单例实例
const cacheInvalidationService = new CacheInvalidationService();

// 注册常见的失效规则
cacheInvalidationService.registerInvalidationRule('user.updated', 'user:{id}');
cacheInvalidationService.registerInvalidationRule('user.updated', 'user_list:*');
cacheInvalidationService.registerInvalidationRule('product.updated', 'product:{id}');
cacheInvalidationService.registerInvalidationRule('product.updated', 'product_list:*');

module.exports = cacheInvalidationService;
```

#### 2.4.2 在业务逻辑中使用缓存失效

```javascript
// src/app/services/user.service.js
const cacheInvalidationService = require('../../services/cache-invalidation.service');
const { User } = require('../models');

class UserService {
  async updateUser(id, userData) {
    try {
      const user = await User.findByPk(id);
      if (!user) {
        throw new Error('User not found');
      }
      
      // 更新用户数据
      await user.update(userData);
      
      // 触发缓存失效
      await cacheInvalidationService.invalidateCache('user.updated', { id });
      
      return user;
    } catch (error) {
      throw error;
    }
  }
  
  async deleteUser(id) {
    try {
      const user = await User.findByPk(id);
      if (!user) {
        throw new Error('User not found');
      }
      
      // 删除用户
      await user.destroy();
      
      // 触发缓存失效
      await cacheInvalidationService.invalidateCache('user.updated', { id });
      
      return { success: true };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = new UserService();
```

## 3. 数据库优化技术

### 3.1 查询优化

#### 3.1.1 索引优化

```javascript
// src/app/models/user.model.js
const { DataTypes } = require('sequelize');
const BaseModel = require('./base.model');

class User extends BaseModel {
  // 用户模型实现
}

User.init({
  id: {
    type: DataTypes.BIGINT,
    primaryKey: true,
    autoIncrement: true
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true
  },
  name: {
    type: DataTypes.STRING(50),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('active', 'inactive', 'suspended'),
    defaultValue: 'active'
  },
  created_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  }
}, {
  sequelize,
  tableName: 'users',
  timestamps: false,
  indexes: [
    // 为常用查询字段创建索引
    {
      unique: true,
      fields: ['email']
    },
    {
      fields: ['status']
    },
    {
      fields: ['created_at']
    },
    // 复合索引
    {
      fields: ['status', 'created_at']
    }
  ]
});

module.exports = User;
```

#### 3.1.2 查询优化示例

```javascript
// src/app/services/user.service.js
const { User, Order } = require('../models');
const { Op } = require('sequelize');

class UserService {
  // 优化的用户列表查询
  async getUserList(options = {}) {
    const {
      page = 1,
      limit = 10,
      status,
      search,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = options;
    
    const offset = (page - 1) * limit;
    
    // 构建查询条件
    const where = {};
    
    if (status) {
      where.status = status;
    }
    
    if (search) {
      where[Op.or] = [
        { name: { [Op.like]: `%${search}%` } },
        { email: { [Op.like]: `%${search}%` } }
      ];
    }
    
    // 使用attributes限制返回字段
    const result = await User.findAndCountAll({
      where,
      attributes: ['id', 'name', 'email', 'status', 'created_at'], // 只查询需要的字段
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [[sortBy, sortOrder]],
      // 避免N+1查询
      include: [
        {
          model: Order,
          as: 'orders',
          attributes: ['id', 'total_amount', 'status'], // 只查询需要的字段
          limit: 5 // 限制关联数据数量
        }
      ]
    });
    
    return {
      data: result.rows,
      pagination: {
        total: result.count,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(result.count / limit)
      }
    };
  }
  
  // 批量查询优化
  async getUsersByIds(ids) {
    // 使用IN查询而不是多次单独查询
    return await User.findAll({
      where: {
        id: {
          [Op.in]: ids
        }
      },
      attributes: ['id', 'name', 'email', 'status']
    });
  }
  
  // 预加载关联数据
  async getUserWithOrders(userId) {
    return await User.findByPk(userId, {
      include: [
        {
          model: Order,
          as: 'orders',
          attributes: ['id', 'total_amount', 'status', 'created_at'],
          // 添加排序和限制
          order: [['created_at', 'DESC']],
          limit: 10
        }
      ]
    });
  }
}

module.exports = new UserService();
```

### 3.2 连接池优化

#### 3.2.1 Sequelize连接池配置

```javascript
// src/config/database.js
const { Sequelize } = require('sequelize');
const config = require('./index');

const sequelize = new Sequelize(config.database.database, config.database.username, config.database.password, {
  host: config.database.host,
  port: config.database.port,
  dialect: config.database.dialect,
  timezone: config.database.timezone,
  logging: config.app.isDevelopment ? console.log : false,
  
  // 连接池配置
  pool: {
    max: config.database.pool.max || 20,      // 最大连接数
    min: config.database.pool.min || 5,       // 最小连接数
    idle: config.database.pool.idle || 10000, // 连接在释放前可以空闲的最长时间(毫秒)
    acquire: config.database.pool.acquire || 30000, // 获取连接的最长时间(毫秒)
    evict: config.database.pool.evict || 1000, // 清理连接的频率(毫秒)
    handleDisconnects: true // 自动处理连接断开
  },
  
  // 查询配置
  query: {
    raw: false, // 返回原始结果而不是模型实例
    nest: true  // 嵌套结果
  },
  
  // 重试配置
  retry: {
    max: 3 // 最大重试次数
  }
});

// 测试数据库连接
async function testConnection() {
  try {
    await sequelize.authenticate();
    console.log('Database connection established successfully');
  } catch (error) {
    console.error('Unable to connect to the database:', error);
  }
}

// 监控连接池状态
sequelize.connectionManager.on('pool-acquire', (connection) => {
  console.log('Connection acquired from pool');
});

sequelize.connectionManager.on('pool-release', (connection) => {
  console.log('Connection released to pool');
});

module.exports = { sequelize, testConnection };
```

#### 3.2.2 连接池监控

```javascript
// src/utils/db-monitor.js
const { sequelize } = require('../config/database');

class DatabaseMonitor {
  static getConnectionPoolStats() {
    const pool = sequelize.connectionManager.pool;
    
    return {
      used: pool.used,
      free: pool.free,
      pending: pool.pending,
      maxSize: pool.maxSize,
      minSize: pool.minSize
    };
  }
  
  static async getDatabaseStats() {
    try {
      // 获取连接池状态
      const poolStats = this.getConnectionPoolStats();
      
      // 获取慢查询日志
      const slowQueries = await this.getSlowQueries();
      
      // 获取表大小信息
      const tableSizes = await this.getTableSizes();
      
      return {
        pool: poolStats,
        slowQueries,
        tableSizes
      };
    } catch (error) {
      console.error('Database monitoring error:', error);
      return null;
    }
  }
  
  static async getSlowQueries() {
    // 实现慢查询监控逻辑
    // 这里可以查询MySQL的slow_log表或使用其他监控工具
    return [];
  }
  
  static async getTableSizes() {
    // 实现表大小查询逻辑
    try {
      const [results] = await sequelize.query(`
        SELECT 
          table_name,
          ROUND(((data_length + index_length) / 1024 / 1024), 2) AS size_mb
        FROM information_schema.tables 
        WHERE table_schema = DATABASE()
        ORDER BY (data_length + index_length) DESC
      `);
      
      return results;
    } catch (error) {
      console.error('Table size query error:', error);
      return [];
    }
  }
}

module.exports = DatabaseMonitor;
```

### 3.3 查询缓存

#### 3.3.1 Sequelize查询缓存

```javascript
// src/utils/query-cache.js
const redisClient = require('../config/redis');
const crypto = require('crypto');

class QueryCache {
  static generateQueryKey(query, options) {
    const queryStr = JSON.stringify({ query, options });
    return `query:${crypto.createHash('md5').update(queryStr).digest('hex')}`;
  }
  
  static async getCachedQuery(query, options = {}) {
    const cacheKey = this.generateQueryKey(query, options);
    
    try {
      const cached = await redisClient.get(cacheKey);
      if (cached) {
        console.log(`Query cache HIT: ${cacheKey}`);
        return JSON.parse(cached);
      }
      return null;
    } catch (error) {
      console.error('Query cache read error:', error);
      return null;
    }
  }
  
  static async setCachedQuery(query, result, options = {}) {
    const { ttl = 300 } = options;
    const cacheKey = this.generateQueryKey(query, options);
    
    try {
      await redisClient.setex(cacheKey, ttl, JSON.stringify(result));
      console.log(`Query cached: ${cacheKey}`);
    } catch (error) {
      console.error('Query cache write error:', error);
    }
  }
  
  static async invalidateQueryPattern(pattern) {
    try {
      const keys = await redisClient.keys(`query:${pattern}*`);
      if (keys.length > 0) {
        await redisClient.del(...keys);
        console.log(`Invalidated ${keys.length} query cache keys`);
      }
    } catch (error) {
      console.error('Query cache invalidation error:', error);
    }
  }
}

module.exports = QueryCache;
```

#### 3.3.2 使用查询缓存

```javascript
// src/app/services/product.service.js
const { Product } = require('../models');
const QueryCache = require('../../utils/query-cache');

class ProductService {
  async getFeaturedProducts(limit = 10) {
    const query = 'featured_products';
    const options = { limit };
    
    // 尝试从缓存获取
    let products = await QueryCache.getCachedQuery(query, options);
    if (products) {
      return products;
    }
    
    // 从数据库查询
    products = await Product.findAll({
      where: {
        is_featured: true,
        status: 'active'
      },
      limit,
      order: [['created_at', 'DESC']],
      attributes: ['id', 'name', 'price', 'image_url', 'rating']
    });
    
    // 缓存结果
    await QueryCache.setCachedQuery(query, products, { ttl: 600 });
    
    return products;
  }
  
  async searchProducts(keyword, options = {}) {
    const {
      page = 1,
      limit = 20,
      category_id,
      min_price,
      max_price
    } = options;
    
    const offset = (page - 1) * limit;
    
    // 构建查询条件
    const where = {
      status: 'active'
    };
    
    if (keyword) {
      where.name = {
        [Op.like]: `%${keyword}%`
      };
    }
    
    if (category_id) {
      where.category_id = category_id;
    }
    
    if (min_price || max_price) {
      where.price = {};
      if (min_price) where.price[Op.gte] = min_price;
      if (max_price) where.price[Op.lte] = max_price;
    }
    
    const query = 'search_products';
    const cacheOptions = { keyword, page, limit, category_id, min_price, max_price };
    
    // 尝试从缓存获取
    let result = await QueryCache.getCachedQuery(query, cacheOptions);
    if (result) {
      return result;
    }
    
    // 从数据库查询
    result = await Product.findAndCountAll({
      where,
      limit,
      offset,
      order: [['created_at', 'DESC']],
      attributes: ['id', 'name', 'price', 'image_url', 'rating', 'created_at']
    });
    
    const response = {
      data: result.rows,
      pagination: {
        total: result.count,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(result.count / limit)
      }
    };
    
    // 缓存结果
    await QueryCache.setCachedQuery(query, response, { ttl: 300 });
    
    return response;
  }
  
  async updateProduct(id, productData) {
    try {
      const product = await Product.findByPk(id);
      if (!product) {
        throw new Error('Product not found');
      }
      
      await product.update(productData);
      
      // 使相关缓存失效
      await QueryCache.invalidateQueryPattern('featured_products');
      await QueryCache.invalidateQueryPattern('search_products');
      
      return product;
    } catch (error) {
      throw error;
    }
  }
}

module.exports = new ProductService();
```

## 4. CDN集成方案

### 4.1 CDN基础配置

#### 4.1.1 静态资源CDN

```javascript
// src/config/cdn.js
const config = require('./index');

const cdnConfig = {
  enabled: config.cdn.enabled || false,
  baseUrl: config.cdn.baseUrl || '',
  staticAssets: {
    images: '/images',
    css: '/css',
    js: '/js',
    fonts: '/fonts'
  },
  ttl: config.cdn.ttl || 86400, // 默认24小时
  compression: config.cdn.compression || true
};

module.exports = cdnConfig;
```

#### 4.1.2 静态资源中间件

```javascript
// src/middleware/static-cdn.middleware.js
const cdnConfig = require('../config/cdn');
const path = require('path');
const fs = require('fs').promises;

const staticCdnMiddleware = async (ctx, next) => {
  if (!cdnConfig.enabled) {
    return await next();
  }
  
  // 检查是否为静态资源请求
  const staticPaths = Object.values(cdnConfig.staticAssets);
  const isStaticAsset = staticPaths.some(staticPath => 
    ctx.path.startsWith(staticPath)
  );
  
  if (!isStaticAsset) {
    return await next();
  }
  
  // 重定向到CDN
  const cdnUrl = `${cdnConfig.baseUrl}${ctx.path}`;
  ctx.redirect(cdnUrl);
};

module.exports = staticCdnMiddleware;
```

### 4.2 动态内容CDN

#### 4.2.1 CDN头部设置

```javascript
// src/middleware/cdn-headers.middleware.js
const cdnConfig = require('../config/cdn');

const cdnHeadersMiddleware = async (ctx, next) => {
  await next();
  
  // 为可缓存的响应设置CDN头部
  if (ctx.status === 200 && ctx.method === 'GET') {
    // 检查是否为可缓存内容
    const cacheablePaths = [
      '/api/products',
      '/api/categories',
      '/api/featured'
    ];
    
    const isCacheable = cacheablePaths.some(path => 
      ctx.path.startsWith(path)
    );
    
    if (isCacheable) {
      // 设置CDN缓存头部
      ctx.set('Cache-Control', `public, max-age=${cdnConfig.ttl}`);
      ctx.set('CDN-Cache-Control', `max-age=${cdnConfig.ttl}`);
      
      // 启用压缩
      if (cdnConfig.compression) {
        ctx.set('Content-Encoding', 'gzip');
      }
    }
  }
};

module.exports = cdnHeadersMiddleware;
```

#### 4.2.2 图片优化CDN

```javascript
// src/utils/image-cdn.js
const cdnConfig = require('../config/cdn');
const sharp = require('sharp');
const path = require('path');

class ImageCDN {
  static getOptimizedImageUrl(imagePath, options = {}) {
    if (!cdnConfig.enabled) {
      return `/uploads${imagePath}`;
    }
    
    const {
      width,
      height,
      quality = 80,
      format = 'webp'
    } = options;
    
    // 构建CDN优化URL
    let cdnUrl = `${cdnConfig.baseUrl}/images${imagePath}`;
    
    const params = [];
    if (width) params.push(`w=${width}`);
    if (height) params.push(`h=${height}`);
    if (quality) params.push(`q=${quality}`);
    if (format) params.push(`f=${format}`);
    
    if (params.length > 0) {
      cdnUrl += `?${params.join('&')}`;
    }
    
    return cdnUrl;
  }
  
  static async processImage(localPath, options = {}) {
    try {
      const {
        width,
        height,
        quality = 80,
        format = 'webp'
      } = options;
      
      // 读取原始图片
      const imageBuffer = await fs.readFile(localPath);
      
      // 使用Sharp处理图片
      let processor = sharp(imageBuffer);
      
      // 调整尺寸
      if (width || height) {
        processor = processor.resize(width, height, {
          fit: 'inside',
          withoutEnlargement: true
        });
      }
      
      // 设置格式和质量
      switch (format.toLowerCase()) {
        case 'webp':
          processor = processor.webp({ quality });
          break;
        case 'jpeg':
        case 'jpg':
          processor = processor.jpeg({ quality });
          break;
        case 'png':
          processor = processor.png({ quality: Math.round(quality / 10) });
          break;
        default:
          processor = processor.webp({ quality });
      }
      
      // 生成处理后的图片
      const processedBuffer = await processor.toBuffer();
      
      // 保存处理后的图片
      const ext = path.extname(localPath);
      const basename = path.basename(localPath, ext);
      const processedPath = path.join(
        path.dirname(localPath),
        `${basename}_${width}x${height}.${format}`
      );
      
      await fs.writeFile(processedPath, processedBuffer);
      
      return processedPath;
    } catch (error) {
      console.error('Image processing error:', error);
      throw error;
    }
  }
}

module.exports = ImageCDN;
```

### 4.3 CDN缓存策略

#### 4.3.1 缓存键生成

```javascript
// src/utils/cdn-cache-key.js
const crypto = require('crypto');

class CDNCacheKey {
  static generate(apiPath, queryParams = {}, headers = {}) {
    // 提取影响缓存的关键参数
    const cacheParams = {
      path: apiPath,
      query: this.extractCacheableQueryParams(queryParams),
      headers: this.extractCacheableHeaders(headers)
    };
    
    // 生成缓存键
    const cacheKeyStr = JSON.stringify(cacheParams);
    return crypto.createHash('md5').update(cacheKeyStr).digest('hex');
  }
  
  static extractCacheableQueryParams(queryParams) {
    // 定义可缓存的查询参数
    const cacheableParams = [
      'page', 'limit', 'sort', 'category', 'brand', 'min_price', 'max_price'
    ];
    
    const result = {};
    for (const param of cacheableParams) {
      if (queryParams[param] !== undefined) {
        result[param] = queryParams[param];
      }
    }
    
    return result;
  }
  
  static extractCacheableHeaders(headers) {
    // 定义可缓存的请求头
    const cacheableHeaders = [
      'accept-language', 'accept-encoding'
    ];
    
    const result = {};
    for (const header of cacheableHeaders) {
      if (headers[header]) {
        result[header] = headers[header];
      }
    }
    
    return result;
  }
}

module.exports = CDNCacheKey;
```

#### 4.3.2 缓存预热

```javascript
// src/utils/cdn-warmer.js
const axios = require('axios');
const cdnConfig = require('../config/cdn');

class CDNCacher {
  static async warmCache(urls) {
    if (!cdnConfig.enabled) {
      console.log('CDN is not enabled, skipping cache warming');
      return;
    }
    
    console.log(`Warming up CDN cache for ${urls.length} URLs`);
    
    const results = [];
    
    for (const url of urls) {
      try {
        // 发送请求预热CDN缓存
        const response = await axios.get(url, {
          timeout: 10000,
          headers: {
            'User-Agent': 'CDN-Cache-Warmer/1.0'
          }
        });
        
        results.push({
          url,
          status: response.status,
          success: true
        });
        
        console.log(`Successfully warmed cache for: ${url}`);
      } catch (error) {
        results.push({
          url,
          error: error.message,
          success: false
        });
        
        console.error(`Failed to warm cache for ${url}:`, error.message);
      }
      
      // 添加延迟避免过于频繁的请求
      await this.delay(100);
    }
    
    return results;
  }
  
  static async warmPopularContent() {
    const popularUrls = [
      `${cdnConfig.baseUrl}/api/products/featured`,
      `${cdnConfig.baseUrl}/api/categories`,
      `${cdnConfig.baseUrl}/api/products?page=1&limit=20`,
      // 添加更多热门URL
    ];
    
    return await this.warmCache(popularUrls);
  }
  
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = CDNCacher;
```

## 5. 性能监控与分析

### 5.1 性能指标收集

#### 5.1.1 响应时间监控

```javascript
// src/middleware/performance.middleware.js
const redisClient = require('../config/redis');

const performanceMiddleware = async (ctx, next) => {
  const start = Date.now();
  
  try {
    await next();
    
    const duration = Date.now() - start;
    
    // 记录响应时间
    await redisClient.lpush('response_times', duration);
    await redisClient.ltrim('response_times', 0, 999); // 保持最近1000个记录
    
    // 设置响应时间头部
    ctx.set('X-Response-Time', `${duration}ms`);
    
    // 记录慢查询
    if (duration > 1000) { // 超过1秒的请求
      await redisClient.lpush('slow_requests', JSON.stringify({
        url: ctx.url,
        method: ctx.method,
        duration,
        timestamp: new Date().toISOString()
      }));
      await redisClient.ltrim('slow_requests', 0, 99); // 保持最近100个慢查询
    }
  } catch (error) {
    const duration = Date.now() - start;
    ctx.set('X-Response-Time', `${duration}ms`);
    throw error;
  }
};

module.exports = performanceMiddleware;
```

#### 5.1.2 数据库查询监控

```javascript
// src/utils/db-profiler.js
const redisClient = require('../config/redis');

class DatabaseProfiler {
  static async profileQuery(query, options = {}) {
    const start = Date.now();
    
    try {
      const result = await query;
      const duration = Date.now() - start;
      
      // 记录查询性能
      await this.recordQueryPerformance({
        sql: options.sql || 'Unknown',
        duration,
        success: true,
        timestamp: new Date().toISOString()
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      
      // 记录失败的查询
      await this.recordQueryPerformance({
        sql: options.sql || 'Unknown',
        duration,
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      
      throw error;
    }
  }
  
  static async recordQueryPerformance(data) {
    try {
      await redisClient.lpush('db_queries', JSON.stringify(data));
      await redisClient.ltrim('db_queries', 0, 999); // 保持最近1000个查询记录
      
      // 记录慢查询
      if (data.duration > 500) { // 超过500ms的查询
        await redisClient.lpush('slow_db_queries', JSON.stringify(data));
        await redisClient.ltrim('slow_db_queries', 0, 99); // 保持最近100个慢查询
      }
    } catch (error) {
      console.error('Query profiling error:', error);
    }
  }
  
  static async getPerformanceStats() {
    try {
      // 获取响应时间统计
      const responseTimes = await redisClient.lrange('response_times', 0, -1);
      const responseTimeNumbers = responseTimes.map(time => parseInt(time));
      
      // 获取慢查询统计
      const slowRequests = await redisClient.lrange('slow_requests', 0, -1);
      
      // 获取数据库查询统计
      const dbQueries = await redisClient.lrange('db_queries', 0, -1);
      const slowDbQueries = await redisClient.lrange('slow_db_queries', 0, -1);
      
      return {
        responseTimes: {
          count: responseTimeNumbers.length,
          avg: responseTimeNumbers.length > 0 
            ? responseTimeNumbers.reduce((a, b) => a + b, 0) / responseTimeNumbers.length 
            : 0,
          min: responseTimeNumbers.length > 0 ? Math.min(...responseTimeNumbers) : 0,
          max: responseTimeNumbers.length > 0 ? Math.max(...responseTimeNumbers) : 0
        },
        slowRequests: slowRequests.length,
        dbQueries: dbQueries.length,
        slowDbQueries: slowDbQueries.length
      };
    } catch (error) {
      console.error('Performance stats error:', error);
      return null;
    }
  }
}

module.exports = DatabaseProfiler;
```

### 5.2 性能优化建议

#### 5.2.1 性能分析工具

```javascript
// src/utils/performance-analyzer.js
const DatabaseProfiler = require('./db-profiler');

class PerformanceAnalyzer {
  static async analyze() {
    const stats = await DatabaseProfiler.getPerformanceStats();
    if (!stats) return null;
    
    const recommendations = [];
    
    // 分析响应时间
    if (stats.responseTimes.avg > 500) {
      recommendations.push({
        type: 'warning',
        message: '平均响应时间过长',
        suggestion: '检查慢查询和数据库性能'
      });
    }
    
    if (stats.responseTimes.max > 5000) {
      recommendations.push({
        type: 'critical',
        message: '存在超长响应时间请求',
        suggestion: '立即检查和优化相关接口'
      });
    }
    
    // 分析慢查询
    if (stats.slowDbQueries > 10) {
      recommendations.push({
        type: 'warning',
        message: '存在较多慢数据库查询',
        suggestion: '优化慢查询SQL，添加必要索引'
      });
    }
    
    // 分析缓存命中率
    const cacheHitRate = await this.calculateCacheHitRate();
    if (cacheHitRate < 0.8) { // 缓存命中率低于80%
      recommendations.push({
        type: 'info',
        message: '缓存命中率较低',
        suggestion: '优化缓存策略，增加缓存覆盖'
      });
    }
    
    return {
      stats,
      recommendations
    };
  }
  
  static async calculateCacheHitRate() {
    try {
      // 这里需要实现实际的缓存命中率计算逻辑
      // 可以通过Redis统计缓存命中和未命中的次数
      return 0.85; // 示例值
    } catch (error) {
      console.error('Cache hit rate calculation error:', error);
      return 0;
    }
  }
  
  static async generateReport() {
    const analysis = await this.analyze();
    if (!analysis) return null;
    
    return `
# 性能分析报告

## 统计数据
- 平均响应时间: ${analysis.stats.responseTimes.avg.toFixed(2)}ms
- 最大响应时间: ${analysis.stats.responseTimes.max}ms
- 慢请求数量: ${analysis.stats.slowRequests}
- 数据库查询总数: ${analysis.stats.dbQueries}
- 慢数据库查询: ${analysis.stats.slowDbQueries}

## 优化建议
${analysis.recommendations.map(rec => 
  `- [${rec.type.toUpperCase()}] ${rec.message}: ${rec.suggestion}`
).join('\n')}
    `.trim();
  }
}

module.exports = PerformanceAnalyzer;
```

## 6. 总结

本文档详细介绍了企业级电商系统的缓存与性能优化策略。通过Redis缓存实现、数据库优化技术和CDN集成方案，我们能够显著提升系统性能和用户体验。

### 6.1 关键要点

1. **缓存策略**：实现多层缓存架构，包括应用层缓存和分布式缓存
2. **Redis优化**：合理配置Redis连接池和缓存失效策略
3. **数据库优化**：通过索引优化、查询优化和连接池调优提升数据库性能
4. **CDN集成**：利用CDN加速静态资源和动态内容的分发
5. **性能监控**：建立完善的性能监控体系，及时发现和解决性能瓶颈

### 6.2 下一步学习

- 实现消息队列与异步处理机制
- 完善测试策略与实践
- 实施部署与运维方案
- 构建监控与日志系统

继续阅读后续文档，深入学习电商系统的其他核心功能模块！