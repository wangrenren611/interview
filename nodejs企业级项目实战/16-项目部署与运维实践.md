# 16-项目部署与运维实践

## 1. 容器化部署

### 1.1 Docker配置优化

#### 1.1.1 多阶段构建

**Dockerfile**
```dockerfile
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY tsconfig*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制源码
COPY src/ ./src/

# 构建应用
RUN npm run build

# 生产阶段
FROM node:18-alpine AS production

# 创建非root用户
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# 复制构建产物
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# 设置用户
USER nodejs

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node dist/health-check.js

# 暴露端口
EXPOSE 3000

# 启动应用
CMD ["node", "dist/server.js"]
```

#### 1.1.2 Docker Compose配置

**docker-compose.yml**
```yaml
version: '3.8'

services:
  # 应用服务
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: ecommerce-api
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - ecommerce-network
    volumes:
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "node", "dist/health-check.js"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: ecommerce-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./docker/mysql/conf.d:/etc/mysql/conf.d
      - ./docker/mysql/init:/docker-entrypoint-initdb.d
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

  # Redis缓存
  redis:
    image: redis:7.0-alpine
    container_name: ecommerce-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./docker/redis/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: ecommerce-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/conf.d:/etc/nginx/conf.d
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    networks:
      - ecommerce-network

volumes:
  mysql_data:
  redis_data:

networks:
  ecommerce-network:
    driver: bridge
```

### 1.2 Kubernetes部署

#### 1.2.1 应用部署配置

**k8s/deployment.yaml**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ecommerce-api
  labels:
    app: ecommerce-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ecommerce-api
  template:
    metadata:
      labels:
        app: ecommerce-api
    spec:
      containers:
      - name: ecommerce-api
        image: ecommerce-api:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: ecommerce-secrets
              key: db-host
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: ecommerce-secrets
              key: db-password
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: logs
          mountPath: /app/logs
      volumes:
      - name: logs
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: ecommerce-api-service
spec:
  selector:
    app: ecommerce-api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer
```

#### 1.2.2 配置管理

**k8s/configmap.yaml**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: ecommerce-config
data:
  NODE_ENV: "production"
  APP_NAME: "ECommerce API"
  APP_VERSION: "1.0.0"
  LOG_LEVEL: "info"
  REDIS_HOST: "redis-service"
  REDIS_PORT: "6379"
---
apiVersion: v1
kind: Secret
metadata:
  name: ecommerce-secrets
type: Opaque
data:
  db-host: bXlzcWwtc2VydmljZQ==  # base64 encoded
  db-password: cGFzc3dvcmQxMjM=  # base64 encoded
  jwt-secret: c3VwZXJfc2VjcmV0X2tleQ==  # base64 encoded
```

## 2. CI/CD流水线

### 2.1 GitHub Actions配置

**.github/workflows/ci-cd.yml**
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 代码质量检查
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Type check
      run: npm run type-check

    - name: Lint code
      run: npm run lint

    - name: Format check
      run: npm run format:check

    - name: Run tests
      run: npm run test:coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info

  # 构建和推送镜像
  build-and-push:
    needs: quality-check
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # 部署到测试环境
  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment"
        # 部署逻辑

  # 部署到生产环境
  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - name: Deploy to production
      run: |
        echo "Deploying to production environment"
        # 部署逻辑
```

### 2.2 自动化测试

**tests/integration/api.test.ts**
```typescript
import request from 'supertest';
import app from '../../src/app';
import { sequelize } from '../../src/database/connection';

describe('API Integration Tests', () => {
  beforeAll(async () => {
    await sequelize.sync({ force: true });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  describe('User API', () => {
    it('should create a new user', async () => {
      const userData = {
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.username).toBe(userData.username);
      expect(response.body.data.email).toBe(userData.email);
      expect(response.body.data.password_hash).toBeUndefined();
    });

    it('should authenticate user', async () => {
      const credentials = {
        email: 'test@example.com',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/auth/login')
        .send(credentials)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.token).toBeDefined();
    });
  });
});
```

## 3. 监控与日志

### 3.1 应用监控

#### 3.1.1 Prometheus指标

**src/middleware/metrics.middleware.ts**
```typescript
import { Context, Next } from 'koa';
import client from 'prom-client';

// 创建指标
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const httpRequestTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const activeConnections = new client.Gauge({
  name: 'active_connections',
  help: 'Number of active connections'
});

// 中间件
export const metricsMiddleware = async (ctx: Context, next: Next): Promise<void> => {
  const start = Date.now();
  
  await next();
  
  const duration = (Date.now() - start) / 1000;
  const route = ctx.route?.path || ctx.path;
  
  httpRequestDuration
    .labels(ctx.method, route, ctx.status.toString())
    .observe(duration);
    
  httpRequestTotal
    .labels(ctx.method, route, ctx.status.toString())
    .inc();
};

// 健康检查端点
export const healthCheck = async (ctx: Context): Promise<void> => {
  ctx.body = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    version: process.env.APP_VERSION
  };
};

// 指标端点
export const metricsEndpoint = async (ctx: Context): Promise<void> => {
  ctx.set('Content-Type', client.register.contentType);
  ctx.body = await client.register.metrics();
};
```

#### 3.1.2 日志配置

**src/utils/logger.ts**
```typescript
import winston from 'winston';
import config from '../config';

// 日志格式
const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// 创建logger
const logger = winston.createLogger({
  level: config.app.isDevelopment ? 'debug' : 'info',
  format: logFormat,
  defaultMeta: { service: 'ecommerce-api' },
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // 文件输出
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

// 请求日志中间件
export const requestLogger = async (ctx: Context, next: Next): Promise<void> => {
  const start = Date.now();
  
  await next();
  
  const duration = Date.now() - start;
  
  logger.info('HTTP Request', {
    method: ctx.method,
    url: ctx.url,
    status: ctx.status,
    duration: `${duration}ms`,
    userAgent: ctx.get('User-Agent'),
    ip: ctx.ip,
    userId: ctx.user?.id
  });
};

export default logger;
```

### 3.2 错误监控

#### 3.2.1 Sentry集成

**src/utils/sentry.ts**
```typescript
import * as Sentry from '@sentry/node';
import { ProfilingIntegration } from '@sentry/profiling-node';
import config from '../config';

// 初始化Sentry
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: config.app.env,
  integrations: [
    new ProfilingIntegration(),
  ],
  tracesSampleRate: config.app.isProduction ? 0.1 : 1.0,
  profilesSampleRate: config.app.isProduction ? 0.1 : 1.0,
});

// 错误处理中间件
export const sentryErrorHandler = async (ctx: Context, next: Next): Promise<void> => {
  try {
    await next();
  } catch (error) {
    Sentry.withScope((scope) => {
      scope.setTag('component', 'koa');
      scope.setContext('request', {
        method: ctx.method,
        url: ctx.url,
        headers: ctx.headers,
        body: ctx.request.body
      });
      scope.setUser({
        id: ctx.user?.id,
        username: ctx.user?.username
      });
      
      Sentry.captureException(error);
    });
    
    throw error;
  }
};

export default Sentry;
```

## 4. 性能优化

### 4.1 缓存策略

#### 4.1.1 Redis缓存实现

**src/services/cache.service.ts**
```typescript
import Redis from 'ioredis';
import config from '../config';

class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: config.redis.host,
      port: config.redis.port,
      password: config.redis.password,
      db: config.redis.db,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3
    });
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    try {
      await this.redis.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async del(key: string): Promise<void> {
    try {
      await this.redis.del(key);
    } catch (error) {
      console.error('Cache delete error:', error);
    }
  }

  async invalidatePattern(pattern: string): Promise<void> {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error('Cache invalidate pattern error:', error);
    }
  }
}

export default new CacheService();
```

#### 4.1.2 缓存装饰器

**src/decorators/cache.decorator.ts**
```typescript
import cacheService from '../services/cache.service';

export function Cache(ttl: number = 3600, keyGenerator?: (...args: any[]) => string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheKey = keyGenerator 
        ? keyGenerator(...args)
        : `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;

      // 尝试从缓存获取
      const cached = await cacheService.get(cacheKey);
      if (cached) {
        return cached;
      }

      // 执行原方法
      const result = await method.apply(this, args);
      
      // 缓存结果
      await cacheService.set(cacheKey, result, ttl);
      
      return result;
    };
  };
}

// 使用示例
class ProductService {
  @Cache(1800, (id: number) => `product:${id}`)
  async getProductById(id: number): Promise<Product> {
    // 数据库查询逻辑
    return await Product.findByPk(id);
  }
}
```

### 4.2 数据库优化

#### 4.2.1 连接池配置

**src/database/connection.ts**
```typescript
import { Sequelize, Options } from 'sequelize';
import config from '../config';

const sequelizeOptions: Options = {
  host: config.database.host,
  port: config.database.port,
  dialect: 'mysql',
  timezone: config.database.timezone,
  logging: config.database.logging,
  
  // 连接池优化
  pool: {
    max: 20,        // 最大连接数
    min: 5,         // 最小连接数
    acquire: 30000, // 获取连接超时时间
    idle: 10000,    // 连接空闲时间
    evict: 1000,    // 检查空闲连接间隔
    handleDisconnects: true
  },
  
  // 查询优化
  benchmark: true,
  retry: {
    max: 3,
    timeout: 60000,
    match: [
      /ETIMEDOUT/,
      /EHOSTUNREACH/,
      /ECONNRESET/,
      /ECONNREFUSED/,
      /ETIMEDOUT/,
      /ESOCKETTIMEDOUT/,
      /EHOSTUNREACH/,
      /EPIPE/,
      /EAI_AGAIN/,
      /SequelizeConnectionError/,
      /SequelizeConnectionRefusedError/,
      /SequelizeHostNotFoundError/,
      /SequelizeHostNotReachableError/,
      /SequelizeInvalidConnectionError/,
      /SequelizeConnectionTimedOutError/
    ]
  },
  
  define: {
    timestamps: true,
    underscored: true,
    freezeTableName: true,
    paranoid: false
  }
};

const sequelize = new Sequelize(
  config.database.database,
  config.database.username,
  config.database.password,
  sequelizeOptions
);

export { sequelize };
export default sequelize;
```

## 5. 安全配置

### 5.1 安全中间件

**src/middleware/security.middleware.ts**
```typescript
import { Context, Next } from 'koa';
import rateLimit from 'koa-ratelimit';
import helmet from 'koa-helmet';
import Redis from 'ioredis';

// 限流配置
export const rateLimitMiddleware = rateLimit({
  driver: 'redis',
  db: new Redis({
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD
  }),
  duration: 60000, // 1分钟
  errorMessage: '请求过于频繁，请稍后再试',
  id: (ctx: Context) => ctx.ip,
  headers: {
    remaining: 'Rate-Limit-Remaining',
    reset: 'Rate-Limit-Reset',
    total: 'Rate-Limit-Total'
  },
  max: 100, // 每分钟最多100次请求
  disableHeader: false
});

// 安全头配置
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

// 输入验证中间件
export const inputValidation = (schema: any) => {
  return async (ctx: Context, next: Next): Promise<void> => {
    try {
      const { error, value } = schema.validate(ctx.request.body);
      if (error) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: '输入验证失败',
          errors: error.details.map(detail => detail.message)
        };
        return;
      }
      ctx.request.body = value;
      await next();
    } catch (err) {
      ctx.status = 400;
      ctx.body = {
        success: false,
        message: '输入验证错误'
      };
    }
  };
};
```

## 6. 总结

企业级项目的部署与运维是一个系统工程，需要从容器化、CI/CD、监控、性能优化、安全等多个维度进行考虑和实践。

### 6.1 关键要点

1. **容器化部署**：使用Docker和Kubernetes实现应用的标准化部署
2. **自动化流水线**：建立完整的CI/CD流程，确保代码质量和部署效率
3. **监控告警**：建立完善的监控体系，及时发现和处理问题
4. **性能优化**：通过缓存、数据库优化等手段提升系统性能
5. **安全防护**：实施多层次的安全防护措施

### 6.2 持续改进

- 定期评估和优化部署流程
- 持续监控系统性能和安全状况
- 建立完善的文档和知识库
- 培养团队的技术能力和运维经验
