# 03-用户认证与权限管理

## 1. 用户认证系统概述

### 1.1 认证vs授权

#### 1.1.1 认证（Authentication）
认证是验证用户身份的过程，回答"你是谁？"的问题。

#### 1.1.2 授权（Authorization）
授权是验证用户权限的过程，回答"你能做什么？"的问题。

### 1.2 JWT（JSON Web Token）原理

#### 1.2.1 JWT结构
JWT由三部分组成，用点(.)分隔：`Header.Payload.Signature`

```javascript
// JWT服务类
class JWTService {
  constructor() {
    this.secret = process.env.JWT_SECRET;
    this.expiresIn = process.env.JWT_EXPIRES_IN || '7d';
  }

  // 生成访问令牌
  generateAccessToken(user) {
    const payload = {
      userId: user.id,
      username: user.username,
      email: user.email,
      roles: user.roles || []
    };

    return jwt.sign(payload, this.secret, {
      expiresIn: this.expiresIn,
      issuer: 'ecommerce-api'
    });
  }

  // 验证访问令牌
  verifyAccessToken(token) {
    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Access token has expired');
      }
      throw new Error('Invalid access token');
    }
  }
}
```

## 2. 用户认证实现

### 2.1 用户注册验证
```javascript
// 注册数据验证
const registerSchema = Joi.object({
  username: Joi.string().alphanum().min(3).max(50).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).required(),
  confirmPassword: Joi.string().valid(Joi.ref('password')).required()
});
```

### 2.2 用户注册控制器
```javascript
class RegisterController {
  async register(ctx) {
    try {
      // 1. 数据验证
      const { error, value } = registerSchema.validate(ctx.request.body);
      if (error) {
        ctx.status = 400;
        ctx.body = { success: false, message: '数据验证失败' };
        return;
      }

      const { username, email, password } = value;

      // 2. 检查用户是否已存在
      const existingUser = await User.findOne({
        where: { [Op.or]: [{ username }, { email }] }
      });

      if (existingUser) {
        ctx.status = 409;
        ctx.body = { success: false, message: '用户已存在' };
        return;
      }

      // 3. 创建用户
      const user = await User.create({
        username,
        email,
        password_hash: password
      });

      // 4. 分配默认角色
      const customerRole = await Role.findOne({ where: { name: 'customer' } });
      if (customerRole) {
        await user.addRoleList([customerRole]);
      }

      // 5. 生成JWT令牌
      const roles = ['customer'];
      const userWithRoles = { ...user.toJSON(), roles };
      const accessToken = jwtService.generateAccessToken(userWithRoles);

      // 6. 返回响应
      ctx.status = 201;
      ctx.body = {
        success: true,
        message: '注册成功',
        data: {
          user: { id: user.id, username: user.username, email: user.email },
          token: accessToken
        }
      };

    } catch (error) {
      ctx.status = 500;
      ctx.body = { success: false, message: '注册失败' };
    }
  }
}
```

### 2.3 用户登录控制器
```javascript
class LoginController {
  async login(ctx) {
    try {
      const { username, password } = ctx.request.body;

      // 查找用户
      const user = await User.findOne({
        where: { [Op.or]: [{ username }, { email: username }] },
        include: [{ model: Role, as: 'roleList' }]
      });

      if (!user || !(await user.validatePassword(password))) {
        ctx.status = 401;
        ctx.body = { success: false, message: '用户名或密码错误' };
        return;
      }

      // 检查用户状态
      if (user.status !== 'active') {
        ctx.status = 403;
        ctx.body = { success: false, message: '账户未激活' };
        return;
      }

      // 更新最后登录信息
      await user.update({
        last_login_at: new Date(),
        last_login_ip: ctx.ip
      });

      // 生成JWT令牌
      const roles = user.roleList.map(role => role.name);
      const userWithRoles = { ...user.toJSON(), roles };
      const accessToken = jwtService.generateAccessToken(userWithRoles);

      // 返回响应
      ctx.status = 200;
      ctx.body = {
        success: true,
        message: '登录成功',
        data: {
          user: { id: user.id, username: user.username, email: user.email, roles },
          token: accessToken
        }
      };

    } catch (error) {
      ctx.status = 500;
      ctx.body = { success: false, message: '登录失败' };
    }
  }
}
```

## 3. 认证中间件

### 3.1 JWT认证中间件
```javascript
class AuthMiddleware {
  static async authenticate(ctx, next) {
    try {
      const authHeader = ctx.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        ctx.status = 401;
        ctx.body = { success: false, message: '访问令牌缺失' };
        return;
      }

      const token = authHeader.substring(7);
      const decoded = jwtService.verifyAccessToken(token);

      // 验证用户是否仍然有效
      const user = await User.findByPk(decoded.userId);
      if (!user || user.status !== 'active') {
        ctx.status = 401;
        ctx.body = { success: false, message: '用户不存在' };
        return;
      }

      ctx.user = { ...decoded, roles: decoded.roles || [] };
      await next();

    } catch (error) {
      ctx.status = 401;
      ctx.body = { success: false, message: '认证失败' };
    }
  }
}
```

## 4. RBAC权限控制系统

### 4.1 权限管理服务
```javascript
class PermissionService {
  // 检查用户权限
  async checkUserPermission(userId, permissionName) {
    try {
      const user = await User.findByPk(userId, {
        include: [{
          model: Role,
          as: 'roleList',
          include: [{
            model: Permission,
            as: 'permissionList',
            where: { name: permissionName },
            required: false
          }]
        }]
      });

      if (!user) return false;

      return user.roleList.some(role => 
        role.permissionList && role.permissionList.length > 0
      );

    } catch (error) {
      return false;
    }
  }

  // 获取用户所有权限
  async getUserPermissions(userId) {
    try {
      const user = await User.findByPk(userId, {
        include: [{
          model: Role,
          as: 'roleList',
          include: [{
            model: Permission,
            as: 'permissionList'
          }]
        }]
      });

      if (!user) return [];

      const permissions = new Set();
      user.roleList.forEach(role => {
        if (role.permissionList) {
          role.permissionList.forEach(permission => {
            permissions.add(permission.name);
          });
        }
      });

      return Array.from(permissions);

    } catch (error) {
      return [];
    }
  }
}
```

### 4.2 权限中间件
```javascript
class PermissionMiddleware {
  // 检查特定权限
  static requirePermission(permissionName) {
    return async (ctx, next) => {
      try {
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = { success: false, message: '请先登录' };
          return;
        }

        const hasPermission = await permissionService.checkUserPermission(
          ctx.user.userId,
          permissionName
        );

        if (!hasPermission) {
          ctx.status = 403;
          ctx.body = { success: false, message: '权限不足' };
          return;
        }

        await next();

      } catch (error) {
        ctx.status = 500;
        ctx.body = { success: false, message: '权限验证失败' };
      }
    };
  }

  // 检查角色
  static requireRole(roleName) {
    return async (ctx, next) => {
      try {
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = { success: false, message: '请先登录' };
          return;
        }

        const hasRole = ctx.user.roles && ctx.user.roles.includes(roleName);

        if (!hasRole) {
          ctx.status = 403;
          ctx.body = { success: false, message: '角色权限不足' };
          return;
        }

        await next();

      } catch (error) {
        ctx.status = 500;
        ctx.body = { success: false, message: '角色验证失败' };
      }
    };
  }
}
```

## 5. 路由保护与API设计

### 5.1 认证路由
```javascript
const router = new Router({ prefix: '/api/auth' });

// 公开路由
router.post('/register', registerController.register);
router.post('/login', loginController.login);

// 需要认证的路由
router.post('/logout', AuthMiddleware.authenticate, loginController.logout);
router.get('/me', AuthMiddleware.authenticate, async (ctx) => {
  ctx.body = { success: true, data: { user: ctx.user } };
});
```

### 5.2 受保护的API路由
```javascript
const router = new Router({ prefix: '/api/users' });

// 所有用户路由都需要认证
router.use(AuthMiddleware.authenticate);

// 获取用户列表 - 需要管理员权限
router.get('/', 
  PermissionMiddleware.requirePermission('user.list'),
  userController.list
);

// 获取单个用户 - 需要查看用户权限
router.get('/:id', 
  PermissionMiddleware.requirePermission('user.view'),
  userController.show
);

// 创建用户 - 需要创建用户权限
router.post('/', 
  PermissionMiddleware.requirePermission('user.create'),
  userController.create
);

// 更新用户 - 需要更新权限或是用户本人
router.put('/:id', 
  PermissionMiddleware.requireAnyPermission(['user.update', 'user.update.own']),
  userController.update
);

// 删除用户 - 需要删除权限
router.delete('/:id', 
  PermissionMiddleware.requirePermission('user.delete'),
  userController.delete
);
```

## 6. 安全最佳实践

### 6.1 密码安全
```javascript
// 密码加密服务
const bcrypt = require('bcryptjs');

class PasswordService {
  static async hashPassword(password) {
    const saltRounds = 12;
    const salt = await bcrypt.genSalt(saltRounds);
    const hash = await bcrypt.hash(password, salt);
    return { hash, salt };
  }

  static async comparePassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }
}
```

### 6.2 防止暴力破解
```javascript
// 限流中间件
class RateLimitMiddleware {
  static loginRateLimit(maxAttempts = 5, windowMs = 15 * 60 * 1000) {
    return async (ctx, next) => {
      const identifier = ctx.ip || 'unknown';
      const key = `login_attempts:${identifier}`;
      
      try {
        const attempts = await redis.get(key);
        
        if (attempts && parseInt(attempts) >= maxAttempts) {
          ctx.status = 429;
          ctx.body = { success: false, message: '登录尝试次数过多' };
          return;
        }
        
        await next();
        
      } catch (error) {
        await next();
      }
    };
  }
}
```

### 6.3 JWT安全配置
```javascript
// JWT安全配置
class SecureJWTService {
  constructor() {
    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET;
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET;
    this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '15m';
    this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d';
  }

  generateTokens(user) {
    const accessTokenPayload = {
      userId: user.id,
      username: user.username,
      roles: user.roles
    };

    const refreshTokenPayload = {
      userId: user.id,
      tokenId: this.generateRandomId()
    };

    const accessToken = jwt.sign(accessTokenPayload, this.accessTokenSecret, {
      expiresIn: this.accessTokenExpiry,
      issuer: 'ecommerce-api'
    });

    const refreshToken = jwt.sign(refreshTokenPayload, this.refreshTokenSecret, {
      expiresIn: this.refreshTokenExpiry,
      issuer: 'ecommerce-api'
    });

    return { accessToken, refreshToken };
  }

  generateRandomId() {
    return require('crypto').randomBytes(16).toString('hex');
  }
}
```

## 7. 总结

本文档详细介绍了企业级电商系统的用户认证与权限管理实现。通过JWT令牌认证、RBAC权限控制、安全最佳实践等技术，构建了一个完整、安全的用户管理系统。

### 7.1 关键要点

1. **JWT认证机制**：无状态、可扩展的认证方案
2. **RBAC权限模型**：灵活的角色权限管理
3. **多层次安全防护**：密码安全、限流防护、JWT安全配置
4. **完整的认证流程**：注册、登录、令牌刷新、权限验证

### 7.2 下一步学习

- 实现商品管理模块
- 开发订单处理系统
- 构建支付集成方案

继续阅读后续文档，深入学习电商系统的核心业务功能实现！