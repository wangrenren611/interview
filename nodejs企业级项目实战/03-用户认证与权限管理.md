# 03-用户认证与权限管理

## 1. 用户认证系统概述

### 1.0 TypeScript在认证系统中的优势

在用户认证与权限管理系统中，TypeScript提供了强大的类型安全保障，特别是在处理敏感的用户数据和权限验证时：

#### 1.0.1 类型安全的用户数据
```typescript
// 用户接口定义
interface User {
  id: number;
  username: string;
  email: string;
  status: 'active' | 'inactive' | 'banned';
  roles: Role[];
  created_at: Date;
  updated_at: Date;
}

// JWT载荷类型定义
interface JWTPayload {
  userId: number;
  username: string;
  email: string;
  roles: string[];
  iat?: number;
  exp?: number;
  iss?: string;
}

// 认证响应类型
interface AuthResponse {
  success: boolean;
  message: string;
  data?: {
    user: Pick<User, 'id' | 'username' | 'email'>;
    token: string;
  };
}
```

#### 1.0.2 权限系统的类型安全
```typescript
// 权限类型定义
type Permission = 'user.create' | 'user.read' | 'user.update' | 'user.delete' | 
                 'product.create' | 'product.read' | 'product.update' | 'product.delete' |
                 'order.create' | 'order.read' | 'order.update' | 'order.delete';

// 角色类型定义
interface Role {
  id: number;
  name: string;
  display_name: string;
  permissions: Permission[];
}

// 权限检查结果类型
interface PermissionCheckResult {
  hasPermission: boolean;
  reason?: string;
}
```

### 1.1 认证vs授权

#### 1.1.1 认证（Authentication）
认证是验证用户身份的过程，回答"你是谁？"的问题。在TypeScript中，我们可以通过严格的类型定义来确保认证过程的安全性。

#### 1.1.2 授权（Authorization）
授权是验证用户权限的过程，回答"你能做什么？"的问题。TypeScript的类型系统可以帮助我们在编译时发现权限配置错误。

### 1.2 JWT（JSON Web Token）原理

#### 1.2.1 JWT结构
JWT由三部分组成，用点(.)分隔：`Header.Payload.Signature`

```typescript
import jwt from 'jsonwebtoken';
import config from '../config';

// JWT服务类
class JWTService {
  private readonly secret: string;
  private readonly expiresIn: string;
  private readonly issuer: string;

  constructor() {
    this.secret = config.jwt.secret;
    this.expiresIn = config.jwt.expiresIn;
    this.issuer = 'ecommerce-api';
  }

  // 生成访问令牌
  generateAccessToken(user: User): string {
    const payload: JWTPayload = {
      userId: user.id,
      username: user.username,
      email: user.email,
      roles: user.roles.map(role => role.name)
    };

    return jwt.sign(payload, this.secret, {
      expiresIn: this.expiresIn,
      issuer: this.issuer
    });
  }

  // 验证访问令牌
  verifyAccessToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.secret) as JWTPayload;
    } catch (error: any) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Access token has expired');
      }
      throw new Error('Invalid access token');
    }
  }

  // 生成刷新令牌
  generateRefreshToken(userId: number): string {
    const payload = {
      userId,
      type: 'refresh',
      tokenId: this.generateRandomId()
    };

    return jwt.sign(payload, config.jwt.refreshSecret, {
      expiresIn: config.jwt.refreshExpiresIn,
      issuer: this.issuer
    });
  }

  private generateRandomId(): string {
    return crypto.randomBytes(16).toString('hex');
  }
}

export default new JWTService();
```

## 2. 用户认证实现

### 2.1 用户注册验证

#### 2.1.1 TypeScript类型定义
```typescript
// 注册请求类型
interface RegisterRequest {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

// 注册响应类型
interface RegisterResponse {
  success: boolean;
  message: string;
  data?: {
    user: Pick<User, 'id' | 'username' | 'email'>;
    token: string;
  };
}
```

#### 2.1.2 数据验证Schema
```typescript
import Joi from 'joi';

// 注册数据验证
const registerSchema = Joi.object<RegisterRequest>({
  username: Joi.string().alphanum().min(3).max(50).required()
    .messages({
      'string.alphanum': '用户名只能包含字母和数字',
      'string.min': '用户名至少需要3个字符',
      'string.max': '用户名不能超过50个字符',
      'any.required': '用户名是必填项'
    }),
  email: Joi.string().email().required()
    .messages({
      'string.email': '请输入有效的邮箱地址',
      'any.required': '邮箱是必填项'
    }),
  password: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).required()
    .messages({
      'string.min': '密码至少需要8个字符',
      'string.pattern.base': '密码必须包含至少一个小写字母、一个大写字母和一个数字',
      'any.required': '密码是必填项'
    }),
  confirmPassword: Joi.string().valid(Joi.ref('password')).required()
    .messages({
      'any.only': '确认密码与密码不匹配',
      'any.required': '确认密码是必填项'
    })
});
```

### 2.2 用户注册控制器
```typescript
import { Context } from 'koa';
import { Op } from 'sequelize';
import Joi from 'joi';
import User from '../models/user.model';
import Role from '../models/role.model';
import jwtService from '../services/jwt.service';
import { RegisterRequest, RegisterResponse } from '../types/auth.types';

class RegisterController {
  async register(ctx: Context): Promise<void> {
    try {
      // 1. 数据验证
      const { error, value } = registerSchema.validate(ctx.request.body);
      if (error) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: '数据验证失败',
          errors: error.details.map(detail => detail.message)
        } as RegisterResponse;
        return;
      }

      const { username, email, password }: RegisterRequest = value;

      // 2. 检查用户是否已存在
      const existingUser = await User.findOne({
        where: { 
          [Op.or]: [{ username }, { email }] 
        }
      });

      if (existingUser) {
        ctx.status = 409;
        ctx.body = {
          success: false,
          message: '用户名或邮箱已存在'
        } as RegisterResponse;
        return;
      }

      // 3. 创建用户
      const user = await User.create({
        username,
        email,
        password_hash: password // 模型会自动处理密码加密
      });

      // 4. 分配默认角色
      const customerRole = await Role.findOne({ 
        where: { name: 'customer' } 
      });
      
      if (customerRole) {
        await (user as any).addRoleList([customerRole]);
      }

      // 5. 获取用户角色信息
      const userWithRoles = await User.findByPk(user.id, {
        include: [{ model: Role, as: 'roleList' }]
      });

      // 6. 生成JWT令牌
      const accessToken = jwtService.generateAccessToken(userWithRoles!);

      // 7. 返回响应
      ctx.status = 201;
      ctx.body = {
        success: true,
        message: '注册成功',
        data: {
          user: { 
            id: user.id, 
            username: user.username, 
            email: user.email 
          },
          token: accessToken
        }
      } as RegisterResponse;

    } catch (error: any) {
      console.error('Registration error:', error);
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: '注册失败，请稍后重试'
      } as RegisterResponse;
    }
  }
}

export default new RegisterController();
```

### 2.3 用户登录控制器

#### 2.3.1 登录类型定义
```typescript
// 登录请求类型
interface LoginRequest {
  username: string; // 可以是用户名或邮箱
  password: string;
}

// 登录响应类型
interface LoginResponse {
  success: boolean;
  message: string;
  data?: {
    user: Pick<User, 'id' | 'username' | 'email'> & { roles: string[] };
    token: string;
  };
}
```

#### 2.3.2 登录控制器实现
```typescript
import { Context } from 'koa';
import { Op } from 'sequelize';
import User from '../models/user.model';
import Role from '../models/role.model';
import jwtService from '../services/jwt.service';
import { LoginRequest, LoginResponse } from '../types/auth.types';

class LoginController {
  async login(ctx: Context): Promise<void> {
    try {
      const { username, password }: LoginRequest = ctx.request.body;

      // 1. 查找用户（支持用户名或邮箱登录）
      const user = await User.findOne({
        where: { 
          [Op.or]: [{ username }, { email: username }] 
        },
        include: [{ model: Role, as: 'roleList' }]
      });

      // 2. 验证用户和密码
      if (!user || !(await user.validatePassword(password))) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: '用户名或密码错误'
        } as LoginResponse;
        return;
      }

      // 3. 检查用户状态
      if (user.status !== 'active') {
        ctx.status = 403;
        ctx.body = {
          success: false,
          message: '账户未激活，请联系管理员'
        } as LoginResponse;
        return;
      }

      // 4. 更新最后登录信息
      await user.update({
        last_login_at: new Date(),
        last_login_ip: ctx.ip
      });

      // 5. 生成JWT令牌
      const roles = user.roleList.map(role => role.name);
      const accessToken = jwtService.generateAccessToken(user);

      // 6. 返回响应
      ctx.status = 200;
      ctx.body = {
        success: true,
        message: '登录成功',
        data: {
          user: { 
            id: user.id, 
            username: user.username, 
            email: user.email,
            roles 
          },
          token: accessToken
        }
      } as LoginResponse;

    } catch (error: any) {
      console.error('Login error:', error);
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: '登录失败，请稍后重试'
      } as LoginResponse;
    }
  }

  // 登出功能
  async logout(ctx: Context): Promise<void> {
    try {
      // 在实际应用中，可以将token加入黑名单
      // 这里简化处理，客户端删除token即可
      ctx.status = 200;
      ctx.body = {
        success: true,
        message: '登出成功'
      };
    } catch (error: any) {
      console.error('Logout error:', error);
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: '登出失败'
      };
    }
  }
}

export default new LoginController();
```

## 3. 认证中间件

### 3.1 JWT认证中间件

#### 3.1.1 中间件类型定义
```typescript
import { Context, Next } from 'koa';

// 扩展Context接口，添加用户信息
declare module 'koa' {
  interface Context {
    user?: JWTPayload;
  }
}

// 认证中间件响应类型
interface AuthMiddlewareResponse {
  success: false;
  message: string;
}
```

#### 3.1.2 JWT认证中间件实现
```typescript
import { Context, Next } from 'koa';
import User from '../models/user.model';
import jwtService from '../services/jwt.service';
import { JWTPayload } from '../types/auth.types';

class AuthMiddleware {
  /**
   * JWT认证中间件
   * 验证请求头中的Bearer token，并将用户信息添加到context中
   */
  static async authenticate(ctx: Context, next: Next): Promise<void> {
    try {
      // 1. 获取Authorization头
      const authHeader = ctx.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: '访问令牌缺失，请提供有效的Bearer token'
        } as AuthMiddlewareResponse;
        return;
      }

      // 2. 提取token
      const token = authHeader.substring(7);
      
      // 3. 验证token
      const decoded = jwtService.verifyAccessToken(token);

      // 4. 验证用户是否仍然有效
      const user = await User.findByPk(decoded.userId);
      if (!user || user.status !== 'active') {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: '用户不存在或已被禁用'
        } as AuthMiddlewareResponse;
        return;
      }

      // 5. 将用户信息添加到context
      ctx.user = {
        ...decoded,
        roles: decoded.roles || []
      };

      // 6. 继续执行下一个中间件
      await next();

    } catch (error: any) {
      console.error('Authentication error:', error);
      
      let message = '认证失败';
      if (error.message === 'Access token has expired') {
        message = '访问令牌已过期，请重新登录';
      } else if (error.message === 'Invalid access token') {
        message = '无效的访问令牌';
      }

      ctx.status = 401;
      ctx.body = {
        success: false,
        message
      } as AuthMiddlewareResponse;
    }
  }

  /**
   * 可选认证中间件
   * 如果提供了token则验证，否则继续执行
   */
  static async optionalAuth(ctx: Context, next: Next): Promise<void> {
    const authHeader = ctx.headers.authorization;
    
    if (authHeader && authHeader.startsWith('Bearer ')) {
      // 如果有token，则进行认证
      await AuthMiddleware.authenticate(ctx, next);
    } else {
      // 如果没有token，直接继续
      await next();
    }
  }
}

export default AuthMiddleware;
```

## 4. RBAC权限控制系统

### 4.1 权限管理服务

#### 4.1.1 权限服务类型定义
```typescript
// 权限检查结果类型
interface PermissionCheckResult {
  hasPermission: boolean;
  reason?: string;
  userRoles?: string[];
}

// 用户权限信息类型
interface UserPermissionInfo {
  userId: number;
  roles: string[];
  permissions: string[];
  lastChecked: Date;
}
```

#### 4.1.2 权限管理服务实现
```typescript
import User from '../models/user.model';
import Role from '../models/role.model';
import Permission from '../models/permission.model';
import { PermissionCheckResult, UserPermissionInfo } from '../types/auth.types';

class PermissionService {
  /**
   * 检查用户是否具有特定权限
   * @param userId 用户ID
   * @param permissionName 权限名称
   * @returns 权限检查结果
   */
  async checkUserPermission(userId: number, permissionName: string): Promise<PermissionCheckResult> {
    try {
      const user = await User.findByPk(userId, {
        include: [{
          model: Role,
          as: 'roleList',
          include: [{
            model: Permission,
            as: 'permissionList',
            where: { name: permissionName },
            required: false
          }]
        }]
      });

      if (!user) {
        return {
          hasPermission: false,
          reason: '用户不存在'
        };
      }

      if (user.status !== 'active') {
        return {
          hasPermission: false,
          reason: '用户账户未激活'
        };
      }

      const hasPermission = user.roleList.some(role => 
        role.permissionList && role.permissionList.length > 0
      );

      return {
        hasPermission,
        userRoles: user.roleList.map(role => role.name),
        reason: hasPermission ? undefined : '用户角色没有此权限'
      };

    } catch (error: any) {
      console.error('Permission check error:', error);
      return {
        hasPermission: false,
        reason: '权限检查失败'
      };
    }
  }

  /**
   * 获取用户所有权限
   * @param userId 用户ID
   * @returns 用户权限列表
   */
  async getUserPermissions(userId: number): Promise<string[]> {
    try {
      const user = await User.findByPk(userId, {
        include: [{
          model: Role,
          as: 'roleList',
          include: [{
            model: Permission,
            as: 'permissionList'
          }]
        }]
      });

      if (!user) {
        return [];
      }

      const permissions = new Set<string>();
      user.roleList.forEach(role => {
        if (role.permissionList) {
          role.permissionList.forEach(permission => {
            permissions.add(permission.name);
          });
        }
      });

      return Array.from(permissions);

    } catch (error: any) {
      console.error('Get user permissions error:', error);
      return [];
    }
  }

  /**
   * 获取用户权限详细信息
   * @param userId 用户ID
   * @returns 用户权限详细信息
   */
  async getUserPermissionInfo(userId: number): Promise<UserPermissionInfo | null> {
    try {
      const user = await User.findByPk(userId, {
        include: [{
          model: Role,
          as: 'roleList',
          include: [{
            model: Permission,
            as: 'permissionList'
          }]
        }]
      });

      if (!user) {
        return null;
      }

      const permissions = await this.getUserPermissions(userId);

      return {
        userId: user.id,
        roles: user.roleList.map(role => role.name),
        permissions,
        lastChecked: new Date()
      };

    } catch (error: any) {
      console.error('Get user permission info error:', error);
      return null;
    }
  }

  /**
   * 批量检查用户权限
   * @param userId 用户ID
   * @param permissions 权限列表
   * @returns 权限检查结果映射
   */
  async checkMultiplePermissions(userId: number, permissions: string[]): Promise<Record<string, boolean>> {
    const results: Record<string, boolean> = {};
    
    // 并行检查所有权限
    const checkPromises = permissions.map(async (permission) => {
      const result = await this.checkUserPermission(userId, permission);
      return { permission, hasPermission: result.hasPermission };
    });

    const checkResults = await Promise.all(checkPromises);
    
    checkResults.forEach(({ permission, hasPermission }) => {
      results[permission] = hasPermission;
    });

    return results;
  }
}

export default new PermissionService();
```

### 4.2 权限中间件

#### 4.2.1 权限中间件类型定义
```typescript
// 权限中间件响应类型
interface PermissionMiddlewareResponse {
  success: false;
  message: string;
}

// 权限中间件工厂函数类型
type PermissionMiddlewareFactory = (permission: string) => (ctx: Context, next: Next) => Promise<void>;
type RoleMiddlewareFactory = (role: string) => (ctx: Context, next: Next) => Promise<void>;
```

#### 4.2.2 权限中间件实现
```typescript
import { Context, Next } from 'koa';
import permissionService from '../services/permission.service';
import { PermissionMiddlewareResponse } from '../types/auth.types';

class PermissionMiddleware {
  /**
   * 检查特定权限的中间件工厂
   * @param permissionName 权限名称
   * @returns 权限检查中间件
   */
  static requirePermission(permissionName: string) {
    return async (ctx: Context, next: Next): Promise<void> => {
      try {
        // 1. 检查用户是否已认证
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = {
            success: false,
            message: '请先登录'
          } as PermissionMiddlewareResponse;
          return;
        }

        // 2. 检查用户权限
        const permissionResult = await permissionService.checkUserPermission(
          ctx.user.userId,
          permissionName
        );

        if (!permissionResult.hasPermission) {
          ctx.status = 403;
          ctx.body = {
            success: false,
            message: `权限不足：${permissionResult.reason || '没有访问权限'}`
          } as PermissionMiddlewareResponse;
          return;
        }

        // 3. 权限验证通过，继续执行
        await next();

      } catch (error: any) {
        console.error('Permission middleware error:', error);
        ctx.status = 500;
        ctx.body = {
          success: false,
          message: '权限验证失败'
        } as PermissionMiddlewareResponse;
      }
    };
  }

  /**
   * 检查特定角色的中间件工厂
   * @param roleName 角色名称
   * @returns 角色检查中间件
   */
  static requireRole(roleName: string) {
    return async (ctx: Context, next: Next): Promise<void> => {
      try {
        // 1. 检查用户是否已认证
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = {
            success: false,
            message: '请先登录'
          } as PermissionMiddlewareResponse;
          return;
        }

        // 2. 检查用户角色
        const hasRole = ctx.user.roles && ctx.user.roles.includes(roleName);

        if (!hasRole) {
          ctx.status = 403;
          ctx.body = {
            success: false,
            message: `角色权限不足：需要${roleName}角色`
          } as PermissionMiddlewareResponse;
          return;
        }

        // 3. 角色验证通过，继续执行
        await next();

      } catch (error: any) {
        console.error('Role middleware error:', error);
        ctx.status = 500;
        ctx.body = {
          success: false,
          message: '角色验证失败'
        } as PermissionMiddlewareResponse;
      }
    };
  }

  /**
   * 检查多个权限中的任意一个
   * @param permissions 权限列表
   * @returns 权限检查中间件
   */
  static requireAnyPermission(permissions: string[]) {
    return async (ctx: Context, next: Next): Promise<void> => {
      try {
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = {
            success: false,
            message: '请先登录'
          } as PermissionMiddlewareResponse;
          return;
        }

        // 并行检查所有权限
        const permissionResults = await Promise.all(
          permissions.map(permission => 
            permissionService.checkUserPermission(ctx.user!.userId, permission)
          )
        );

        // 检查是否有任何一个权限通过
        const hasAnyPermission = permissionResults.some(result => result.hasPermission);

        if (!hasAnyPermission) {
          ctx.status = 403;
          ctx.body = {
            success: false,
            message: `权限不足：需要以下权限之一 [${permissions.join(', ')}]`
          } as PermissionMiddlewareResponse;
          return;
        }

        await next();

      } catch (error: any) {
        console.error('Any permission middleware error:', error);
        ctx.status = 500;
        ctx.body = {
          success: false,
          message: '权限验证失败'
        } as PermissionMiddlewareResponse;
      }
    };
  }

  /**
   * 检查多个角色中的任意一个
   * @param roles 角色列表
   * @returns 角色检查中间件
   */
  static requireAnyRole(roles: string[]) {
    return async (ctx: Context, next: Next): Promise<void> => {
      try {
        if (!ctx.user) {
          ctx.status = 401;
          ctx.body = {
            success: false,
            message: '请先登录'
          } as PermissionMiddlewareResponse;
          return;
        }

        const hasAnyRole = roles.some(role => 
          ctx.user!.roles && ctx.user!.roles.includes(role)
        );

        if (!hasAnyRole) {
          ctx.status = 403;
          ctx.body = {
            success: false,
            message: `角色权限不足：需要以下角色之一 [${roles.join(', ')}]`
          } as PermissionMiddlewareResponse;
          return;
        }

        await next();

      } catch (error: any) {
        console.error('Any role middleware error:', error);
        ctx.status = 500;
        ctx.body = {
          success: false,
          message: '角色验证失败'
        } as PermissionMiddlewareResponse;
      }
    };
  }
}

export default PermissionMiddleware;
```

## 5. 路由保护与API设计

### 5.1 认证路由

#### 5.1.1 认证路由实现
```typescript
import Router from 'koa-router';
import { Context } from 'koa';
import registerController from '../controllers/auth/register.controller';
import loginController from '../controllers/auth/login.controller';
import AuthMiddleware from '../middleware/auth.middleware';

const router = new Router({ prefix: '/api/auth' });

// 公开路由 - 无需认证
router.post('/register', registerController.register);
router.post('/login', loginController.login);

// 需要认证的路由
router.post('/logout', AuthMiddleware.authenticate, loginController.logout);

// 获取当前用户信息
router.get('/me', AuthMiddleware.authenticate, async (ctx: Context): Promise<void> => {
  ctx.body = {
    success: true,
    data: { user: ctx.user }
  };
});

// 刷新令牌
router.post('/refresh', async (ctx: Context): Promise<void> => {
  try {
    const { refreshToken } = ctx.request.body;
    
    if (!refreshToken) {
      ctx.status = 400;
      ctx.body = {
        success: false,
        message: '刷新令牌缺失'
      };
      return;
    }

    // 验证刷新令牌并生成新的访问令牌
    const decoded = jwtService.verifyRefreshToken(refreshToken);
    const user = await User.findByPk(decoded.userId);
    
    if (!user || user.status !== 'active') {
      ctx.status = 401;
      ctx.body = {
        success: false,
        message: '无效的刷新令牌'
      };
      return;
    }

    const newAccessToken = jwtService.generateAccessToken(user);
    
    ctx.body = {
      success: true,
      data: {
        token: newAccessToken
      }
    };

  } catch (error: any) {
    ctx.status = 401;
    ctx.body = {
      success: false,
      message: '刷新令牌失败'
    };
  }
});

export default router;
```

### 5.2 受保护的API路由

#### 5.2.1 用户管理路由
```typescript
import Router from 'koa-router';
import { Context } from 'koa';
import userController from '../controllers/user.controller';
import AuthMiddleware from '../middleware/auth.middleware';
import PermissionMiddleware from '../middleware/permission.middleware';

const router = new Router({ prefix: '/api/users' });

// 所有用户路由都需要认证
router.use(AuthMiddleware.authenticate);

// 获取用户列表 - 需要管理员权限
router.get('/', 
  PermissionMiddleware.requirePermission('user.list'),
  userController.list
);

// 获取单个用户 - 需要查看用户权限
router.get('/:id', 
  PermissionMiddleware.requirePermission('user.view'),
  userController.show
);

// 创建用户 - 需要创建用户权限
router.post('/', 
  PermissionMiddleware.requirePermission('user.create'),
  userController.create
);

// 更新用户 - 需要更新权限或是用户本人
router.put('/:id', 
  PermissionMiddleware.requireAnyPermission(['user.update', 'user.update.own']),
  userController.update
);

// 删除用户 - 需要删除权限
router.delete('/:id', 
  PermissionMiddleware.requirePermission('user.delete'),
  userController.delete
);

// 批量操作用户 - 需要管理员权限
router.post('/batch', 
  PermissionMiddleware.requireRole('admin'),
  userController.batchOperation
);

export default router;
```

#### 5.2.2 商品管理路由
```typescript
import Router from 'koa-router';
import productController from '../controllers/product.controller';
import AuthMiddleware from '../middleware/auth.middleware';
import PermissionMiddleware from '../middleware/permission.middleware';

const router = new Router({ prefix: '/api/products' });

// 公开路由 - 商品列表和详情
router.get('/', productController.list);
router.get('/:id', productController.show);
router.get('/search', productController.search);

// 需要认证的路由
router.use(AuthMiddleware.authenticate);

// 创建商品 - 需要商品创建权限
router.post('/', 
  PermissionMiddleware.requirePermission('product.create'),
  productController.create
);

// 更新商品 - 需要商品更新权限
router.put('/:id', 
  PermissionMiddleware.requirePermission('product.update'),
  productController.update
);

// 删除商品 - 需要商品删除权限
router.delete('/:id', 
  PermissionMiddleware.requirePermission('product.delete'),
  productController.delete
);

// 商品分类管理 - 需要管理员权限
router.get('/categories', 
  PermissionMiddleware.requireRole('admin'),
  productController.getCategories
);

export default router;
```

#### 5.2.3 订单管理路由
```typescript
import Router from 'koa-router';
import orderController from '../controllers/order.controller';
import AuthMiddleware from '../middleware/auth.middleware';
import PermissionMiddleware from '../middleware/permission.middleware';

const router = new Router({ prefix: '/api/orders' });

// 所有订单路由都需要认证
router.use(AuthMiddleware.authenticate);

// 获取用户订单列表
router.get('/', orderController.getUserOrders);

// 创建订单
router.post('/', orderController.create);

// 获取订单详情 - 需要是订单所有者或管理员
router.get('/:id', 
  PermissionMiddleware.requireAnyPermission(['order.view.own', 'order.view.all']),
  orderController.show
);

// 更新订单状态 - 需要管理员权限
router.patch('/:id/status', 
  PermissionMiddleware.requireRole('admin'),
  orderController.updateStatus
);

// 取消订单 - 需要是订单所有者
router.patch('/:id/cancel', 
  PermissionMiddleware.requirePermission('order.cancel.own'),
  orderController.cancel
);

export default router;
```

## 6. 安全最佳实践

### 6.1 密码安全

#### 6.1.1 密码加密服务
```typescript
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

interface PasswordHashResult {
  hash: string;
  salt: string;
}

class PasswordService {
  private static readonly SALT_ROUNDS = 12;
  private static readonly MIN_PASSWORD_LENGTH = 8;

  /**
   * 加密密码
   * @param password 明文密码
   * @returns 加密后的密码和盐值
   */
  static async hashPassword(password: string): Promise<PasswordHashResult> {
    if (password.length < this.MIN_PASSWORD_LENGTH) {
      throw new Error(`密码长度不能少于${this.MIN_PASSWORD_LENGTH}位`);
    }

    const salt = await bcrypt.genSalt(this.SALT_ROUNDS);
    const hash = await bcrypt.hash(password, salt);
    
    return { hash, salt };
  }

  /**
   * 验证密码
   * @param password 明文密码
   * @param hash 加密后的密码
   * @returns 是否匹配
   */
  static async comparePassword(password: string, hash: string): Promise<boolean> {
    return await bcrypt.compare(password, hash);
  }

  /**
   * 生成随机密码
   * @param length 密码长度
   * @returns 随机密码
   */
  static generateRandomPassword(length: number = 12): string {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    
    return password;
  }

  /**
   * 验证密码强度
   * @param password 密码
   * @returns 密码强度信息
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean;
    score: number;
    feedback: string[];
  } {
    const feedback: string[] = [];
    let score = 0;

    if (password.length < 8) {
      feedback.push('密码长度至少8位');
    } else {
      score += 1;
    }

    if (!/[a-z]/.test(password)) {
      feedback.push('需要包含小写字母');
    } else {
      score += 1;
    }

    if (!/[A-Z]/.test(password)) {
      feedback.push('需要包含大写字母');
    } else {
      score += 1;
    }

    if (!/\d/.test(password)) {
      feedback.push('需要包含数字');
    } else {
      score += 1;
    }

    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      feedback.push('建议包含特殊字符');
    } else {
      score += 1;
    }

    return {
      isValid: score >= 4,
      score,
      feedback
    };
  }
}

export default PasswordService;
```

### 6.2 防止暴力破解

#### 6.2.1 限流中间件
```typescript
import { Context, Next } from 'koa';
import Redis from 'ioredis';
import config from '../config';

interface RateLimitConfig {
  maxAttempts: number;
  windowMs: number;
  keyGenerator?: (ctx: Context) => string;
}

class RateLimitMiddleware {
  private static redis: Redis;

  static {
    this.redis = new Redis({
      host: config.redis.host,
      port: config.redis.port,
      password: config.redis.password,
      db: config.redis.db
    });
  }

  /**
   * 登录限流中间件
   * @param maxAttempts 最大尝试次数
   * @param windowMs 时间窗口（毫秒）
   * @returns 限流中间件
   */
  static loginRateLimit(maxAttempts: number = 5, windowMs: number = 15 * 60 * 1000) {
    return async (ctx: Context, next: Next): Promise<void> => {
      const identifier = ctx.ip || 'unknown';
      const key = `login_attempts:${identifier}`;
      
      try {
        const attempts = await this.redis.get(key);
        const attemptCount = attempts ? parseInt(attempts) : 0;
        
        if (attemptCount >= maxAttempts) {
          ctx.status = 429;
          ctx.body = {
            success: false,
            message: '登录尝试次数过多，请稍后再试',
            retryAfter: Math.ceil(windowMs / 1000)
          };
          return;
        }
        
        // 增加尝试次数
        await this.redis.incr(key);
        if (attemptCount === 0) {
          await this.redis.expire(key, Math.ceil(windowMs / 1000));
        }
        
        await next();
        
      } catch (error: any) {
        console.error('Rate limit error:', error);
        // 如果Redis出错，允许请求通过
        await next();
      }
    };
  }

  /**
   * 通用限流中间件
   * @param config 限流配置
   * @returns 限流中间件
   */
  static rateLimit(config: RateLimitConfig) {
    return async (ctx: Context, next: Next): Promise<void> => {
      const identifier = config.keyGenerator ? config.keyGenerator(ctx) : ctx.ip;
      const key = `rate_limit:${identifier}`;
      
      try {
        const current = await this.redis.incr(key);
        
        if (current === 1) {
          await this.redis.expire(key, Math.ceil(config.windowMs / 1000));
        }
        
        if (current > config.maxAttempts) {
          ctx.status = 429;
          ctx.body = {
            success: false,
            message: '请求过于频繁，请稍后再试',
            retryAfter: Math.ceil(config.windowMs / 1000)
          };
          return;
        }
        
        await next();
        
      } catch (error: any) {
        console.error('Rate limit error:', error);
        await next();
      }
    };
  }

  /**
   * 重置限流计数器
   * @param identifier 标识符
   */
  static async resetRateLimit(identifier: string): Promise<void> {
    try {
      await this.redis.del(`login_attempts:${identifier}`);
      await this.redis.del(`rate_limit:${identifier}`);
    } catch (error: any) {
      console.error('Reset rate limit error:', error);
    }
  }
}

export default RateLimitMiddleware;
```

### 6.3 JWT安全配置

#### 6.3.1 安全JWT服务
```typescript
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import config from '../config';

interface TokenPair {
  accessToken: string;
  refreshToken: string;
}

interface RefreshTokenPayload {
  userId: number;
  tokenId: string;
  type: 'refresh';
  iat?: number;
  exp?: number;
  iss?: string;
}

class SecureJWTService {
  private readonly accessTokenSecret: string;
  private readonly refreshTokenSecret: string;
  private readonly accessTokenExpiry: string;
  private readonly refreshTokenExpiry: string;
  private readonly issuer: string;

  constructor() {
    this.accessTokenSecret = config.jwt.secret;
    this.refreshTokenSecret = config.jwt.refreshSecret;
    this.accessTokenExpiry = '15m'; // 访问令牌15分钟过期
    this.refreshTokenExpiry = '7d'; // 刷新令牌7天过期
    this.issuer = 'ecommerce-api';
  }

  /**
   * 生成访问令牌和刷新令牌对
   * @param user 用户信息
   * @returns 令牌对
   */
  generateTokens(user: User): TokenPair {
    const tokenId = this.generateRandomId();
    
    const accessTokenPayload: JWTPayload = {
      userId: user.id,
      username: user.username,
      email: user.email,
      roles: user.roles.map(role => role.name)
    };

    const refreshTokenPayload: RefreshTokenPayload = {
      userId: user.id,
      tokenId,
      type: 'refresh'
    };

    const accessToken = jwt.sign(accessTokenPayload, this.accessTokenSecret, {
      expiresIn: this.accessTokenExpiry,
      issuer: this.issuer,
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(refreshTokenPayload, this.refreshTokenSecret, {
      expiresIn: this.refreshTokenExpiry,
      issuer: this.issuer,
      algorithm: 'HS256'
    });

    return { accessToken, refreshToken };
  }

  /**
   * 验证访问令牌
   * @param token 访问令牌
   * @returns 解码后的载荷
   */
  verifyAccessToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.accessTokenSecret, {
        issuer: this.issuer,
        algorithms: ['HS256']
      }) as JWTPayload;
    } catch (error: any) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Access token has expired');
      } else if (error.name === 'JsonWebTokenError') {
        throw new Error('Invalid access token');
      }
      throw error;
    }
  }

  /**
   * 验证刷新令牌
   * @param token 刷新令牌
   * @returns 解码后的载荷
   */
  verifyRefreshToken(token: string): RefreshTokenPayload {
    try {
      const payload = jwt.verify(token, this.refreshTokenSecret, {
        issuer: this.issuer,
        algorithms: ['HS256']
      }) as RefreshTokenPayload;

      if (payload.type !== 'refresh') {
        throw new Error('Invalid token type');
      }

      return payload;
    } catch (error: any) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Refresh token has expired');
      } else if (error.name === 'JsonWebTokenError') {
        throw new Error('Invalid refresh token');
      }
      throw error;
    }
  }

  /**
   * 生成随机ID
   * @returns 随机ID
   */
  private generateRandomId(): string {
    return crypto.randomBytes(16).toString('hex');
  }

  /**
   * 从令牌中提取用户ID（不验证签名）
   * @param token 令牌
   * @returns 用户ID
   */
  extractUserIdFromToken(token: string): number | null {
    try {
      const decoded = jwt.decode(token) as any;
      return decoded?.userId || null;
    } catch (error) {
      return null;
    }
  }
}

export default new SecureJWTService();
```

### 6.4 安全头配置

#### 6.4.1 安全中间件
```typescript
import { Context, Next } from 'koa';

class SecurityMiddleware {
  /**
   * 设置安全响应头
   */
  static securityHeaders = async (ctx: Context, next: Next): Promise<void> => {
    // 防止XSS攻击
    ctx.set('X-Content-Type-Options', 'nosniff');
    ctx.set('X-Frame-Options', 'DENY');
    ctx.set('X-XSS-Protection', '1; mode=block');
    
    // 内容安全策略
    ctx.set('Content-Security-Policy', 
      "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline'; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "font-src 'self' data:; " +
      "connect-src 'self';"
    );
    
    // 严格传输安全（仅HTTPS）
    if (ctx.secure) {
      ctx.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
    }
    
    // 引用者策略
    ctx.set('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    await next();
  };

  /**
   * 移除敏感信息
   */
  static sanitizeResponse = async (ctx: Context, next: Next): Promise<void> => {
    await next();
    
    // 移除敏感响应头
    ctx.remove('X-Powered-By');
    ctx.remove('Server');
    
    // 清理响应体中的敏感信息
    if (ctx.body && typeof ctx.body === 'object') {
      this.removeSensitiveData(ctx.body);
    }
  };

  /**
   * 移除对象中的敏感数据
   */
  private static removeSensitiveData(obj: any): void {
    if (typeof obj !== 'object' || obj === null) return;
    
    const sensitiveKeys = ['password', 'password_hash', 'salt', 'token', 'secret'];
    
    for (const key in obj) {
      if (sensitiveKeys.includes(key.toLowerCase())) {
        delete obj[key];
      } else if (typeof obj[key] === 'object') {
        this.removeSensitiveData(obj[key]);
      }
    }
  }
}

export default SecurityMiddleware;
```

## 7. 总结

本文档详细介绍了基于TypeScript的企业级电商系统的用户认证与权限管理实现。通过JWT令牌认证、RBAC权限控制、安全最佳实践等技术，构建了一个类型安全、完整、安全的用户管理系统。

### 7.1 TypeScript在认证系统中的优势

#### 7.1.1 类型安全保障
- **编译时错误检测**：在开发阶段就能发现类型错误，避免运行时问题
- **接口约束**：通过接口定义确保数据结构的一致性
- **智能提示**：IDE提供更好的代码补全和错误提示

#### 7.1.2 代码可维护性
- **重构安全**：类型系统确保重构过程中不会破坏现有功能
- **文档化**：类型定义本身就是最好的文档
- **团队协作**：统一的类型定义提高团队开发效率

#### 7.1.3 运行时稳定性
- **数据验证**：结合Joi等验证库，提供双重数据验证
- **错误处理**：类型化的错误处理机制
- **API一致性**：确保API请求和响应的数据结构一致

### 7.2 关键要点

1. **JWT认证机制**：无状态、可扩展的认证方案，支持访问令牌和刷新令牌
2. **RBAC权限模型**：灵活的角色权限管理，支持细粒度权限控制
3. **多层次安全防护**：密码安全、限流防护、JWT安全配置、安全头设置
4. **完整的认证流程**：注册、登录、令牌刷新、权限验证
5. **TypeScript类型系统**：完整的类型定义，确保类型安全

### 7.3 最佳实践总结

#### 7.3.1 类型定义策略
```typescript
// 1. 使用接口定义数据结构
interface User {
  id: number;
  username: string;
  email: string;
  status: 'active' | 'inactive' | 'banned';
  roles: Role[];
}

// 2. 使用联合类型定义状态
type UserStatus = 'active' | 'inactive' | 'banned';
type Permission = 'user.create' | 'user.read' | 'user.update' | 'user.delete';

// 3. 使用泛型提高代码复用性
interface ApiResponse<T> {
  success: boolean;
  message: string;
  data?: T;
}
```

#### 7.3.2 错误处理模式
```typescript
// 1. 类型化的错误处理
try {
  const result = await someAsyncOperation();
  return { success: true, data: result };
} catch (error: any) {
  return { success: false, error: error.message };
}

// 2. 自定义错误类型
class AuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthenticationError';
  }
}
```

#### 7.3.3 中间件设计模式
```typescript
// 1. 工厂函数模式
static requirePermission(permission: string) {
  return async (ctx: Context, next: Next): Promise<void> => {
    // 权限检查逻辑
  };
}

// 2. 组合模式
router.use(
  AuthMiddleware.authenticate,
  PermissionMiddleware.requirePermission('user.read'),
  userController.show
);
```

### 7.4 性能优化建议

1. **缓存策略**：使用Redis缓存用户权限信息，减少数据库查询
2. **批量操作**：支持批量权限检查，减少数据库往返次数
3. **连接池**：合理配置数据库连接池，提高并发性能
4. **限流机制**：实现多层次的限流策略，保护系统稳定性

### 7.5 安全考虑

1. **密码安全**：使用bcrypt加密，支持密码强度验证
2. **令牌安全**：短生命周期访问令牌，长生命周期刷新令牌
3. **限流防护**：防止暴力破解和DDoS攻击
4. **安全头**：设置完整的安全响应头
5. **数据脱敏**：自动移除响应中的敏感信息

### 7.6 下一步学习

- **商品管理模块**：实现商品CRUD、分类管理、库存管理
- **订单处理系统**：订单创建、状态管理、支付集成
- **支付集成方案**：多种支付方式、支付安全、回调处理
- **消息队列系统**：异步处理、事件驱动架构
- **监控与日志**：系统监控、日志收集、性能分析

继续阅读后续文档，深入学习电商系统的核心业务功能实现！每个模块都将采用TypeScript实现，确保整个系统的类型安全和代码质量。