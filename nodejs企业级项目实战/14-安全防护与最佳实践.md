# 14-安全防护与最佳实践

## 1. 安全防护概述

### 1.1 安全的重要性

在企业级应用开发中，安全防护是保障用户数据、业务资产和系统稳定性的关键环节。完善的安全防护体系能够：

1. **保护用户隐私**：防止用户敏感信息泄露
2. **防范恶意攻击**：抵御各种网络攻击和入侵行为
3. **确保业务连续性**：避免因安全事件导致的业务中断
4. **合规性要求**：满足相关法律法规和行业标准

### 1.2 安全威胁类型

#### 1.2.1 OWASP Top 10威胁

OWASP（开放式Web应用程序安全项目）定义了Web应用面临的十大安全风险：

```mermaid
graph TD
    A[OWASP Top 10] --> B[注入攻击]
    A --> C[失效的身份认证]
    A --> D[敏感数据泄露]
    A --> E[XML外部实体(XXE)]
    A --> F[失效的访问控制]
    A --> G[安全配置错误]
    A --> H[跨站脚本(XSS)]
    A --> I[不安全的反序列化]
    A --> J[使用含有已知漏洞的组件]
    A --> K[不足的日志记录和监控]
    
    style B fill:#F44336,stroke:#D32F2F
    style C fill:#F44336,stroke:#D32F2F
    style D fill:#F44336,stroke:#D32F2F
    style E fill:#FF9800,stroke:#F57C00
    style F fill:#F44336,stroke:#D32F2F
    style G fill:#FF9800,stroke:#F57C00
    style H fill:#F44336,stroke:#D32F2F
    style I fill:#FF9800,stroke:#F57C00
    style J fill:#FF9800,stroke:#F57C00
    style K fill:#FF9800,stroke:#F57C00
```

#### 1.2.2 常见攻击类型

```javascript
// 常见安全攻击示例
const securityAttacks = {
  // 1. SQL注入攻击
  sqlInjection: {
    attack: "SELECT * FROM users WHERE id = 1 OR 1=1",
    prevention: "使用参数化查询和ORM"
  },
  
  // 2. XSS跨站脚本攻击
  xss: {
    attack: "<script>alert('XSS')</script>",
    prevention: "输入验证、输出编码、CSP策略"
  },
  
  // 3. CSRF跨站请求伪造
  csrf: {
    attack: "恶意网站自动提交表单到银行网站",
    prevention: "CSRF令牌、SameSite Cookie"
  },
  
  // 4. 暴力破解攻击
  bruteForce: {
    attack: "尝试大量用户名密码组合",
    prevention: "账户锁定、验证码、限流"
  },
  
  // 5. 文件上传攻击
  fileUpload: {
    attack: "上传恶意脚本文件",
    prevention: "文件类型验证、文件名重命名、存储隔离"
  }
};
```

## 2. 身份认证与授权安全

### 2.1 JWT安全实现

#### 2.1.1 JWT令牌安全配置

```javascript
// src/config/jwt.js
const jwt = require("jsonwebtoken");
const crypto = require("crypto");

class JWTConfig {
  constructor() {
    this.secret = process.env.JWT_SECRET || this.generateSecret();
    this.expiresIn = process.env.JWT_EXPIRES_IN || "7d";
    this.algorithm = "HS256";
  }
  
  // 生成随机密钥
  generateSecret(length = 64) {
    return crypto.randomBytes(length).toString("hex");
  }
  
  // 签发访问令牌
  signAccessToken(payload) {
    const options = {
      expiresIn: process.env.JWT_ACCESS_EXPIRES_IN || "15m",
      algorithm: this.algorithm
    };
    
    return jwt.sign(payload, this.secret, options);
  }
  
  // 签发刷新令牌
  signRefreshToken(payload) {
    const options = {
      expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || "7d",
      algorithm: this.algorithm
    };
    
    return jwt.sign(payload, this.secret, options);
  }
  
  // 验证令牌
  verifyToken(token) {
    try {
      return jwt.verify(token, this.secret, { algorithms: [this.algorithm] });
    } catch (error) {
      throw new Error("Invalid token");
    }
  }
  
  // 解码令牌（不验证签名）
  decodeToken(token) {
    return jwt.decode(token);
  }
}

module.exports = new JWTConfig();
```

#### 2.1.2 安全的认证中间件

```javascript
// src/middleware/auth.middleware.js
const JWTConfig = require("../config/jwt");
const { User } = require("../app/models");
const logger = require("../config/winston");

class AuthMiddleware {
  // 访问令牌验证
  async authenticate(ctx, next) {
    try {
      const token = this.extractToken(ctx);
      if (!token) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "未提供认证令牌"
        };
        return;
      }
      
      // 验证令牌
      const decoded = JWTConfig.verifyToken(token);
      
      // 检查用户是否存在
      const user = await User.findByPk(decoded.id);
      if (!user) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "用户不存在"
        };
        return;
      }
      
      // 检查用户状态
      if (user.status !== "active") {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "账户已被禁用"
        };
        return;
      }
      
      // 将用户信息添加到上下文
      ctx.user = user;
      ctx.state.userId = user.id;
      
      await next();
    } catch (error) {
      logger.warn("认证失败", { 
        error: error.message,
        ip: ctx.ip,
        userAgent: ctx.headers["user-agent"]
      });
      
      ctx.status = 401;
      ctx.body = {
        success: false,
        message: "认证失败"
      };
    }
  }
  
  // 刷新令牌
  async refresh(ctx) {
    try {
      const { refreshToken } = ctx.request.body;
      
      if (!refreshToken) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: "缺少刷新令牌"
        };
        return;
      }
      
      // 验证刷新令牌
      const decoded = JWTConfig.verifyToken(refreshToken);
      
      // 检查用户
      const user = await User.findByPk(decoded.id);
      if (!user) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "用户不存在"
        };
        return;
      }
      
      // 生成新的访问令牌
      const newAccessToken = JWTConfig.signAccessToken({
        id: user.id,
        email: user.email
      });
      
      ctx.body = {
        success: true,
        data: {
          accessToken: newAccessToken,
          tokenType: "Bearer"
        }
      };
    } catch (error) {
      logger.warn("刷新令牌失败", { error: error.message });
      
      ctx.status = 401;
      ctx.body = {
        success: false,
        message: "刷新令牌无效"
      };
    }
  }
  
  // 提取令牌
  extractToken(ctx) {
    const authHeader = ctx.headers.authorization;
    if (!authHeader) return null;
    
    const parts = authHeader.split(" ");
    if (parts.length !== 2 || parts[0] !== "Bearer") {
      return null;
    }
    
    return parts[1];
  }
}

module.exports = new AuthMiddleware();
```

### 2.2 RBAC权限控制

#### 2.2.1 权限模型设计

```javascript
// src/app/models/role.model.js
const { DataTypes } = require("sequelize");
const { sequelize } = require("../../database");

const Role = sequelize.define("Role", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  description: {
    type: DataTypes.STRING(255)
  },
  level: {
    type: DataTypes.INTEGER,
    defaultValue: 1
  }
});

// src/app/models/permission.model.js
const Permission = sequelize.define("Permission", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true
  },
  description: {
    type: DataTypes.STRING(255)
  },
  resource: {
    type: DataTypes.STRING(100),
    allowNull: false
  },
  action: {
    type: DataTypes.STRING(50),
    allowNull: false
  }
});

// src/app/models/role-permission.model.js
const RolePermission = sequelize.define("RolePermission", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  }
});

// 关系定义
Role.belongsToMany(Permission, {
  through: RolePermission,
  foreignKey: "roleId",
  otherKey: "permissionId"
});

Permission.belongsToMany(Role, {
  through: RolePermission,
  foreignKey: "permissionId",
  otherKey: "roleId"
});

module.exports = { Role, Permission, RolePermission };
```

#### 2.2.2 权限验证中间件

```javascript
// src/middleware/rbac.middleware.js
const { Role, Permission } = require("../app/models");

class RBACMiddleware {
  // 检查用户角色
  requireRole(roles) {
    return async (ctx, next) => {
      if (!ctx.user) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "需要认证"
        };
        return;
      }
      
      const userRoles = await ctx.user.getRoles();
      const roleNames = userRoles.map(role => role.name);
      
      const hasRole = Array.isArray(roles) 
        ? roles.some(role => roleNames.includes(role))
        : roleNames.includes(roles);
      
      if (!hasRole) {
        ctx.status = 403;
        ctx.body = {
          success: false,
          message: "权限不足"
        };
        return;
      }
      
      await next();
    };
  }
  
  // 检查用户权限
  requirePermission(permissions) {
    return async (ctx, next) => {
      if (!ctx.user) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "需要认证"
        };
        return;
      }
      
      // 获取用户所有权限
      const userPermissions = await this.getUserPermissions(ctx.user.id);
      const permissionNames = userPermissions.map(p => p.name);
      
      const hasPermission = Array.isArray(permissions)
        ? permissions.some(permission => permissionNames.includes(permission))
        : permissionNames.includes(permissions);
      
      if (!hasPermission) {
        ctx.status = 403;
        ctx.body = {
          success: false,
          message: "权限不足"
        };
        return;
      }
      
      await next();
    };
  }
  
  // 获取用户权限
  async getUserPermissions(userId) {
    const user = await User.findByPk(userId, {
      include: [{
        model: Role,
        include: [Permission]
      }]
    });
    
    if (!user) return [];
    
    // 展平权限数组
    const permissions = [];
    user.Roles.forEach(role => {
      role.Permissions.forEach(permission => {
        if (!permissions.find(p => p.id === permission.id)) {
          permissions.push(permission);
        }
      });
    });
    
    return permissions;
  }
}

module.exports = new RBACMiddleware();
```

## 3. 数据安全防护

### 3.1 敏感数据保护

#### 3.1.1 数据加密

```javascript
// src/utils/encryption.js
const crypto = require("crypto");
const bcrypt = require("bcryptjs");

class EncryptionUtil {
  // AES加密
  static encrypt(text, key) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher("aes-256-cbc", key);
    let encrypted = cipher.update(text, "utf8", "hex");
    encrypted += cipher.final("hex");
    return iv.toString("hex") + ":" + encrypted;
  }
  
  // AES解密
  static decrypt(encryptedText, key) {
    const parts = encryptedText.split(":");
    const iv = Buffer.from(parts[0], "hex");
    const encrypted = parts[1];
    const decipher = crypto.createDecipher("aes-256-cbc", key);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  }
  
  // 哈希加密
  static async hashPassword(password) {
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }
  
  // 密码验证
  static async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }
  
  // 生成随机令牌
  static generateToken(length = 32) {
    return crypto.randomBytes(length).toString("hex");
  }
  
  // 生成盐值
  static generateSalt(length = 16) {
    return crypto.randomBytes(length).toString("hex");
  }
}

module.exports = EncryptionUtil;
```

#### 3.1.2 敏感数据处理

```javascript
// src/app/models/user.model.js
const { DataTypes } = require("sequelize");
const { sequelize } = require("../../database");
const EncryptionUtil = require("../../utils/encryption");

const User = sequelize.define("User", {
  id: {
    type: DataTypes.BIGINT,
    primaryKey: true,
    autoIncrement: true
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  password: {
    type: DataTypes.STRING(255),
    allowNull: false,
    set(value) {
      // 密码加密存储
      if (value) {
        this.setDataValue("password", EncryptionUtil.hashPassword(value));
      }
    }
  },
  phone: {
    type: DataTypes.STRING(20),
    validate: {
      is: /^[1][3-9]\d{9}$/
    },
    set(value) {
      // 手机号加密存储
      if (value) {
        const key = process.env.ENCRYPTION_KEY;
        this.setDataValue("phone", EncryptionUtil.encrypt(value, key));
      }
    },
    get() {
      // 解密手机号
      const encryptedPhone = this.getDataValue("phone");
      if (encryptedPhone) {
        const key = process.env.ENCRYPTION_KEY;
        return EncryptionUtil.decrypt(encryptedPhone, key);
      }
      return null;
    }
  },
  idCard: {
    type: DataTypes.STRING(50),
    set(value) {
      // 身份证号加密存储
      if (value) {
        const key = process.env.ENCRYPTION_KEY;
        this.setDataValue("idCard", EncryptionUtil.encrypt(value, key));
      }
    },
    get() {
      // 解密身份证号
      const encryptedIdCard = this.getDataValue("idCard");
      if (encryptedIdCard) {
        const key = process.env.ENCRYPTION_KEY;
        return EncryptionUtil.decrypt(encryptedIdCard, key);
      }
      return null;
    }
  }
}, {
  // 隐藏敏感字段
  defaultScope: {
    attributes: {
      exclude: ["password", "phone", "idCard"]
    }
  },
  // 包含敏感字段的作用域
  scopes: {
    withSensitive: {
      attributes: {}
    }
  }
});

module.exports = User;
```

### 3.2 数据库安全

#### 3.2.1 连接安全

```javascript
// src/config/database.js
const { Sequelize } = require("sequelize");
const config = require("./index");

const sequelize = new Sequelize(config.database.database, config.database.username, config.database.password, {
  host: config.database.host,
  port: config.database.port,
  dialect: config.database.dialect,
  timezone: config.database.timezone,
  
  // 安全配置
  dialectOptions: {
    ssl: {
      require: true,
      rejectUnauthorized: false // 生产环境应设置为true
    }
  },
  
  // 连接池配置
  pool: {
    max: config.database.pool.max || 20,
    min: config.database.pool.min || 5,
    acquire: config.database.pool.acquire || 60000,
    idle: config.database.pool.idle || 10000
  },
  
  // 安全选项
  logging: config.app.isDevelopment ? console.log : false,
  benchmark: false,
  
  // 防止SQL注入
  quoteIdentifiers: true,
  
  // 时区设置
  timezone: "+08:00"
});

// 测试数据库连接
async function testConnection() {
  try {
    await sequelize.authenticate();
    console.log("数据库连接成功");
  } catch (error) {
    console.error("数据库连接失败:", error);
  }
}

module.exports = { sequelize, testConnection };
```

#### 3.2.2 查询安全

```javascript
// src/utils/db-security.js
const validator = require("validator");

class DatabaseSecurity {
  // 防止SQL注入
  static sanitizeInput(input) {
    if (typeof input === "string") {
      // 移除潜在的SQL注入字符
      return input.replace(/['";\\-]/g, "");
    }
    return input;
  }
  
  // 验证ID参数
  static validateId(id) {
    if (!id || !validator.isInt(id.toString())) {
      throw new Error("无效的ID参数");
    }
    return parseInt(id);
  }
  
  // 验证邮箱
  static validateEmail(email) {
    if (!email || !validator.isEmail(email)) {
      throw new Error("无效的邮箱格式");
    }
    return email.toLowerCase();
  }
  
  // 验证手机号
  static validatePhone(phone) {
    if (!phone || !validator.matches(phone, /^[1][3-9]\d{9}$/)) {
      throw new Error("无效的手机号格式");
    }
    return phone;
  }
  
  // 构建安全的WHERE条件
  static buildSafeWhere(conditions) {
    const safeConditions = {};
    
    for (const [key, value] of Object.entries(conditions)) {
      // 过滤掉危险字符
      if (typeof value === "string") {
        safeConditions[key] = this.sanitizeInput(value);
      } else {
        safeConditions[key] = value;
      }
    }
    
    return safeConditions;
  }
}

module.exports = DatabaseSecurity;
```

## 4. 网络安全防护

### 4.1 请求安全防护

#### 4.1.1 安全中间件

```javascript
// src/middleware/security.middleware.js
const rateLimit = require("koa-ratelimit");
const helmet = require("koa-helmet");
const cors = require("@koa/cors");
const validator = require("validator");

class SecurityMiddleware {
  // 应用安全头
  async applySecurityHeaders(ctx, next) {
    // 应用Helmet安全头
    await helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'"]
        }
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      },
      noSniff: true,
      ieNoOpen: true,
      xssFilter: true,
      frameguard: {
        action: "deny"
      }
    })(ctx, next);
  }
  
  // CORS配置
  configureCORS() {
    return cors({
      origin: (ctx) => {
        const whitelist = [
          "https://yourdomain.com",
          "https://www.yourdomain.com"
        ];
        
        const origin = ctx.headers.origin;
        if (whitelist.includes(origin)) {
          return origin;
        }
        
        // 开发环境允许所有源
        if (process.env.NODE_ENV === "development") {
          return origin;
        }
        
        return false;
      },
      credentials: true,
      allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      allowHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
      exposeHeaders: ["X-Total-Count"]
    });
  }
  
  // 请求验证
  validateRequest() {
    return async (ctx, next) => {
      // 验证请求头
      this.validateHeaders(ctx.headers);
      
      // 验证请求体大小
      if (ctx.request.length > 10 * 1024 * 1024) { // 10MB
        ctx.status = 413;
        ctx.body = {
          success: false,
          message: "请求体过大"
        };
        return;
      }
      
      // 验证用户代理
      if (!ctx.headers["user-agent"]) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: "缺少User-Agent头"
        };
        return;
      }
      
      await next();
    };
  }
  
  // 验证请求头
  validateHeaders(headers) {
    // 检查危险头
    const dangerousHeaders = [
      "x-forwarded-for",
      "x-real-ip",
      "x-client-ip"
    ];
    
    for (const header of dangerousHeaders) {
      if (headers[header] && !this.isValidIP(headers[header])) {
        throw new Error(`无效的请求头: ${header}`);
      }
    }
  }
  
  // 验证IP地址
  isValidIP(ip) {
    return validator.isIP(ip);
  }
  
  // 限流配置
  configureRateLimit() {
    return rateLimit({
      driver: "memory",
      db: new Map(),
      duration: 60000, // 1分钟
      max: 100, // 最多100次请求
      errorMessage: "请求过于频繁，请稍后再试",
      id: (ctx) => ctx.ip,
      headers: {
        remaining: "Rate-Limit-Remaining",
        reset: "Rate-Limit-Reset",
        total: "Rate-Limit-Total"
      },
      whitelist: (ctx) => {
        // 白名单IP不限制
        const whitelist = ["127.0.0.1", "::1"];
        return whitelist.includes(ctx.ip);
      },
      blacklist: (ctx) => {
        // 黑名单IP直接拒绝
        const blacklist = [];
        return blacklist.includes(ctx.ip);
      }
    });
  }
}

module.exports = new SecurityMiddleware();
```

#### 4.1.2 输入验证与清理

```javascript
// src/middleware/validation.middleware.js
const Joi = require("joi");
const validator = require("validator");
const xss = require("xss");

class ValidationMiddleware {
  // 验证并清理输入
  validateAndSanitize(schema) {
    return async (ctx, next) => {
      try {
        // 验证请求参数
        if (schema.params && ctx.params) {
          await schema.params.validateAsync(ctx.params);
        }
        
        // 验证查询参数
        if (schema.query && ctx.query) {
          await this.sanitizeAndValidate(ctx.query, schema.query);
        }
        
        // 验证请求体
        if (schema.body && ctx.request.body) {
          await this.sanitizeAndValidate(ctx.request.body, schema.body);
        }
        
        await next();
      } catch (error) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: "参数验证失败",
          errors: error.details.map(detail => ({
            field: detail.path.join("."),
            message: detail.message
          }))
        };
      }
    };
  }
  
  // 清理和验证数据
  async sanitizeAndValidate(data, schema) {
    // 清理数据
    const sanitizedData = this.sanitizeData(data);
    
    // 验证数据
    await schema.validateAsync(sanitizedData);
    
    return sanitizedData;
  }
  
  // 数据清理
  sanitizeData(data) {
    if (typeof data === "string") {
      // XSS清理
      return xss(data);
    } else if (Array.isArray(data)) {
      return data.map(item => this.sanitizeData(item));
    } else if (typeof data === "object" && data !== null) {
      const sanitized = {};
      for (const [key, value] of Object.entries(data)) {
        sanitized[key] = this.sanitizeData(value);
      }
      return sanitized;
    }
    return data;
  }
  
  // 创建用户验证
  createUserSchema() {
    return Joi.object({
      name: Joi.string()
        .min(2)
        .max(50)
        .required()
        .messages({
          "string.min": "姓名至少2个字符",
          "string.max": "姓名最多50个字符",
          "any.required": "姓名是必填项"
        }),
      email: Joi.string()
        .email()
        .required()
        .messages({
          "string.email": "邮箱格式不正确",
          "any.required": "邮箱是必填项"
        }),
      password: Joi.string()
        .min(8)
        .max(50)
        .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/)
        .required()
        .messages({
          "string.min": "密码至少8个字符",
          "string.max": "密码最多50个字符",
          "string.pattern.base": "密码必须包含大小写字母和数字",
          "any.required": "密码是必填项"
        }),
      phone: Joi.string()
        .pattern(/^[1][3-9]\d{9}$/)
        .messages({
          "string.pattern.base": "手机号格式不正确"
        })
    });
  }
}

module.exports = new ValidationMiddleware();
```

### 4.2 API安全防护

#### 4.2.1 API密钥管理

```javascript
// src/app/models/api-key.model.js
const { DataTypes } = require("sequelize");
const { sequelize } = require("../../database");
const crypto = require("crypto");

const ApiKey = sequelize.define("ApiKey", {
  id: {
    type: DataTypes.BIGINT,
    primaryKey: true,
    autoIncrement: true
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: false
  },
  key: {
    type: DataTypes.STRING(64),
    allowNull: false,
    unique: true
  },
  secret: {
    type: DataTypes.STRING(128),
    allowNull: false
  },
  permissions: {
    type: DataTypes.JSON,
    allowNull: false,
    defaultValue: []
  },
  status: {
    type: DataTypes.ENUM("active", "inactive", "revoked"),
    defaultValue: "active"
  },
  expiresAt: {
    type: DataTypes.DATE
  },
  lastUsedAt: {
    type: DataTypes.DATE
  }
}, {
  indexes: [
    {
      fields: ["key"]
    },
    {
      fields: ["status"]
    }
  ]
});

// 生成API密钥
ApiKey.generateKey = function() {
  return crypto.randomBytes(32).toString("hex");
};

// 生成API密钥密文
ApiKey.generateSecret = function() {
  return crypto.randomBytes(64).toString("hex");
};

module.exports = ApiKey;
```

#### 4.2.2 API密钥验证中间件

```javascript
// src/middleware/api-key.middleware.js
const ApiKey = require("../app/models/api-key.model");
const crypto = require("crypto");

class ApiKeyMiddleware {
  async authenticate(ctx, next) {
    try {
      // 从请求头获取API密钥
      const apiKey = ctx.headers["x-api-key"];
      const apiSecret = ctx.headers["x-api-secret"];
      
      if (!apiKey || !apiSecret) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "缺少API密钥或密钥密文"
        };
        return;
      }
      
      // 查找API密钥
      const keyRecord = await ApiKey.findOne({
        where: {
          key: apiKey,
          status: "active"
        }
      });
      
      if (!keyRecord) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "无效的API密钥"
        };
        return;
      }
      
      // 验证密钥密文
      if (keyRecord.secret !== apiSecret) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "API密钥密文不正确"
        };
        return;
      }
      
      // 检查过期时间
      if (keyRecord.expiresAt && keyRecord.expiresAt < new Date()) {
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: "API密钥已过期"
        };
        return;
      }
      
      // 检查权限
      if (!this.checkPermission(keyRecord.permissions, ctx.path, ctx.method)) {
        ctx.status = 403;
        ctx.body = {
          success: false,
          message: "API密钥权限不足"
        };
        return;
      }
      
      // 更新最后使用时间
      await keyRecord.update({
        lastUsedAt: new Date()
      });
      
      // 将API密钥信息添加到上下文
      ctx.state.apiKey = keyRecord;
      
      await next();
    } catch (error) {
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: "API密钥验证失败"
      };
    }
  }
  
  // 检查权限
  checkPermission(permissions, path, method) {
    // 如果没有设置权限，则允许所有访问
    if (!permissions || permissions.length === 0) {
      return true;
    }
    
    // 检查是否有匹配的权限
    return permissions.some(permission => {
      const [permPath, permMethod] = permission.split(":");
      return (
        (permPath === "*" || path.startsWith(permPath)) &&
        (permMethod === "*" || permMethod === method)
      );
    });
  }
}

module.exports = new ApiKeyMiddleware();
```

## 5. 安全审计与监控

### 5.1 安全日志记录

#### 5.1.1 安全事件日志

```javascript
// src/services/security-log.service.js
const logger = require("../config/winston");

class SecurityLogService {
  // 记录安全事件
  static logSecurityEvent(event, userId, details = {}) {
    const logData = {
      type: "security_event",
      event,
      userId,
      details,
      timestamp: new Date().toISOString(),
      ip: details.ip,
      userAgent: details.userAgent
    };
    
    // 根据事件严重程度记录不同级别的日志
    switch (event) {
      case "login_failed":
      case "unauthorized_access":
        logger.warn("安全警告", logData);
        break;
      case "brute_force_attempt":
      case "suspicious_activity":
        logger.error("安全威胁", logData);
        break;
      default:
        logger.info("安全事件", logData);
    }
    
    // 可以将安全日志存储到专门的安全日志数据库
    this.storeSecurityLog(logData);
  }
  
  // 存储安全日志
  static async storeSecurityLog(logData) {
    try {
      // 实现安全日志存储逻辑
      // 可以存储到专门的安全日志数据库或发送到SIEM系统
      console.log("存储安全日志:", JSON.stringify(logData));
    } catch (error) {
      logger.error("存储安全日志失败", { error: error.message });
    }
  }
  
  // 记录用户行为
  static logUserAction(userId, action, details = {}) {
    const logData = {
      type: "user_action",
      userId,
      action,
      details,
      timestamp: new Date().toISOString()
    };
    
    logger.info("用户行为日志", logData);
  }
  
  // 记录系统事件
  static logSystemEvent(event, details = {}) {
    const logData = {
      type: "system_event",
      event,
      details,
      timestamp: new Date().toISOString()
    };
    
    logger.info("系统事件日志", logData);
  }
}

module.exports = SecurityLogService;
```

#### 5.1.2 安全监控中间件

```javascript
// src/middleware/security-monitor.middleware.js
const SecurityLogService = require("../services/security-log.service");

class SecurityMonitorMiddleware {
  // 监控可疑活动
  async monitorSuspiciousActivity(ctx, next) {
    const startTime = Date.now();
    
    try {
      await next();
      
      // 检查响应时间是否异常
      const responseTime = Date.now() - startTime;
      if (responseTime > 10000) { // 超过10秒
        SecurityLogService.logSecurityEvent("slow_response", ctx.user?.id, {
          path: ctx.path,
          method: ctx.method,
          responseTime,
          ip: ctx.ip,
          userAgent: ctx.headers["user-agent"]
        });
      }
    } catch (error) {
      // 记录错误响应
      SecurityLogService.logSecurityEvent("error_response", ctx.user?.id, {
        path: ctx.path,
        method: ctx.method,
        error: error.message,
        ip: ctx.ip,
        userAgent: ctx.headers["user-agent"]
      });
      
      throw error;
    }
  }
  
  // 监控认证尝试
  async monitorAuthAttempts(ctx, next) {
    if (ctx.path === "/api/auth/login" && ctx.method === "POST") {
      const { email } = ctx.request.body;
      
      try {
        await next();
        
        // 登录成功记录
        if (ctx.status === 200) {
          SecurityLogService.logUserAction(ctx.user?.id, "login_success", {
            email,
            ip: ctx.ip,
            userAgent: ctx.headers["user-agent"]
          });
        }
      } catch (error) {
        // 登录失败记录
        SecurityLogService.logSecurityEvent("login_failed", null, {
          email,
          error: error.message,
          ip: ctx.ip,
          userAgent: ctx.headers["user-agent"]
        });
        
        throw error;
      }
    } else {
      await next();
    }
  }
  
  // 监控敏感操作
  async monitorSensitiveOperations(ctx, next) {
    const sensitivePaths = [
      "/api/users",
      "/api/admin",
      "/api/payments"
    ];
    
    const isSensitive = sensitivePaths.some(path => ctx.path.startsWith(path));
    
    if (isSensitive) {
      SecurityLogService.logSecurityEvent("sensitive_operation", ctx.user?.id, {
        path: ctx.path,
        method: ctx.method,
        ip: ctx.ip,
        userAgent: ctx.headers["user-agent"]
      });
    }
    
    await next();
  }
}

module.exports = new SecurityMonitorMiddleware();
```

### 5.2 安全扫描与测试

#### 5.2.1 安全测试脚本

```javascript
// tests/security/security.test.js
const request = require("supertest");
const app = require("../../src/app");

describe("安全测试", () => {
  describe("SQL注入防护", () => {
    it("应该拒绝恶意SQL注入尝试", async () => {
      const maliciousInput = "1' OR '1'='1";
      
      const response = await request(app)
        .get(`/api/users/${maliciousInput}`)
        .expect(400);
      
      expect(response.body.success).toBe(false);
    });
  });
  
  describe("XSS防护", () => {
    it("应该清理XSS攻击载荷", async () => {
      const xssPayload = "<script>alert('XSS')</script>";
      
      const response = await request(app)
        .post("/api/users")
        .send({
          name: xssPayload,
          email: "test@example.com"
        })
        .expect(400);
      
      expect(response.body.success).toBe(false);
    });
  });
  
  describe("认证安全", () => {
    it("应该拒绝无效的JWT令牌", async () => {
      const response = await request(app)
        .get("/api/users/profile")
        .set("Authorization", "Bearer invalid.token.here")
        .expect(401);
      
      expect(response.body.success).toBe(false);
    });
    
    it("应该拒绝过期的JWT令牌", async () => {
      // 生成一个过期的令牌进行测试
      const expiredToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwiZXhwIjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
      
      const response = await request(app)
        .get("/api/users/profile")
        .set("Authorization", `Bearer ${expiredToken}`)
        .expect(401);
      
      expect(response.body.success).toBe(false);
    });
  });
  
  describe("权限控制", () => {
    it("应该拒绝未授权的访问", async () => {
      const response = await request(app)
        .get("/api/admin/users")
        .expect(401);
      
      expect(response.body.success).toBe(false);
    });
  });
  
  describe("速率限制", () => {
    it("应该限制过多的请求", async () => {
      // 发送大量请求测试限流
      const requests = [];
      for (let i = 0; i < 150; i++) {
        requests.push(
          request(app)
            .get("/api/public")
        );
      }
      
      const responses = await Promise.all(requests);
      const rateLimitedResponses = responses.filter(
        res => res.status === 429
      );
      
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });
});
```

#### 5.2.2 安全扫描工具集成

```javascript
// scripts/security-scan.js
const { exec } = require("child_process");
const fs = require("fs");

class SecurityScanner {
  // 运行npm audit检查
  async runNpmAudit() {
    return new Promise((resolve, reject) => {
      exec("npm audit --audit-level=moderate", (error, stdout, stderr) => {
        if (error) {
          console.error("npm audit failed:", error);
          reject(error);
        } else {
          console.log("npm audit completed:", stdout);
          resolve(stdout);
        }
      });
    });
  }
  
  // 运行安全扫描
  async runSecurityScan() {
    try {
      console.log("开始安全扫描...");
      
      // 运行npm audit
      await this.runNpmAudit();
      
      // 可以集成其他安全扫描工具
      // 例如：nsp, snyk等
      
      console.log("安全扫描完成");
    } catch (error) {
      console.error("安全扫描失败:", error);
      process.exit(1);
    }
  }
}

// 如果直接运行此脚本
if (require.main === module) {
  const scanner = new SecurityScanner();
  scanner.runSecurityScan();
}

module.exports = SecurityScanner;
```

## 6. 合规性与最佳实践

### 6.1 GDPR合规

#### 6.1.1 数据保护实现

```javascript
// src/services/gdpr.service.js
const { User } = require("../app/models");
const fs = require("fs").promises;
const path = require("path");

class GDPRService {
  // 数据主体权利 - 访问权
  async getUserData(userId) {
    const user = await User.findByPk(userId, {
      attributes: { exclude: ["password"] } // 排除密码字段
    });
    
    if (!user) {
      throw new Error("用户不存在");
    }
    
    // 获取用户相关的所有数据
    const userData = {
      profile: user.toJSON(),
      orders: await this.getUserOrders(userId),
      payments: await this.getUserPayments(userId),
      logs: await this.getUserLogs(userId)
    };
    
    return userData;
  }
  
  // 数据主体权利 - 删除权
  async deleteUserData(userId) {
    const user = await User.findByPk(userId);
    
    if (!user) {
      throw new Error("用户不存在");
    }
    
    // 删除用户相关数据
    await this.deleteUserOrders(userId);
    await this.deleteUserPayments(userId);
    await this.deleteUserLogs(userId);
    
    // 匿名化用户账户而不是完全删除
    await user.update({
      email: `deleted_${userId}@example.com`,
      name: "已删除用户",
      phone: null,
      idCard: null,
      status: "deleted"
    });
    
    return { success: true, message: "用户数据已删除" };
  }
  
  // 数据主体权利 - 可移植权
  async exportUserData(userId) {
    const userData = await this.getUserData(userId);
    
    // 生成JSON格式的数据导出
    const exportData = {
      exportedAt: new Date().toISOString(),
      userId,
      data: userData
    };
    
    // 保存到文件或返回给用户
    const fileName = `user_data_${userId}_${Date.now()}.json`;
    const filePath = path.join("exports", fileName);
    
    await fs.writeFile(filePath, JSON.stringify(exportData, null, 2));
    
    return { filePath, fileName };
  }
  
  // 获取用户订单数据
  async getUserOrders(userId) {
    // 实现获取用户订单逻辑
    return [];
  }
  
  // 获取用户支付数据
  async getUserPayments(userId) {
    // 实现获取用户支付逻辑
    return [];
  }
  
  // 获取用户日志数据
  async getUserLogs(userId) {
    // 实现获取用户日志逻辑
    return [];
  }
  
  // 删除用户订单数据
  async deleteUserOrders(userId) {
    // 实现删除用户订单逻辑
  }
  
  // 删除用户支付数据
  async deleteUserPayments(userId) {
    // 实现删除用户支付逻辑
  }
  
  // 删除用户日志数据
  async deleteUserLogs(userId) {
    // 实现删除用户日志逻辑
  }
}

module.exports = new GDPRService();
```

### 6.2 安全最佳实践

#### 6.2.1 安全配置检查清单

```javascript
// src/utils/security-checklist.js
class SecurityChecklist {
  static checks = {
    // 环境配置
    environment: [
      "NODE_ENV设置为production",
      "敏感配置通过环境变量管理",
      "不在代码中硬编码密钥和密码",
      "使用.env文件且不提交到版本控制"
    ],
    
    // 认证安全
    authentication: [
      "使用强密码策略",
      "实现账户锁定机制",
      "使用安全的密码哈希算法",
      "实现多因素认证",
      "定期轮换JWT密钥"
    ],
    
    // 网络安全
    network: [
      "使用HTTPS",
      "配置适当的安全头",
      "实施速率限制",
      "配置CORS策略",
      "使用内容安全策略(CSP)"
    ],
    
    // 数据安全
    data: [
      "敏感数据加密存储",
      "数据库连接使用SSL",
      "定期备份数据",
      "实施数据访问控制",
      "清理不使用的数据"
    ],
    
    // 应用安全
    application: [
      "输入验证和清理",
      "防止SQL注入",
      "防止XSS攻击",
      "防止CSRF攻击",
      "安全的错误处理"
    ],
    
    // 依赖安全
    dependencies: [
      "定期更新依赖包",
      "运行npm audit检查",
      "移除不使用的依赖",
      "使用可信的依赖源",
      "锁定依赖版本"
    ]
  };
  
  static async runAllChecks() {
    console.log("运行安全检查清单...");
    
    for (const [category, checks] of Object.entries(this.checks)) {
      console.log(`\n${category.toUpperCase()}检查:`);
      
      for (const check of checks) {
        console.log(`  □ ${check}`);
      }
    }
    
    console.log("\n请手动验证以上检查项是否已完成。");
  }
}

module.exports = SecurityChecklist;
```

#### 6.2.2 安全更新策略

```javascript
// scripts/security-update.js
const { exec } = require("child_process");
const fs = require("fs");

class SecurityUpdater {
  // 检查依赖安全更新
  async checkDependencyUpdates() {
    return new Promise((resolve, reject) => {
      exec("npm audit", (error, stdout, stderr) => {
        if (error && error.code !== 1) {
          reject(error);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
  }
  
  // 自动修复安全问题
  async fixSecurityIssues() {
    return new Promise((resolve, reject) => {
      exec("npm audit fix", (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
  }
  
  // 更新依赖到最新版本
  async updateDependencies() {
    return new Promise((resolve, reject) => {
      exec("npm update", (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
  }
  
  // 运行完整的安全更新流程
  async runSecurityUpdate() {
    try {
      console.log("开始安全更新流程...");
      
      // 1. 检查当前安全状态
      console.log("1. 检查依赖安全状态...");
      const auditResult = await this.checkDependencyUpdates();
      console.log(auditResult.stdout);
      
      // 2. 修复安全问题
      console.log("2. 修复安全问题...");
      const fixResult = await this.fixSecurityIssues();
      console.log(fixResult.stdout);
      
      // 3. 更新依赖
      console.log("3. 更新依赖...");
      const updateResult = await this.updateDependencies();
      console.log(updateResult.stdout);
      
      console.log("安全更新流程完成！");
    } catch (error) {
      console.error("安全更新失败:", error);
      process.exit(1);
    }
  }
}

// 如果直接运行此脚本
if (require.main === module) {
  const updater = new SecurityUpdater();
  updater.runSecurityUpdate();
}

module.exports = SecurityUpdater;
```

## 7. 总结

本文档详细介绍了企业级电商系统的安全防护策略与最佳实践。通过身份认证、数据安全、网络安全、安全审计等多维度的防护措施，我们能够构建出高安全性的应用系统。

### 7.1 关键要点

1. **身份认证安全**：实现JWT安全认证和RBAC权限控制
2. **数据安全防护**：敏感数据加密存储和传输安全
3. **网络安全防护**：请求验证、输入清理、速率限制
4. **安全审计监控**：安全日志记录和异常行为监控
5. **合规性保障**：GDPR合规和安全最佳实践

### 7.2 安全建议

1. **定期安全评估**：定期进行安全扫描和渗透测试
2. **安全培训**：对开发团队进行安全意识培训
3. **应急响应**：建立安全事件应急响应机制
4. **持续监控**：实施7×24小时安全监控
5. **合规审计**：定期进行合规性审计

通过实施以上安全防护措施，可以显著提升电商系统的安全性，保护用户数据和业务资产。安全是一个持续的过程，需要在系统生命周期的每个阶段都给予足够的重视。

继续深入学习安全防护技术，关注最新的安全威胁和防护手段，不断提升系统的安全防护能力！