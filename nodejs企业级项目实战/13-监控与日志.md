# 13-监控与日志

## 1. 监控系统概述

### 1.0 TypeScript在监控系统中的优势

在监控与日志系统中，TypeScript提供了强大的类型安全保障，特别是在处理复杂的监控指标和日志数据时：

#### 1.0.1 类型安全的监控指标
```typescript
// 监控指标基础接口
interface BaseMetric {
  name: string;
  value: number;
  timestamp: Date;
  tags?: Record<string, string>;
  unit?: string;
}

// CPU使用率指标接口
interface CPUUsageMetric extends BaseMetric {
  name: 'cpu_usage';
  value: number; // 百分比
  unit: 'percent';
  details: {
    user: number;
    system: number;
    idle: number;
    total: number;
  };
}

// 内存使用指标接口
interface MemoryUsageMetric extends BaseMetric {
  name: 'memory_usage';
  value: number; // 字节
  unit: 'bytes';
  details: {
    total: number;
    used: number;
    free: number;
    cached: number;
    utilization: number; // 百分比
  };
}

// 网络流量指标接口
interface NetworkTrafficMetric extends BaseMetric {
  name: 'network_traffic';
  value: number; // 字节/秒
  unit: 'bytes_per_second';
  details: {
    rxBytes: number;
    txBytes: number;
    rxPackets: number;
    txPackets: number;
  };
}
```

#### 1.0.2 应用性能监控类型
```typescript
// HTTP请求指标接口
interface HTTPRequestMetric extends BaseMetric {
  name: 'http_request';
  value: number; // 请求数
  unit: 'count';
  details: {
    total: number;
    success: number;
    error: number;
    successRate: number;
    avgResponseTime: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
  };
}

// 数据库指标接口
interface DatabaseMetric extends BaseMetric {
  name: 'database';
  value: number; // 连接数
  unit: 'count';
  details: {
    connections: number;
    maxConnections: number;
    avgQueryTime: number;
    slowQueries: number;
    connectionPoolUtilization: number;
  };
}

// 缓存指标接口
interface CacheMetric extends BaseMetric {
  name: 'cache';
  value: number; // 命中数
  unit: 'count';
  details: {
    hits: number;
    misses: number;
    hitRate: number;
    evictions: number;
    utilization: number;
  };
}
```

### 1.1 监控的重要性

在企业级应用运维中，监控系统是保障系统稳定性、及时发现和解决问题的关键工具。完善的监控体系能够：

1. **主动发现问题**：通过实时监控及时发现系统异常，TypeScript提供类型安全的指标定义
2. **快速定位故障**：提供详细的指标和日志帮助快速定位问题根源，类型化的日志结构
3. **性能优化指导**：通过历史数据分析指导系统性能优化，类型安全的性能指标
4. **容量规划支持**：基于监控数据进行资源容量规划，类型化的容量指标

### 1.2 监控维度

#### 1.2.1 基础设施监控

基础设施监控关注服务器、网络、存储等底层资源的运行状态：

```typescript
// 基础设施监控指标示例
// src/monitoring/infrastructure-metrics.ts
import { CPUUsageMetric, MemoryUsageMetric, NetworkTrafficMetric } from '../types/monitoring.types';

// CPU使用率监控
const cpuUsageMetric: CPUUsageMetric = {
  name: 'cpu_usage',
  value: 23.7, // 总体CPU使用率
  unit: 'percent',
  timestamp: new Date(),
  tags: {
    host: 'server-01',
    region: 'us-west-1'
  },
  details: {
    user: 15.2, // 用户态CPU使用率
    system: 8.5, // 系统态CPU使用率
    idle: 76.3, // 空闲CPU使用率
    total: 23.7 // 总体CPU使用率
  }
};

// 内存使用情况监控
const memoryUsageMetric: MemoryUsageMetric = {
  name: 'memory_usage',
  value: 4294967296, // 已使用内存(字节)
  unit: 'bytes',
  timestamp: new Date(),
  tags: {
    host: 'server-01',
    region: 'us-west-1'
  },
  details: {
    total: 8589934592, // 总内存(字节)
    used: 4294967296, // 已使用内存(字节)
    free: 2147483648, // 空闲内存(字节)
    cached: 2147483648, // 缓存内存(字节)
    utilization: 50.0 // 内存使用率(%)
  }
};

// 网络流量监控
const networkTrafficMetric: NetworkTrafficMetric = {
  name: 'network_traffic',
  value: 2048000, // 接收字节数(bytes/s)
  unit: 'bytes_per_second',
  timestamp: new Date(),
  tags: {
    host: 'server-01',
    interface: 'eth0',
    region: 'us-west-1'
  },
  details: {
    rxBytes: 2048000, // 接收字节数(bytes/s)
    txBytes: 1024000, // 发送字节数(bytes/s)
    rxPackets: 2000, // 接收数据包数(packets/s)
    txPackets: 1000 // 发送数据包数(packets/s)
  }
};

// 基础设施监控数据收集器
class InfrastructureMonitor {
  private metrics: Map<string, BaseMetric> = new Map();

  /**
   * 收集CPU使用率指标
   * @returns CPU使用率指标
   */
  async collectCPUUsage(): Promise<CPUUsageMetric> {
    // 实际实现中会调用系统API获取CPU使用率
    const cpuUsage = await this.getSystemCPUUsage();
    
    const metric: CPUUsageMetric = {
      name: 'cpu_usage',
      value: cpuUsage.total,
      unit: 'percent',
      timestamp: new Date(),
      tags: {
        host: process.env.HOSTNAME || 'unknown',
        region: process.env.REGION || 'unknown'
      },
      details: cpuUsage
    };

    this.metrics.set('cpu_usage', metric);
    return metric;
  }

  /**
   * 收集内存使用指标
   * @returns 内存使用指标
   */
  async collectMemoryUsage(): Promise<MemoryUsageMetric> {
    // 实际实现中会调用系统API获取内存使用情况
    const memoryUsage = await this.getSystemMemoryUsage();
    
    const metric: MemoryUsageMetric = {
      name: 'memory_usage',
      value: memoryUsage.used,
      unit: 'bytes',
      timestamp: new Date(),
      tags: {
        host: process.env.HOSTNAME || 'unknown',
        region: process.env.REGION || 'unknown'
      },
      details: memoryUsage
    };

    this.metrics.set('memory_usage', metric);
    return metric;
  }

  /**
   * 获取系统CPU使用率
   * @returns CPU使用率详情
   */
  private async getSystemCPUUsage(): Promise<CPUUsageMetric['details']> {
    // 这里应该调用实际的系统API
    // 示例数据
    return {
      user: 15.2,
      system: 8.5,
      idle: 76.3,
      total: 23.7
    };
  }

  /**
   * 获取系统内存使用情况
   * @returns 内存使用详情
   */
  private async getSystemMemoryUsage(): Promise<MemoryUsageMetric['details']> {
    // 这里应该调用实际的系统API
    // 示例数据
    return {
      total: 8589934592,
      used: 4294967296,
      free: 2147483648,
      cached: 2147483648,
      utilization: 50.0
    };
  }
}
```

#### 1.2.2 应用性能监控

应用性能监控关注应用程序本身的运行状态和性能表现：

```javascript
// 应用性能监控指标示例
const applicationMetrics = {
  // HTTP请求指标
  httpRequest: {
    total: 10000, // 总请求数
    success: 9950, // 成功请求数
    error: 50, // 错误请求数
    successRate: 99.5, // 成功率(%)
    avgResponseTime: 150, // 平均响应时间(ms)
    p95ResponseTime: 300, // 95%响应时间(ms)
    p99ResponseTime: 500 // 99%响应时间(ms)
  },
  
  // 数据库指标
  database: {
    connections: 25, // 当前连接数
    maxConnections: 100, // 最大连接数
    avgQueryTime: 25, // 平均查询时间(ms)
    slowQueries: 5, // 慢查询数
    connectionPoolUtilization: 25.0 // 连接池使用率(%)
  },
  
  // 缓存指标
  cache: {
    hits: 8000, // 缓存命中数
    misses: 2000, // 缓存未命中数
    hitRate: 80.0, // 缓存命中率(%)
    evictions: 100, // 缓存驱逐数
    utilization: 65.0 // 缓存使用率(%)
  }
};
```

#### 1.2.3 业务指标监控

业务指标监控关注核心业务流程的运行状态：

```javascript
// 业务指标监控示例
const businessMetrics = {
  // 用户指标
  user: {
    activeUsers: 10000, // 活跃用户数
    newUsers: 500, // 新增用户数
    loginSuccess: 8000, // 登录成功数
    loginFailure: 200 // 登录失败数
  },
  
  // 订单指标
  order: {
    totalOrders: 1000, // 总订单数
    completedOrders: 950, // 完成订单数
    cancelledOrders: 50, // 取消订单数
    avgOrderValue: 299.99, // 平均订单金额
    conversionRate: 3.5 // 转化率(%)
  },
  
  // 支付指标
  payment: {
    totalPayments: 950, // 总支付数
    successfulPayments: 940, // 成功支付数
    failedPayments: 10, // 失败支付数
    successRate: 98.9, // 支付成功率(%)
    avgPaymentTime: 2000 // 平均支付时间(ms)
  }
};
```

## 2. Prometheus监控系统

### 2.1 Prometheus集成

Prometheus 是一个开源的系统监控和告警工具包，特别适合云原生环境：

#### 2.1.1 Prometheus配置

```yaml
# prometheus.yml
# 全局配置
global:
  scrape_interval: 15s # 抓取间隔
  evaluation_interval: 15s # 规则评估间隔

# 告警管理器配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

# 规则文件
rule_files:
  - "ecommerce_rules.yml"

# 抓取配置
scrape_configs:
  # 监控Prometheus自身
  - job_name: "prometheus"
    static_configs:
      - targets: ["localhost:9090"]
  
  # 监控Node Exporter
  - job_name: "node"
    static_configs:
      - targets: ["node-exporter:9100"]
  
  # 监控应用指标
  - job_name: "ecommerce-app"
    static_configs:
      - targets: ["app:3000"]
    metrics_path: "/metrics"
    scrape_interval: 10s
```

#### 2.1.2 应用指标暴露

```typescript
// src/metrics/prometheus.ts
import * as client from 'prom-client';

// 创建注册表
const register = new client.Registry();
client.collectDefaultMetrics({ register });

// 自定义指标
const httpRequestTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code'],
});

const httpRequestDuration = new client.Histogram({
  name: "http_request_duration_seconds",
  help: "Duration of HTTP requests in seconds",
  labelNames: ["method", "route", "status_code"],
  buckets: [0.1, 0.5, 1, 2, 5, 10],
});

const activeUsers = new client.Gauge({
  name: "active_users",
  help: "Number of active users",
});

const orderTotal = new client.Counter({
  name: "orders_total",
  help: "Total number of orders",
  labelNames: ["status"],
});

// 注册指标
register.registerMetric(httpRequestTotal);
register.registerMetric(httpRequestDuration);
register.registerMetric(activeUsers);
register.registerMetric(orderTotal);

module.exports = {
  register,
  httpRequestTotal,
  httpRequestDuration,
  activeUsers,
  orderTotal,
};
```

#### 2.1.3 监控中间件

```typescript
// src/middleware/metrics.middleware.ts
import { Context, Next } from 'koa';
import { httpRequestTotal, httpRequestDuration } from '../metrics/prometheus';

// 监控中间件
const metricsMiddleware = async (ctx: Context, next: Next): Promise<void> => {
  const start = Date.now();
  
  try {
    await next();
    
    // 记录成功请求
    const duration = (Date.now() - start) / 1000;
    httpRequestTotal.inc({
      method: ctx.method,
      route: ctx.path,
      status_code: ctx.status,
    });
    httpRequestDuration.observe(
      {
        method: ctx.method,
        route: ctx.path,
        status_code: ctx.status,
      },
      duration
    );
  } catch (error) {
    // 记录错误请求
    const duration = (Date.now() - start) / 1000;
    httpRequestTotal.inc({
      method: ctx.method,
      route: ctx.path,
      status_code: 500,
    });
    httpRequestDuration.observe(
      {
        method: ctx.method,
        route: ctx.path,
        status_code: 500,
      },
      duration
    );
    
    throw error;
  }
};

module.exports = metricsMiddleware;
```

#### 2.1.4 指标路由

```typescript
// src/routes/metrics.routes.ts
import Router from 'koa-router';
import { register } from '../metrics/prometheus';
import { Context } from 'koa';

const router = new Router();

// 暴露指标端点
router.get('/metrics', async (ctx: Context): Promise<void> => {
  ctx.set('Content-Type', register.contentType);
  ctx.body = await register.metrics();
});

export default router;
```

### 2.2 Grafana可视化

Grafana 是一个开源的度量分析和可视化套件，可以与Prometheus配合使用：

#### 2.2.1 Grafana仪表板配置

```json
{
  "dashboard": {
    "id": null,
    "title": "电商系统监控面板",
    "tags": ["ecommerce", "nodejs"],
    "timezone": "browser",
    "schemaVersion": 16,
    "version": 0,
    "refresh": "10s",
    "panels": [
      {
        "id": 1,
        "type": "graph",
        "title": "HTTP请求率",
        "datasource": "Prometheus",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{status_code}}"
          }
        ],
        "xaxis": {
          "mode": "time"
        },
        "yaxes": [
          {
            "format": "reqps",
            "label": "请求/秒"
          }
        ]
      },
      {
        "id": 2,
        "type": "singlestat",
        "title": "平均响应时间",
        "datasource": "Prometheus",
        "targets": [
          {
            "expr": "avg(http_request_duration_seconds)",
            "format": "time_series"
          }
        ],
        "valueName": "current",
        "format": "s",
        "prefix": "平均: "
      },
      {
        "id": 3,
        "type": "graph",
        "title": "活跃用户数",
        "datasource": "Prometheus",
        "targets": [
          {
            "expr": "active_users",
            "legendFormat": "活跃用户"
          }
        ],
        "xaxis": {
          "mode": "time"
        },
        "yaxes": [
          {
            "format": "none",
            "label": "用户数"
          }
        ]
      }
    ]
  }
}
```

## 3. 日志系统设计

### 3.1 日志级别与格式

#### 3.1.1 日志级别定义

```javascript
// src/constants/log-levels.js
const LOG_LEVELS = {
  ERROR: 0,
  WARN: 1,
  INFO: 2,
  DEBUG: 3
};

module.exports = LOG_LEVELS;
```

#### 3.1.2 结构化日志格式

```javascript
// src/utils/log-formatter.js
const moment = require("moment");

class LogFormatter {
  static format(level, message, meta = {}) {
    return {
      timestamp: moment().toISOString(),
      level: level.toUpperCase(),
      message,
      meta,
      pid: process.pid,
      hostname: require("os").hostname()
    };
  }
  
  static formatHttp(ctx, ms) {
    return {
      timestamp: moment().toISOString(),
      level: "INFO",
      message: `${ctx.method} ${ctx.url} ${ctx.status}`,
      meta: {
        method: ctx.method,
        url: ctx.url,
        status: ctx.status,
        ip: ctx.ip,
        userAgent: ctx.headers["user-agent"],
        responseTime: ms,
        userId: ctx.user ? ctx.user.id : null
      },
      pid: process.pid,
      hostname: require("os").hostname()
    };
  }
}

module.exports = LogFormatter;
```

### 3.2 Winston日志库集成

#### 3.2.1 Winston配置

```javascript
// src/config/winston.js
const winston = require("winston");
const path = require("path");
const config = require("./index");

// 自定义格式
const customFormat = winston.format.printf(({ timestamp, level, message, meta }) => {
  return `${timestamp} [${level}]: ${message} ${meta ? JSON.stringify(meta) : ""}`;
});

const logger = winston.createLogger({
  level: config.log.level || "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    customFormat
  ),
  defaultMeta: { service: "ecommerce-api" },
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // 错误日志文件
    new winston.transports.File({
      filename: path.join(config.log.path || "logs", "error.log"),
      level: "error",
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    // 综合日志文件
    new winston.transports.File({
      filename: path.join(config.log.path || "logs", "combined.log"),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

// 如果不是生产环境，也输出到控制台
if (process.env.NODE_ENV !== "production") {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

module.exports = logger;
```

#### 3.2.2 应用日志中间件

```javascript
// src/middleware/logger.middleware.js
const logger = require("../config/winston");
const LogFormatter = require("../utils/log-formatter");

const loggerMiddleware = async (ctx, next) => {
  // 请求开始日志
  const start = Date.now();
  const requestLog = LogFormatter.format("INFO", "Request started", {
    method: ctx.method,
    url: ctx.url,
    ip: ctx.ip,
    userAgent: ctx.headers["user-agent"],
    requestId: ctx.state.requestId || require("uuid").v4()
  });
  
  logger.info(requestLog);
  
  try {
    await next();
    
    // 响应完成日志
    const ms = Date.now() - start;
    const responseLog = LogFormatter.formatHttp(ctx, ms);
    logger.info(responseLog);
  } catch (error) {
    // 错误日志
    const ms = Date.now() - start;
    const errorLog = LogFormatter.format("ERROR", "Request failed", {
      method: ctx.method,
      url: ctx.url,
      ip: ctx.ip,
      error: error.message,
      stack: error.stack,
      responseTime: ms
    });
    
    logger.error(errorLog);
    throw error;
  }
};

module.exports = loggerMiddleware;
```

### 3.3 ELK Stack集成

ELK Stack (Elasticsearch, Logstash, Kibana) 是一套完整的日志收集、分析和可视化解决方案：

#### 3.3.1 Logstash配置

```ruby
# logstash.conf
input {
  file {
    path => "/var/log/ecommerce/*.log"
    start_position => "beginning"
    codec => "json"
  }
}

filter {
  json {
    source => "message"
  }
  
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
  
  mutate {
    remove_field => [ "message", "timestamp" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "ecommerce-logs-%{+YYYY.MM.dd}"
  }
  
  stdout {
    codec => rubydebug
  }
}
```

#### 3.3.2 Elasticsearch索引模板

```json
{
  "index_patterns": ["ecommerce-logs-*"],
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 1
  },
  "mappings": {
    "properties": {
      "@timestamp": {
        "type": "date"
      },
      "level": {
        "type": "keyword"
      },
      "message": {
        "type": "text"
      },
      "meta": {
        "type": "object",
        "enabled": true
      },
      "pid": {
        "type": "integer"
      },
      "hostname": {
        "type": "keyword"
      }
    }
  }
}
```

#### 3.3.3 Kibana仪表板

```json
{
  "dashboard": {
    "title": "电商系统日志分析",
    "description": "电商系统日志分析仪表板",
    "panels": [
      {
        "id": "error-rate",
        "type": "visualization",
        "gridData": {
          "x": 0,
          "y": 0,
          "w": 24,
          "h": 15
        }
      },
      {
        "id": "request-volume",
        "type": "visualization",
        "gridData": {
          "x": 24,
          "y": 0,
          "w": 24,
          "h": 15
        }
      }
    ]
  }
}
```

## 4. 分布式追踪

### 4.1 OpenTelemetry集成

OpenTelemetry 是云原生计算基金会的可观测性框架，提供统一的API和SDK：

#### 4.1.1 OpenTelemetry配置

```javascript
// src/config/opentelemetry.js
const opentelemetry = require("@opentelemetry/sdk-node");
const { getNodeAutoInstrumentations } = require("@opentelemetry/auto-instrumentations-node");
const { OTLPTraceExporter } = require("@opentelemetry/exporter-trace-otlp-grpc");

const sdk = new opentelemetry.NodeSDK({
  traceExporter: new OTLPTraceExporter({
    url: "http://jaeger:4317"
  }),
  instrumentations: [getNodeAutoInstrumentations()]
});

sdk.start();

process.on("SIGTERM", () => {
  sdk.shutdown()
    .then(() => console.log("Tracing terminated"))
    .catch((error) => console.log("Error terminating tracing", error))
    .finally(() => process.exit(0));
});
```

#### 4.1.2 自定义追踪

```javascript
// src/utils/tracer.js
const opentelemetry = require("@opentelemetry/api");

const tracer = opentelemetry.trace.getTracer("ecommerce-tracer");

class TracerUtil {
  static async trace(name, func, ctx) {
    return tracer.startActiveSpan(name, async (span) => {
      try {
        // 添加请求上下文
        if (ctx) {
          span.setAttribute("http.method", ctx.method);
          span.setAttribute("http.url", ctx.url);
          span.setAttribute("http.user_agent", ctx.headers["user-agent"]);
          if (ctx.user) {
            span.setAttribute("user.id", ctx.user.id);
          }
        }
        
        const result = await func();
        span.setStatus({ code: opentelemetry.SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.setStatus({
          code: opentelemetry.SpanStatusCode.ERROR,
          message: error.message
        });
        span.recordException(error);
        throw error;
      } finally {
        span.end();
      }
    });
  }
}

module.exports = TracerUtil;
```

#### 4.1.3 在服务中使用追踪

```javascript
// src/app/services/order.service.js
const TracerUtil = require("../../utils/tracer");

class OrderService {
  async createOrder(orderData, ctx) {
    return TracerUtil.trace("createOrder", async () => {
      // 创建订单逻辑
      const order = await this.createOrderInDatabase(orderData);
      
      // 发送通知
      await this.sendOrderNotification(order);
      
      return order;
    }, ctx);
  }
  
  async processPayment(orderId, ctx) {
    return TracerUtil.trace("processPayment", async () => {
      // 处理支付逻辑
      const paymentResult = await this.callPaymentService(orderId);
      
      // 更新订单状态
      await this.updateOrderStatus(orderId, "paid");
      
      return paymentResult;
    }, ctx);
  }
}

module.exports = new OrderService();
```

### 4.2 Jaeger集成

Jaeger 是Uber开源的分布式追踪系统：

#### 4.2.1 Jaeger配置

```yaml
# docker-compose.yml
version: "3.8"

services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686" # Jaeger UI
      - "14268:14268" # 接收Jaeger客户端数据
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
    environment:
      - COLLECTOR_OTLP_ENABLED=true
```

#### 4.2.2 追踪可视化

```javascript
// src/middleware/tracing.middleware.js
const opentelemetry = require("@opentelemetry/api");

const tracingMiddleware = async (ctx, next) => {
  const tracer = opentelemetry.trace.getTracer("koa-tracer");
  
  const span = tracer.startSpan(`HTTP ${ctx.method} ${ctx.path}`, {
    attributes: {
      "http.method": ctx.method,
      "http.url": ctx.url,
      "http.user_agent": ctx.headers["user-agent"],
      "http.route": ctx.path
    }
  });
  
  // 将span添加到上下文
  ctx.state.span = span;
  
  try {
    await next();
    
    // 设置响应状态
    span.setAttribute("http.status_code", ctx.status);
    span.setStatus({
      code: ctx.status < 500 
        ? opentelemetry.SpanStatusCode.OK 
        : opentelemetry.SpanStatusCode.ERROR
    });
  } catch (error) {
    span.setStatus({
      code: opentelemetry.SpanStatusCode.ERROR,
      message: error.message
    });
    span.recordException(error);
    throw error;
  } finally {
    span.end();
  }
};

module.exports = tracingMiddleware;
```

## 5. 告警系统

### 5.1 告警规则设计

#### 5.1.1 Prometheus告警规则

```yaml
# ecommerce_rules.yml
groups:
  - name: ecommerce.rules
    rules:
      # 高错误率告警
      - alert: HighErrorRate
        expr: rate(http_requests_total{status_code=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.05
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "高错误率 (实例 {{ $labels.instance }})"
          description: "5分钟内HTTP错误率超过5% (当前值: {{ $value }})"
      
      # 高延迟告警
      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "高延迟 (实例 {{ $labels.instance }})"
          description: "95%的请求响应时间超过1秒 (当前值: {{ $value }})"
      
      # 低成功率告警
      - alert: LowSuccessRate
        expr: rate(http_requests_total{status_code=~"2.."}[5m]) / rate(http_requests_total[5m]) < 0.95
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "低成功率 (实例 {{ $labels.instance }})"
          description: "5分钟内HTTP成功率低于95% (当前值: {{ $value }})"
      
      # 数据库连接池告警
      - alert: HighDatabaseConnectionUsage
        expr: database_connections / database_max_connections > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接池使用率过高 (实例 {{ $labels.instance }})"
          description: "数据库连接池使用率超过80% (当前值: {{ $value }})"
```

### 5.2 Alertmanager配置

#### 5.2.1 Alertmanager配置文件

```yaml
# alertmanager.yml
global:
  smtp_smarthost: "smtp.example.com:587"
  smtp_from: "alert@example.com"
  smtp_auth_username: "alert@example.com"
  smtp_auth_password: "password"

route:
  group_by: ["alertname"]
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: "team-mails"

receivers:
  - name: "team-mails"
    email_configs:
      - to: "dev-team@example.com"
        send_resolved: true
  
  - name: "webhook"
    webhook_configs:
      - url: "http://webhook.example.com/alerts"
        send_resolved: true

inhibit_rules:
  - source_match:
      severity: "critical"
    target_match:
      severity: "warning"
    equal: ["alertname", "instance"]
```

#### 5.2.2 自定义告警处理

```javascript
// src/services/alert.service.js
const axios = require("axios");

class AlertService {
  static async sendAlert(alertData) {
    try {
      // 发送到企业微信
      await this.sendToWeCom(alertData);
      
      // 发送到钉钉
      await this.sendToDingTalk(alertData);
      
      // 发送到邮件
      await this.sendToEmail(alertData);
      
      console.log("告警已发送:", alertData);
    } catch (error) {
      console.error("发送告警失败:", error.message);
    }
  }
  
  static async sendToWeCom(alertData) {
    const webhookUrl = process.env.WECOM_WEBHOOK_URL;
    if (!webhookUrl) return;
    
    const message = {
      msgtype: "text",
      text: {
        content: `【告警】${alertData.alertname}\n级别: ${alertData.severity}\n描述: ${alertData.description}\n时间: ${new Date().toISOString()}`
      }
    };
    
    await axios.post(webhookUrl, message);
  }
  
  static async sendToDingTalk(alertData) {
    const webhookUrl = process.env.DINGTALK_WEBHOOK_URL;
    if (!webhookUrl) return;
    
    const message = {
      msgtype: "text",
      text: {
        content: `【告警】${alertData.alertname}\n级别: ${alertData.severity}\n描述: ${alertData.description}\n时间: ${new Date().toISOString()}`
      }
    };
    
    await axios.post(webhookUrl, message);
  }
  
  static async sendToEmail(alertData) {
    // 邮件发送逻辑
    console.log("发送邮件告警:", alertData);
  }
}

module.exports = AlertService;
```

## 6. 性能监控

### 6.1 应用性能监控

#### 6.1.1 性能指标收集

```javascript
// src/middleware/performance.middleware.js
const client = require("prom-client");

// 性能指标
const responseTimeHistogram = new client.Histogram({
  name: "http_response_time_seconds",
  help: "HTTP response time in seconds",
  labelNames: ["method", "route", "status"],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const throughputCounter = new client.Counter({
  name: "http_requests_total",
  help: "Total HTTP requests",
  labelNames: ["method", "route", "status"]
});

const performanceMiddleware = async (ctx, next) => {
  const start = process.hrtime.bigint();
  
  try {
    await next();
    
    const end = process.hrtime.bigint();
    const durationSeconds = Number(end - start) / 1e9;
    
    // 记录响应时间
    responseTimeHistogram.observe({
      method: ctx.method,
      route: ctx.path,
      status: ctx.status
    }, durationSeconds);
    
    // 记录吞吐量
    throughputCounter.inc({
      method: ctx.method,
      route: ctx.path,
      status: ctx.status
    });
  } catch (error) {
    const end = process.hrtime.bigint();
    const durationSeconds = Number(end - start) / 1e9;
    
    // 记录错误响应时间
    responseTimeHistogram.observe({
      method: ctx.method,
      route: ctx.path,
      status: 500
    }, durationSeconds);
    
    // 记录错误请求
    throughputCounter.inc({
      method: ctx.method,
      route: ctx.path,
      status: 500
    });
    
    throw error;
  }
};

module.exports = performanceMiddleware;
```

#### 6.1.2 数据库性能监控

```javascript
// src/utils/db-profiler.js
const client = require("prom-client");

// 数据库查询时间直方图
const dbQueryDuration = new client.Histogram({
  name: "db_query_duration_seconds",
  help: "Database query duration in seconds",
  labelNames: ["model", "operation"],
  buckets: [0.01, 0.05, 0.1, 0.3, 0.5, 1, 2, 5]
});

// 慢查询计数器
const slowQueryCounter = new client.Counter({
  name: "db_slow_queries_total",
  help: "Total number of slow database queries",
  labelNames: ["model", "operation"]
});

class DatabaseProfiler {
  static async profile(query, options = {}) {
    const start = process.hrtime.bigint();
    
    try {
      const result = await query;
      const end = process.hrtime.bigint();
      const durationSeconds = Number(end - start) / 1e9;
      
      // 记录查询时间
      dbQueryDuration.observe({
        model: options.model || "unknown",
        operation: options.operation || "unknown"
      }, durationSeconds);
      
      // 记录慢查询
      if (durationSeconds > (options.slowThreshold || 1)) {
        slowQueryCounter.inc({
          model: options.model || "unknown",
          operation: options.operation || "unknown"
        });
      }
      
      return result;
    } catch (error) {
      const end = process.hrtime.bigint();
      const durationSeconds = Number(end - start) / 1e9;
      
      // 记录错误查询时间
      dbQueryDuration.observe({
        model: options.model || "unknown",
        operation: options.operation || "unknown"
      }, durationSeconds);
      
      throw error;
    }
  }
}

module.exports = DatabaseProfiler;
```

### 6.2 缓存性能监控

```javascript
// src/utils/cache-monitor.js
const client = require("prom-client");

// 缓存命中率
const cacheHitCounter = new client.Counter({
  name: "cache_hits_total",
  help: "Total number of cache hits",
  labelNames: ["cache_type"]
});

const cacheMissCounter = new client.Counter({
  name: "cache_misses_total",
  help: "Total number of cache misses",
  labelNames: ["cache_type"]
});

// 缓存操作时间
const cacheOperationDuration = new client.Histogram({
  name: "cache_operation_duration_seconds",
  help: "Cache operation duration in seconds",
  labelNames: ["operation", "cache_type"],
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1]
});

class CacheMonitor {
  static recordHit(cacheType) {
    cacheHitCounter.inc({ cache_type: cacheType });
  }
  
  static recordMiss(cacheType) {
    cacheMissCounter.inc({ cache_type: cacheType });
  }
  
  static recordOperation(operation, cacheType, durationSeconds) {
    cacheOperationDuration.observe({
      operation,
      cache_type: cacheType
    }, durationSeconds);
  }
  
  static getHitRate(cacheType) {
    // 计算缓存命中率
    return new Promise((resolve) => {
      // 实现命中率计算逻辑
      resolve(0.95); // 示例值
    });
  }
}

module.exports = CacheMonitor;
```

## 7. 总结

本文档详细介绍了企业级电商系统的监控与日志管理策略。通过Prometheus监控、ELK日志分析、分布式追踪和告警系统，我们能够构建出完整的可观测性体系。

### 7.1 关键要点

1. **监控体系**：建立基础设施、应用性能和业务指标的全方位监控
2. **日志管理**：实现结构化日志记录和ELK日志分析
3. **分布式追踪**：通过OpenTelemetry和Jaeger实现请求链路追踪
4. **告警机制**：建立多层次的告警规则和通知机制
5. **性能优化**：通过性能监控指导系统优化

### 7.2 下一步学习

- 实现安全防护与最佳实践
- 完善性能调优方案
- 学习云原生监控技术
- 掌握AIOps和智能运维

继续阅读后续文档，深入学习电商系统的其他核心功能模块！