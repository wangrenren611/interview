# 10-消息队列与异步处理

## 1. 消息队列概述

### 1.0 TypeScript在消息队列中的优势

在消息队列与异步处理中，TypeScript提供了强大的类型安全保障，特别是在处理复杂的异步任务和消息传递时：

#### 1.0.1 类型安全的队列系统
```typescript
// 队列任务类型定义
interface QueueTask<T = any> {
  id: string;
  data: T;
  priority?: number;
  delay?: number;
  attempts?: number;
  backoff?: BackoffOptions;
  timestamp: Date;
}

// 队列配置接口
interface QueueConfig {
  name: string;
  redis: RedisConfig;
  settings?: QueueSettings;
  limiter?: RateLimiter;
}

// 队列设置接口
interface QueueSettings {
  lockDuration?: number;
  stalledInterval?: number;
  maxStalledCount?: number;
  guardInterval?: number;
  retryProcessDelay?: number;
  drainDelay?: number;
}

// 速率限制器接口
interface RateLimiter {
  max: number;
  duration: number;
}

// 退避策略接口
interface BackoffOptions {
  type: 'fixed' | 'exponential';
  delay: number;
  maxDelay?: number;
}
```

#### 1.0.2 异步任务类型定义
```typescript
// 任务处理器类型
type TaskProcessor<T = any, R = any> = (job: Job<T>) => Promise<R>;

// 任务状态类型
type JobStatus = 'waiting' | 'active' | 'completed' | 'failed' | 'delayed' | 'paused';

// 任务接口
interface Job<T = any> {
  id: string;
  data: T;
  status: JobStatus;
  progress: number;
  attempts: number;
  maxAttempts: number;
  createdAt: Date;
  processedAt?: Date;
  finishedAt?: Date;
  failedReason?: string;
}

// 队列事件类型
type QueueEvent = 'completed' | 'failed' | 'stalled' | 'progress' | 'active' | 'waiting';

// 事件处理器类型
type EventHandler<T = any> = (job: Job<T>) => void | Promise<void>;
```

### 1.1 消息队列的重要性

在企业级应用中，消息队列是处理异步任务、解耦系统组件和提高系统可扩展性的关键技术。通过消息队列，我们可以：

1. **异步处理**：将耗时操作放入队列后台处理，提高响应速度，TypeScript提供类型安全的异步处理
2. **系统解耦**：降低系统组件间的耦合度，提高可维护性，类型化的消息传递
3. **流量削峰**：在高并发场景下平滑处理请求，类型安全的队列管理
4. **可靠性保障**：通过持久化和重试机制确保任务执行，类型化的错误处理

### 1.2 消息队列模式

#### 1.2.1 点对点模式

```typescript
// 点对点模式：一个消息只能被一个消费者处理
// src/queues/order-processing.queue.ts
import Queue from 'bull';
import { redisConfig } from '../config/redis';
import { OrderProcessingData, OrderProcessingResult } from '../types/order.types';

// 订单处理队列配置
const orderProcessingQueueConfig: QueueConfig = {
  name: 'order-processing',
  redis: redisConfig,
  limiter: {
    max: 1000, // 每秒最多处理1000个任务
    duration: 1000
  },
  settings: {
    lockDuration: 30000,
    stalledInterval: 30000,
    maxStalledCount: 3
  }
};

// 创建订单处理队列
const orderProcessingQueue = new Queue<OrderProcessingData, OrderProcessingResult>(
  orderProcessingQueueConfig.name,
  {
    redis: orderProcessingQueueConfig.redis,
    limiter: orderProcessingQueueConfig.limiter,
    settings: orderProcessingQueueConfig.settings
  }
);

export default orderProcessingQueue;
```

#### 1.2.2 发布订阅模式

```typescript
// 发布订阅模式：一个消息可以被多个消费者处理
// src/queues/notification.queue.ts
import Queue from 'bull';
import { redisConfig } from '../config/redis';
import { NotificationData, NotificationResult } from '../types/notification.types';

// 通知队列配置
const notificationQueueConfig: QueueConfig = {
  name: 'notification',
  redis: redisConfig,
  settings: {
    lockDuration: 60000, // 通知任务可能需要更长时间
    stalledInterval: 30000,
    maxStalledCount: 2
  }
};

// 创建通知队列
const notificationQueue = new Queue<NotificationData, NotificationResult>(
  notificationQueueConfig.name,
  {
    redis: notificationQueueConfig.redis,
    settings: notificationQueueConfig.settings
  }
);

// 多个工作进程可以监听同一个队列
export default notificationQueue;
```

## 2. Bull Queue集成

### 2.1 Bull Queue配置

#### 2.1.1 基础配置

```typescript
// src/config/bull.ts
import { config } from './index';
import { QueueConfig, QueueSettings } from '../types/queue.types';

// Redis配置接口
interface RedisConfig {
  host: string;
  port: number;
  password?: string;
  db: number;
  retryStrategy: (times: number) => number;
}

// Bull队列配置
const bullConfig: QueueConfig = {
  name: 'default',
  redis: {
    host: config.redis.host || 'localhost',
    port: config.redis.port || 6379,
    password: config.redis.password || undefined,
    db: config.redis.db || 0,
    retryStrategy: (times: number): number => {
      const delay = Math.min(times * 50, 2000);
      return delay;
    }
  },
  settings: {
    lockDuration: 30000, // 锁定持续时间
    stalledInterval: 30000, // 检查停滞任务的间隔
    maxStalledCount: 3, // 最大停滞次数
    guardInterval: 5000, // 守卫间隔
    retryProcessDelay: 5000, // 重试处理延迟
    drainDelay: 5 // 排空延迟
  }
};

export { bullConfig, type RedisConfig };
```

#### 2.1.2 队列管理器

```typescript
// src/queues/queue-manager.ts
import Queue from 'bull';
import { bullConfig } from '../config/bull';
import { logger } from '../config/winston';
import { QueueConfig, QueueSettings, TaskProcessor, EventHandler } from '../types/queue.types';

// 队列管理器接口
interface QueueManagerInterface {
  createQueue<T = any, R = any>(name: string, options?: Partial<QueueConfig>): Queue<T, R>;
  getQueue<T = any, R = any>(name: string): Queue<T, R> | undefined;
  removeQueue(name: string): boolean;
  getAllQueues(): Map<string, Queue>;
  closeAllQueues(): Promise<void>;
}

class QueueManager implements QueueManagerInterface {
  private queues = new Map<string, Queue>();
  private logger = logger;

  constructor() {
    this.queues = new Map();
  }
  
  /**
   * 创建队列
   * @param name 队列名称
   * @param options 队列选项
   * @returns 队列实例
   */
  createQueue<T = any, R = any>(name: string, options: Partial<QueueConfig> = {}): Queue<T, R> {
    if (this.queues.has(name)) {
      return this.queues.get(name) as Queue<T, R>;
    }
    
    const queue = new Queue<T, R>(name, {
      ...bullConfig,
      ...options
    });
    
    // 监听队列事件
    this.setupQueueEvents(queue, name);
    
    this.queues.set(name, queue);
    this.logger.info(`Queue created: ${name}`);
    
    return queue;
  }
  
  /**
   * 获取队列
   * @param name 队列名称
   * @returns 队列实例或undefined
   */
  getQueue<T = any, R = any>(name: string): Queue<T, R> | undefined {
    return this.queues.get(name) as Queue<T, R> | undefined;
  }
  
  /**
   * 移除队列
   * @param name 队列名称
   * @returns 是否成功移除
   */
  removeQueue(name: string): boolean {
    const queue = this.queues.get(name);
    if (queue) {
      queue.close();
      return this.queues.delete(name);
    }
    return false;
  }
  
  /**
   * 获取所有队列
   * @returns 队列映射
   */
  getAllQueues(): Map<string, Queue> {
    return new Map(this.queues);
  }
  
  /**
   * 关闭所有队列
   */
  async closeAllQueues(): Promise<void> {
    const closePromises = Array.from(this.queues.values()).map(queue => queue.close());
    await Promise.all(closePromises);
    this.queues.clear();
    this.logger.info('All queues closed');
  }
  
  /**
   * 设置队列事件监听
   * @param queue 队列实例
   * @param name 队列名称
   */
  private setupQueueEvents<T = any, R = any>(queue: Queue<T, R>, name: string): void {
    queue.on('waiting', (jobId: string) => {
      this.logger.info(`Job ${jobId} is waiting in queue ${name}`);
    });
    
    queue.on('active', (job: any) => {
      this.logger.info(`Job ${job.id} is now active in queue ${name}`);
    });
    
    queue.on('completed', (job: any, result: R) => {
      this.logger.info(`Job ${job.id} completed in queue ${name}`, { result });
    });
    
    queue.on('failed', (job: any, err: Error) => {
      this.logger.error(`Job ${job.id} failed in queue ${name}`, { 
        error: err.message,
        stack: err.stack
      });
    });
    
    queue.on('error', (error: Error) => {
      this.logger.error(`Queue ${name} error`, { error: error.message });
    });
  }
}

// 创建单例实例
const queueManager = new QueueManager();

export { queueManager, QueueManager, type QueueManagerInterface };
    
    queue.on('stalled', (job) => {
      logger.warn(`Job ${job.id} stalled in queue ${name}`);
    });
  }
  
  // 关闭所有队列
  async closeAll() {
    for (const [name, queue] of this.queues) {
      await queue.close();
      logger.info(`Queue ${name} closed`);
    }
    this.queues.clear();
  }
  
  // 清空队列
  async cleanAll() {
    for (const [name, queue] of this.queues) {
      await queue.empty();
      logger.info(`Queue ${name} emptied`);
    }
  }
}

module.exports = new QueueManager();
```

### 2.2 队列定义

#### 2.2.1 订单处理队列

```typescript
// src/queues/order-processing.queue.ts
import { QueueManager } from './queue-manager';
import { OrderService } from '../app/services/order.service';
import { logger } from '../config/winston';
import { OrderProcessingData, OrderProcessingResult } from '../types/order.types';

// 创建订单处理队列
const orderProcessingQueue = QueueManager.createQueue<OrderProcessingData, OrderProcessingResult>('order-processing', {
  limiter: {
    max: 100, // 每秒最多处理100个订单
    duration: 1000
  },
  defaultJobOptions: {
    attempts: 3, // 最多重试3次
    backoff: {
      type: 'exponential',
      delay: 1000
    },
    removeOnComplete: true, // 完成后移除任务
    removeOnFail: false // 失败后保留任务
  }
});

// 处理订单任务
orderProcessingQueue.process('process-order', async (job) => {
  const { orderId, userId } = job.data;
  
  logger.info(`Processing order ${orderId}`, { orderId, userId });
  
  try {
    // 处理订单逻辑
    const result = await orderService.processOrder(orderId, userId);
    
    logger.info(`Order ${orderId} processed successfully`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to process order ${orderId}`, { 
      error: error.message,
      orderId,
      userId
    });
    
    // 根据错误类型决定是否重试
    if (error.code === 'TEMPORARY_ERROR') {
      throw error; // 重试
    } else {
      // 永久错误，不重试
      throw new Error(`Permanent error: ${error.message}`);
    }
  }
});

// 处理库存更新任务
orderProcessingQueue.process('update-inventory', async (job) => {
  const { orderId, items } = job.data;
  
  logger.info(`Updating inventory for order ${orderId}`, { orderId, items });
  
  try {
    // 更新库存逻辑
    const result = await orderService.updateInventory(orderId, items);
    
    logger.info(`Inventory updated for order ${orderId}`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to update inventory for order ${orderId}`, { 
      error: error.message,
      orderId,
      items
    });
    throw error;
  }
});

module.exports = orderProcessingQueue;
```

#### 2.2.2 通知队列

```typescript
// src/queues/notification.queue.ts
import { QueueManager } from './queue-manager';
import { EmailService } from '../utils/email.service';
import { SMSService } from '../utils/sms.service';
import { logger } from '../config/winston';
import { NotificationData, NotificationResult } from '../types/notification.types';

// 通知类型枚举
enum NotificationType {
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  WEBHOOK = 'webhook'
}

// 通知数据接口
interface NotificationData {
  type: NotificationType;
  recipient: string;
  subject?: string;
  content: string;
  template?: string;
  variables?: Record<string, any>;
  priority?: 'low' | 'normal' | 'high';
  scheduledAt?: Date;
}

// 通知结果接口
interface NotificationResult {
  success: boolean;
  messageId?: string;
  error?: string;
  sentAt: Date;
}

// 创建通知队列
const notificationQueue = QueueManager.createQueue<NotificationData, NotificationResult>('notification', {
  defaultJobOptions: {
    attempts: 5, // 最多重试5次
    backoff: {
      type: 'fixed',
      delay: 5000 // 5秒后重试
    },
    removeOnComplete: true,
    removeOnFail: false
  }
});

// 处理邮件通知任务
notificationQueue.process('send-email', async (job) => {
  const { to, subject, template, data } = job.data;
  
  logger.info(`Sending email to ${to}`, { subject });
  
  try {
    const result = await emailService.send({
      to,
      subject,
      template,
      data
    });
    
    logger.info(`Email sent successfully to ${to}`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to send email to ${to}`, { 
      error: error.message,
      to,
      subject
    });
    throw error;
  }
});

// 处理短信通知任务
notificationQueue.process('send-sms', async (job) => {
  const { phone, template, data } = job.data;
  
  logger.info(`Sending SMS to ${phone}`);
  
  try {
    const result = await smsService.send({
      phone,
      template,
      data
    });
    
    logger.info(`SMS sent successfully to ${phone}`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to send SMS to ${phone}`, { 
      error: error.message,
      phone
    });
    throw error;
  }
});

module.exports = notificationQueue;
```

#### 2.2.3 数据处理队列

```typescript
// src/queues/data-processing.queue.ts
import { QueueManager } from './queue-manager';
import { ReportService } from '../app/services/report.service';
import { AnalyticsService } from '../app/services/analytics.service';
import { logger } from '../config/winston';
import { DataProcessingData, DataProcessingResult } from '../types/queue.types';

// 数据处理任务数据接口
interface DataProcessingData {
  type: 'report' | 'analytics' | 'export';
  data: any;
  options?: {
    format?: string;
    filters?: Record<string, any>;
    dateRange?: {
      start: Date;
      end: Date;
    };
  };
}

// 数据处理结果接口
interface DataProcessingResult {
  success: boolean;
  data?: any;
  filePath?: string;
  error?: string;
  processedAt: Date;
}

// 创建数据处理队列
const dataProcessingQueue = QueueManager.createQueue<DataProcessingData, DataProcessingResult>('data-processing', {
  limiter: {
    max: 10, // 每分钟最多处理10个任务
    duration: 60000
  },
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 10000 // 10秒后重试
    },
    removeOnComplete: true,
    removeOnFail: false
  }
});

// 处理报表生成任务
dataProcessingQueue.process('generate-report', async (job) => {
  const { reportType, userId, filters } = job.data;
  
  logger.info(`Generating ${reportType} report for user ${userId}`);
  
  try {
    const result = await reportService.generateReport(reportType, userId, filters);
    
    logger.info(`${reportType} report generated for user ${userId}`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to generate ${reportType} report for user ${userId}`, { 
      error: error.message,
      reportType,
      userId
    });
    throw error;
  }
});

// 处理数据分析任务
dataProcessingQueue.process('analyze-data', async (job) => {
  const { dataType, startDate, endDate } = job.data;
  
  logger.info(`Analyzing ${dataType} data from ${startDate} to ${endDate}`);
  
  try {
    const result = await analyticsService.analyzeData(dataType, startDate, endDate);
    
    logger.info(`${dataType} data analyzed`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to analyze ${dataType} data`, { 
      error: error.message,
      dataType,
      startDate,
      endDate
    });
    throw error;
  }
});

module.exports = dataProcessingQueue;
```

## 3. 任务调度实现

### 3.1 定时任务调度器

#### 3.1.1 任务调度管理器

```javascript
// src/schedulers/scheduler-manager.js
const QueueManager = require('../queues/queue-manager');
const logger = require('../config/winston');

class SchedulerManager {
  constructor() {
    this.scheduledJobs = new Map();
  }
  
  // 添加定时任务
  async addScheduledJob(queueName, jobName, data, cronExpression, options = {}) {
    const queue = QueueManager.getQueue(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const jobId = `${jobName}_${Date.now()}`;
    
    // 添加重复任务
    const job = await queue.add(jobName, data, {
      jobId,
      repeat: {
        cron: cronExpression
      },
      ...options
    });
    
    this.scheduledJobs.set(jobId, {
      queueName,
      jobName,
      jobId: job.id,
      cronExpression
    });
    
    logger.info(`Scheduled job added: ${jobName}`, { 
      jobId: job.id,
      queueName,
      cronExpression
    });
    
    return job;
  }
  
  // 移除定时任务
  async removeScheduledJob(jobId) {
    const jobInfo = this.scheduledJobs.get(jobId);
    if (!jobInfo) {
      throw new Error(`Scheduled job ${jobId} not found`);
    }
    
    const queue = QueueManager.getQueue(jobInfo.queueName);
    if (queue) {
      await queue.removeRepeatable(jobInfo.jobName, {
        cron: jobInfo.cronExpression
      });
    }
    
    this.scheduledJobs.delete(jobId);
    logger.info(`Scheduled job removed: ${jobId}`);
  }
  
  // 获取所有定时任务
  getAllScheduledJobs() {
    return Array.from(this.scheduledJobs.values());
  }
  
  // 初始化系统定时任务
  async initializeSystemJobs() {
    try {
      // 每天凌晨2点清理过期数据
      await this.addScheduledJob(
        'data-processing',
        'cleanup-expired-data',
        { days: 30 },
        '0 2 * * *' // 每天凌晨2点
      );
      
      // 每小时生成销售报告
      await this.addScheduledJob(
        'data-processing',
        'generate-sales-report',
        { type: 'hourly' },
        '0 * * * *' // 每小时
      );
      
      // 每天上午9点发送日报
      await this.addScheduledJob(
        'notification',
        'send-daily-report',
        { recipients: ['admin@example.com'] },
        '0 9 * * *' // 每天上午9点
      );
      
      logger.info('System scheduled jobs initialized');
    } catch (error) {
      logger.error('Failed to initialize system scheduled jobs', { 
        error: error.message 
      });
      throw error;
    }
  }
}

module.exports = new SchedulerManager();
```

#### 3.1.2 系统定时任务实现

```javascript
// src/queues/system-jobs.queue.js
const QueueManager = require('../queues/queue-manager');
const dataProcessingQueue = require('./data-processing.queue');
const notificationQueue = require('./notification.queue');
const reportService = require('../app/services/report.service');
const analyticsService = require('../app/services/analytics.service');
const emailService = require('../utils/email.service');
const logger = require('../config/winston');

// 创建系统任务队列
const systemJobsQueue = QueueManager.createQueue('system-jobs', {
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 30000 // 30秒后重试
    },
    removeOnComplete: true,
    removeOnFail: false
  }
});

// 清理过期数据任务
systemJobsQueue.process('cleanup-expired-data', async (job) => {
  const { days } = job.data;
  
  logger.info(`Cleaning up expired data older than ${days} days`);
  
  try {
    // 实现数据清理逻辑
    const result = await analyticsService.cleanupExpiredData(days);
    
    logger.info(`Expired data cleanup completed`, { result });
    return result;
  } catch (error) {
    logger.error(`Failed to cleanup expired data`, { 
      error: error.message,
      days
    });
    throw error;
  }
});

// 生成销售报告任务
systemJobsQueue.process('generate-sales-report', async (job) => {
  const { type } = job.data;
  
  logger.info(`Generating ${type} sales report`);
  
  try {
    const report = await reportService.generateSalesReport(type);
    
    // 发送报告通知
    await notificationQueue.add('send-email', {
      to: 'admin@example.com',
      subject: `${type} Sales Report`,
      template: 'sales-report',
      data: report
    });
    
    logger.info(`${type} sales report generated and sent`, { report });
    return report;
  } catch (error) {
    logger.error(`Failed to generate ${type} sales report`, { 
      error: error.message,
      type
    });
    throw error;
  }
});

// 发送日报任务
systemJobsQueue.process('send-daily-report', async (job) => {
  const { recipients } = job.data;
  
  logger.info(`Sending daily report to ${recipients.length} recipients`);
  
  try {
    // 生成日报数据
    const dailyData = await analyticsService.getDailySummary();
    
    // 发送邮件给每个收件人
    const emailPromises = recipients.map(recipient => 
      emailService.send({
        to: recipient,
        subject: 'Daily System Report',
        template: 'daily-report',
        data: dailyData
      })
    );
    
    const results = await Promise.all(emailPromises);
    
    logger.info(`Daily report sent to ${recipients.length} recipients`, { results });
    return results;
  } catch (error) {
    logger.error(`Failed to send daily report`, { 
      error: error.message,
      recipients
    });
    throw error;
  }
});

module.exports = systemJobsQueue;
```

### 3.2 动态任务调度

#### 3.2.1 任务调度API

```javascript
// src/app/controllers/scheduler.controller.js
const SchedulerManager = require('../../schedulers/scheduler-manager');
const QueueManager = require('../../queues/queue-manager');
const logger = require('../../config/winston');

class SchedulerController {
  // 获取所有定时任务
  async listScheduledJobs(ctx) {
    try {
      const jobs = SchedulerManager.getAllScheduledJobs();
      
      ctx.body = {
        success: true,
        data: jobs
      };
    } catch (error) {
      logger.error('Failed to list scheduled jobs', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to list scheduled jobs'
      };
    }
  }
  
  // 添加定时任务
  async addScheduledJob(ctx) {
    try {
      const { queueName, jobName, data, cronExpression, options } = ctx.request.body;
      
      const job = await SchedulerManager.addScheduledJob(
        queueName,
        jobName,
        data,
        cronExpression,
        options
      );
      
      ctx.status = 201;
      ctx.body = {
        success: true,
        message: 'Scheduled job added successfully',
        data: {
          jobId: job.id,
          queueName,
          jobName
        }
      };
    } catch (error) {
      logger.error('Failed to add scheduled job', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to add scheduled job'
      };
    }
  }
  
  // 移除定时任务
  async removeScheduledJob(ctx) {
    try {
      const { jobId } = ctx.params;
      
      await SchedulerManager.removeScheduledJob(jobId);
      
      ctx.body = {
        success: true,
        message: 'Scheduled job removed successfully'
      };
    } catch (error) {
      logger.error('Failed to remove scheduled job', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to remove scheduled job'
      };
    }
  }
  
  // 立即执行任务
  async executeJob(ctx) {
    try {
      const { queueName, jobName, data } = ctx.request.body;
      
      const queue = QueueManager.getQueue(queueName);
      if (!queue) {
        ctx.status = 404;
        ctx.body = {
          success: false,
          message: `Queue ${queueName} not found`
        };
        return;
      }
      
      const job = await queue.add(jobName, data);
      
      ctx.status = 201;
      ctx.body = {
        success: true,
        message: 'Job added to queue successfully',
        data: {
          jobId: job.id,
          queueName,
          jobName
        }
      };
    } catch (error) {
      logger.error('Failed to execute job', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to execute job'
      };
    }
  }
  
  // 获取队列状态
  async getQueueStatus(ctx) {
    try {
      const queues = QueueManager.getAllQueues();
      const status = {};
      
      for (const queue of queues) {
        const counts = await queue.getJobCounts();
        status[queue.name] = {
          ...counts,
          isPaused: await queue.isPaused()
        };
      }
      
      ctx.body = {
        success: true,
        data: status
      };
    } catch (error) {
      logger.error('Failed to get queue status', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to get queue status'
      };
    }
  }
}

module.exports = new SchedulerController();
```

#### 3.2.2 任务调度路由

```javascript
// src/routes/scheduler.routes.js
const Router = require('koa-router');
const schedulerController = require('../app/controllers/scheduler.controller');
const AuthMiddleware = require('../middleware/auth.middleware');
const AdminMiddleware = require('../middleware/admin.middleware');

const router = new Router({ prefix: '/api/scheduler' });

// 需要认证和管理员权限
router.use(AuthMiddleware.authenticate);
router.use(AdminMiddleware.execute);

// 任务调度相关路由
router.get('/jobs', schedulerController.listScheduledJobs); // 获取定时任务列表
router.post('/jobs', schedulerController.addScheduledJob); // 添加定时任务
router.delete('/jobs/:jobId', schedulerController.removeScheduledJob); // 移除定时任务
router.post('/execute', schedulerController.executeJob); // 立即执行任务
router.get('/status', schedulerController.getQueueStatus); // 获取队列状态

module.exports = router;
```

## 4. 异步处理模式

### 4.1 任务处理器设计

#### 4.1.1 通用任务处理器

```javascript
// src/processors/base.processor.js
const logger = require('../config/winston');

class BaseProcessor {
  constructor(name) {
    this.name = name;
  }
  
  // 处理任务的主方法
  async process(job) {
    const startTime = Date.now();
    const { id, data } = job;
    
    logger.info(`Processing job ${id} with ${this.name}`, { data });
    
    try {
      // 执行具体业务逻辑
      const result = await this.handle(data);
      
      const duration = Date.now() - startTime;
      logger.info(`Job ${id} completed successfully in ${duration}ms`, { 
        result,
        duration
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(`Job ${id} failed after ${duration}ms`, { 
        error: error.message,
        stack: error.stack,
        duration
      });
      
      // 根据错误类型决定处理方式
      await this.handleError(error, job);
      throw error;
    }
  }
  
  // 具体业务逻辑实现（子类需要重写）
  async handle(data) {
    throw new Error('handle method must be implemented by subclass');
  }
  
  // 错误处理
  async handleError(error, job) {
    // 可以在这里实现特定的错误处理逻辑
    // 比如记录到数据库、发送告警等
  }
  
  // 任务验证
  validate(data) {
    // 可以在这里实现数据验证逻辑
    return true;
  }
}

module.exports = BaseProcessor;
```

#### 4.1.2 具体任务处理器

```javascript
// src/processors/order.processor.js
const BaseProcessor = require('./base.processor');
const orderService = require('../app/services/order.service');
const notificationQueue = require('../queues/notification.queue');

class OrderProcessor extends BaseProcessor {
  constructor() {
    super('OrderProcessor');
  }
  
  async handle(data) {
    const { orderId, action } = data;
    
    switch (action) {
      case 'process':
        return await this.processOrder(orderId);
      case 'cancel':
        return await this.cancelOrder(orderId);
      case 'ship':
        return await this.shipOrder(orderId);
      default:
        throw new Error(`Unknown action: ${action}`);
    }
  }
  
  async processOrder(orderId) {
    // 处理订单逻辑
    const order = await orderService.processOrder(orderId);
    
    // 发送订单确认通知
    if (order) {
      await notificationQueue.add('send-email', {
        to: order.user.email,
        subject: 'Order Confirmation',
        template: 'order-confirmation',
        data: { order }
      });
    }
    
    return order;
  }
  
  async cancelOrder(orderId) {
    const order = await orderService.cancelOrder(orderId);
    
    // 发送取消通知
    if (order) {
      await notificationQueue.add('send-email', {
        to: order.user.email,
        subject: 'Order Cancelled',
        template: 'order-cancelled',
        data: { order }
      });
    }
    
    return order;
  }
  
  async shipOrder(orderId) {
    const order = await orderService.shipOrder(orderId);
    
    // 发送发货通知
    if (order) {
      await notificationQueue.add('send-email', {
        to: order.user.email,
        subject: 'Order Shipped',
        template: 'order-shipped',
        data: { order }
      });
    }
    
    return order;
  }
  
  validate(data) {
    const { orderId, action } = data;
    
    if (!orderId) {
      throw new Error('orderId is required');
    }
    
    if (!action) {
      throw new Error('action is required');
    }
    
    const validActions = ['process', 'cancel', 'ship'];
    if (!validActions.includes(action)) {
      throw new Error(`Invalid action: ${action}`);
    }
    
    return true;
  }
}

module.exports = new OrderProcessor();
```

### 4.2 任务状态管理

#### 4.2.1 任务状态跟踪

```javascript
// src/services/job-tracking.service.js
const redisClient = require('../config/redis');
const logger = require('../config/winston');

class JobTrackingService {
  // 记录任务开始
  async recordJobStart(jobId, queueName, jobName, data) {
    try {
      const jobInfo = {
        jobId,
        queueName,
        jobName,
        status: 'started',
        startTime: new Date().toISOString(),
        data
      };
      
      await redisClient.setex(
        `job:${jobId}`, 
        86400, // 24小时过期
        JSON.stringify(jobInfo)
      );
      
      // 记录到任务历史
      await redisClient.lpush(
        'job_history',
        JSON.stringify({
          ...jobInfo,
          timestamp: Date.now()
        })
      );
      
      await redisClient.ltrim('job_history', 0, 999); // 保持最近1000条记录
    } catch (error) {
      logger.error('Failed to record job start', { 
        error: error.message,
        jobId
      });
    }
  }
  
  // 记录任务完成
  async recordJobComplete(jobId, result) {
    try {
      const jobInfoStr = await redisClient.get(`job:${jobId}`);
      if (jobInfoStr) {
        const jobInfo = JSON.parse(jobInfoStr);
        jobInfo.status = 'completed';
        jobInfo.endTime = new Date().toISOString();
        jobInfo.duration = new Date(jobInfo.endTime) - new Date(jobInfo.startTime);
        jobInfo.result = result;
        
        await redisClient.setex(
          `job:${jobId}`,
          86400,
          JSON.stringify(jobInfo)
        );
      }
    } catch (error) {
      logger.error('Failed to record job complete', { 
        error: error.message,
        jobId
      });
    }
  }
  
  // 记录任务失败
  async recordJobFailed(jobId, error) {
    try {
      const jobInfoStr = await redisClient.get(`job:${jobId}`);
      if (jobInfoStr) {
        const jobInfo = JSON.parse(jobInfoStr);
        jobInfo.status = 'failed';
        jobInfo.endTime = new Date().toISOString();
        jobInfo.duration = new Date(jobInfo.endTime) - new Date(jobInfo.startTime);
        jobInfo.error = {
          message: error.message,
          stack: error.stack
        };
        
        await redisClient.setex(
          `job:${jobId}`,
          86400,
          JSON.stringify(jobInfo)
        );
      }
    } catch (error) {
      logger.error('Failed to record job failed', { 
        error: error.message,
        jobId
      });
    }
  }
  
  // 获取任务信息
  async getJobInfo(jobId) {
    try {
      const jobInfoStr = await redisClient.get(`job:${jobId}`);
      return jobInfoStr ? JSON.parse(jobInfoStr) : null;
    } catch (error) {
      logger.error('Failed to get job info', { 
        error: error.message,
        jobId
      });
      return null;
    }
  }
  
  // 获取任务历史
  async getJobHistory(limit = 50) {
    try {
      const history = await redisClient.lrange('job_history', 0, limit - 1);
      return history.map(item => JSON.parse(item));
    } catch (error) {
      logger.error('Failed to get job history', { error: error.message });
      return [];
    }
  }
  
  // 获取任务统计
  async getJobStats() {
    try {
      const history = await this.getJobHistory(1000);
      
      const stats = {
        total: history.length,
        completed: 0,
        failed: 0,
        averageDuration: 0,
        successRate: 0
      };
      
      let totalDuration = 0;
      
      for (const job of history) {
        if (job.status === 'completed') {
          stats.completed++;
          totalDuration += job.duration || 0;
        } else if (job.status === 'failed') {
          stats.failed++;
        }
      }
      
      stats.averageDuration = stats.completed > 0 
        ? Math.round(totalDuration / stats.completed)
        : 0;
      
      stats.successRate = stats.total > 0 
        ? Math.round((stats.completed / stats.total) * 10000) / 100
        : 0;
      
      return stats;
    } catch (error) {
      logger.error('Failed to get job stats', { error: error.message });
      return null;
    }
  }
}

module.exports = new JobTrackingService();
```

#### 4.2.2 带状态跟踪的任务处理器

```javascript
// src/processors/tracked.processor.js
const BaseProcessor = require('./base.processor');
const JobTrackingService = require('../services/job-tracking.service');

class TrackedProcessor extends BaseProcessor {
  constructor(name) {
    super(name);
  }
  
  async process(job) {
    const { id, data, queue: { name: queueName } } = job;
    
    // 记录任务开始
    await JobTrackingService.recordJobStart(id, queueName, this.name, data);
    
    try {
      // 验证数据
      this.validate(data);
      
      // 执行业务逻辑
      const result = await this.handle(data);
      
      // 记录任务完成
      await JobTrackingService.recordJobComplete(id, result);
      
      return result;
    } catch (error) {
      // 记录任务失败
      await JobTrackingService.recordJobFailed(id, error);
      
      // 处理错误
      await this.handleError(error, job);
      throw error;
    }
  }
}

module.exports = TrackedProcessor;
```

## 5. 队列监控与管理

### 5.1 Bull Board集成

#### 5.1.1 Bull Board配置

```javascript
// src/config/bull-board.js
const { createBullBoard } = require('@bull-board/api');
const { BullAdapter } = require('@bull-board/api/bullAdapter');
const { KoaAdapter } = require('@bull-board/koa');
const QueueManager = require('../queues/queue-manager');

// 创建Bull Board适配器
const serverAdapter = new KoaAdapter();

// 获取所有队列
const queues = QueueManager.getAllQueues();

// 创建Bull Board实例
const { addQueue, removeQueue } = createBullBoard({
  queues: queues.map(queue => new BullAdapter(queue)),
  serverAdapter
});

serverAdapter.setBasePath('/admin/queues');

module.exports = { serverAdapter, addQueue, removeQueue };
```

#### 5.1.2 监控路由集成

```javascript
// src/app.js
const Koa = require('koa');
const { serverAdapter } = require('./config/bull-board');
const AuthMiddleware = require('./middleware/auth.middleware');
const AdminMiddleware = require('./middleware/admin.middleware');

const app = new Koa();

// 集成Bull Board监控界面
app.use(async (ctx, next) => {
  // 只有管理员可以访问队列监控界面
  if (ctx.path.startsWith('/admin/queues')) {
    await AuthMiddleware.authenticate(ctx, async () => {
      await AdminMiddleware.execute(ctx, async () => {
        await serverAdapter.registerPlugin();
        await next();
      });
    });
  } else {
    await next();
  }
});

// 其他中间件和路由...
```

### 5.2 自定义监控面板

#### 5.2.1 监控服务

```javascript
// src/services/queue-monitor.service.js
const QueueManager = require('../queues/queue-manager');
const JobTrackingService = require('./job-tracking.service');
const logger = require('../config/winston');

class QueueMonitorService {
  // 获取队列状态
  async getQueueStatus() {
    try {
      const queues = QueueManager.getAllQueues();
      const status = {};
      
      for (const queue of queues) {
        const counts = await queue.getJobCounts();
        const isPaused = await queue.isPaused();
        
        status[queue.name] = {
          counts,
          isPaused,
          activeJobs: await this.getActiveJobs(queue)
        };
      }
      
      return status;
    } catch (error) {
      logger.error('Failed to get queue status', { error: error.message });
      throw error;
    }
  }
  
  // 获取活跃任务
  async getActiveJobs(queue, limit = 10) {
    try {
      const jobs = await queue.getActive(limit);
      return jobs.map(job => ({
        id: job.id,
        name: job.name,
        data: job.data,
        attemptsMade: job.attemptsMade,
        processedOn: job.processedOn,
        timestamp: job.timestamp
      }));
    } catch (error) {
      logger.error(`Failed to get active jobs for queue ${queue.name}`, { 
        error: error.message 
      });
      return [];
    }
  }
  
  // 获取失败任务
  async getFailedJobs(queue, limit = 10) {
    try {
      const jobs = await queue.getFailed(limit);
      return jobs.map(job => ({
        id: job.id,
        name: job.name,
        data: job.data,
        failedReason: job.failedReason,
        attemptsMade: job.attemptsMade,
        processedOn: job.processedOn,
        timestamp: job.timestamp
      }));
    } catch (error) {
      logger.error(`Failed to get failed jobs for queue ${queue.name}`, { 
        error: error.message 
      });
      return [];
    }
  }
  
  // 重试失败任务
  async retryFailedJob(queueName, jobId) {
    try {
      const queue = QueueManager.getQueue(queueName);
      if (!queue) {
        throw new Error(`Queue ${queueName} not found`);
      }
      
      const job = await queue.getJob(jobId);
      if (!job) {
        throw new Error(`Job ${jobId} not found`);
      }
      
      await job.retry();
      logger.info(`Job ${jobId} retried successfully`);
      
      return { success: true, message: 'Job retried successfully' };
    } catch (error) {
      logger.error('Failed to retry job', { 
        error: error.message,
        queueName,
        jobId
      });
      throw error;
    }
  }
  
  // 清空队列
  async cleanQueue(queueName, gracePeriod = 0) {
    try {
      const queue = QueueManager.getQueue(queueName);
      if (!queue) {
        throw new Error(`Queue ${queueName} not found`);
      }
      
      await queue.clean(gracePeriod, 'completed');
      await queue.clean(gracePeriod, 'failed');
      await queue.clean(gracePeriod, 'delayed');
      await queue.clean(gracePeriod, 'wait');
      
      logger.info(`Queue ${queueName} cleaned successfully`);
      
      return { success: true, message: 'Queue cleaned successfully' };
    } catch (error) {
      logger.error('Failed to clean queue', { 
        error: error.message,
        queueName
      });
      throw error;
    }
  }
  
  // 获取综合统计
  async getStatistics() {
    try {
      const queueStatus = await this.getQueueStatus();
      const jobStats = await JobTrackingService.getJobStats();
      
      return {
        queues: queueStatus,
        jobs: jobStats
      };
    } catch (error) {
      logger.error('Failed to get statistics', { error: error.message });
      throw error;
    }
  }
}

module.exports = new QueueMonitorService();
```

#### 5.2.3 监控API控制器

```javascript
// src/app/controllers/monitor.controller.js
const QueueMonitorService = require('../../services/queue-monitor.service');
const logger = require('../../config/winston');

class MonitorController {
  // 获取队列状态
  async getQueueStatus(ctx) {
    try {
      const status = await QueueMonitorService.getQueueStatus();
      
      ctx.body = {
        success: true,
        data: status
      };
    } catch (error) {
      logger.error('Failed to get queue status', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to get queue status'
      };
    }
  }
  
  // 获取失败任务
  async getFailedJobs(ctx) {
    try {
      const { queueName, limit = 10 } = ctx.query;
      
      const queue = require('../../queues/queue-manager').getQueue(queueName);
      if (!queue) {
        ctx.status = 404;
        ctx.body = {
          success: false,
          message: `Queue ${queueName} not found`
        };
        return;
      }
      
      const failedJobs = await QueueMonitorService.getFailedJobs(queue, parseInt(limit));
      
      ctx.body = {
        success: true,
        data: failedJobs
      };
    } catch (error) {
      logger.error('Failed to get failed jobs', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to get failed jobs'
      };
    }
  }
  
  // 重试失败任务
  async retryFailedJob(ctx) {
    try {
      const { queueName, jobId } = ctx.params;
      
      const result = await QueueMonitorService.retryFailedJob(queueName, jobId);
      
      ctx.body = result;
    } catch (error) {
      logger.error('Failed to retry failed job', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to retry failed job'
      };
    }
  }
  
  // 清空队列
  async cleanQueue(ctx) {
    try {
      const { queueName } = ctx.params;
      const { gracePeriod = 0 } = ctx.request.body;
      
      const result = await QueueMonitorService.cleanQueue(queueName, gracePeriod);
      
      ctx.body = result;
    } catch (error) {
      logger.error('Failed to clean queue', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to clean queue'
      };
    }
  }
  
  // 获取综合统计
  async getStatistics(ctx) {
    try {
      const stats = await QueueMonitorService.getStatistics();
      
      ctx.body = {
        success: true,
        data: stats
      };
    } catch (error) {
      logger.error('Failed to get statistics', { error: error.message });
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: 'Failed to get statistics'
      };
    }
  }
}

module.exports = new MonitorController();
```

## 6. 最佳实践与注意事项

### 6.1 性能优化

#### 6.1.1 并发控制

```javascript
// src/queues/concurrent-processing.queue.js
const QueueManager = require('../queues/queue-manager');
const logger = require('../config/winston');

// 创建支持并发控制的队列
const concurrentQueue = QueueManager.createQueue('concurrent-processing', {
  limiter: {
    max: 50, // 每秒最多处理50个任务
    duration: 1000
  },
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    },
    removeOnComplete: true,
    removeOnFail: false
  }
});

// 并发处理任务
concurrentQueue.process(5, async (job) => { // 同时处理5个任务
  const { taskId, data } = job.data;
  
  logger.info(`Processing task ${taskId} concurrently`, { taskId });
  
  try {
    // 模拟耗时任务
    await new Promise(resolve => setTimeout(resolve, Math.random() * 5000));
    
    const result = { taskId, processedAt: new Date().toISOString() };
    logger.info(`Task ${taskId} completed`, { result });
    
    return result;
  } catch (error) {
    logger.error(`Task ${taskId} failed`, { error: error.message, taskId });
    throw error;
  }
});

module.exports = concurrentQueue;
```

#### 6.1.2 内存管理

```javascript
// src/utils/memory-monitor.js
const logger = require('../config/winston');

class MemoryMonitor {
  static checkMemoryUsage() {
    const usage = process.memoryUsage();
    
    // 转换为MB
    const heapUsed = Math.round(usage.heapUsed / 1024 / 1024);
    const heapTotal = Math.round(usage.heapTotal / 1024 / 1024);
    const rss = Math.round(usage.rss / 1024 / 1024);
    
    const memoryInfo = {
      heapUsed,
      heapTotal,
      rss,
      percentage: Math.round((heapUsed / heapTotal) * 100)
    };
    
    logger.info('Memory usage', memoryInfo);
    
    // 如果内存使用超过80%，记录警告
    if (memoryInfo.percentage > 80) {
      logger.warn('High memory usage detected', memoryInfo);
    }
    
    return memoryInfo;
  }
  
  static setupMemoryMonitoring(interval = 30000) { // 每30秒检查一次
    setInterval(() => {
      this.checkMemoryUsage();
    }, interval);
  }
}

module.exports = MemoryMonitor;
```

### 6.2 错误处理与重试策略

#### 6.2.1 智能重试机制

```javascript
// src/utils/smart-retry.js
const logger = require('../config/winston');

class SmartRetry {
  static getBackoffDelay(attempt, error) {
    // 根据错误类型调整重试策略
    if (this.isPermanentError(error)) {
      return -1; // 不重试
    }
    
    if (this.isTemporaryError(error)) {
      // 临时错误使用指数退避
      return Math.min(1000 * Math.pow(2, attempt - 1), 60000); // 最大1分钟
    }
    
    // 默认重试策略
    return 5000; // 5秒后重试
  }
  
  static isPermanentError(error) {
    const permanentErrorCodes = [
      'INVALID_DATA',
      'PERMISSION_DENIED',
      'NOT_FOUND'
    ];
    
    return permanentErrorCodes.includes(error.code);
  }
  
  static isTemporaryError(error) {
    const temporaryErrorCodes = [
      'TIMEOUT',
      'NETWORK_ERROR',
      'SERVICE_UNAVAILABLE'
    ];
    
    return temporaryErrorCodes.includes(error.code);
  }
  
  static shouldRetry(error, attempt, maxAttempts) {
    if (attempt >= maxAttempts) {
      return false;
    }
    
    if (this.isPermanentError(error)) {
      return false;
    }
    
    return true;
  }
}

module.exports = SmartRetry;
```

#### 6.2.2 死信队列

```javascript
// src/queues/dead-letter.queue.js
const QueueManager = require('../queues/queue-manager');
const logger = require('../config/winston');

// 创建死信队列
const deadLetterQueue = QueueManager.createQueue('dead-letter', {
  defaultJobOptions: {
    removeOnComplete: false, // 保留死信任务
    removeOnFail: false
  }
});

// 处理死信任务
deadLetterQueue.process(async (job) => {
  const { originalJob, error, attempts } = job.data;
  
  logger.error('Dead letter job received', {
    originalJob,
    error,
    attempts
  });
  
  // 可以在这里实现死信处理逻辑
  // 比如发送告警、记录到数据库等
  
  return { processed: true };
});

module.exports = deadLetterQueue;
```

## 7. 总结

本文档详细介绍了企业级电商系统的消息队列与异步处理机制。通过Bull Queue集成、任务调度实现和异步处理模式，我们能够构建出高可用、可扩展的异步任务处理系统。

### 7.1 关键要点

1. **消息队列架构**：合理设计队列结构，支持不同类型的异步任务
2. **任务调度机制**：实现定时任务和动态任务调度功能
3. **异步处理模式**：采用处理器模式提高代码可维护性
4. **监控与管理**：建立完善的队列监控和管理机制
5. **最佳实践**：遵循性能优化和错误处理的最佳实践

### 7.2 下一步学习

- 完善测试策略与实践
- 实施部署与运维方案
- 构建监控与日志系统
- 实现安全防护与最佳实践

继续阅读后续文档，深入学习电商系统的其他核心功能模块！