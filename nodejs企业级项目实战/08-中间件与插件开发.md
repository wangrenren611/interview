# 08-中间件与插件开发

## 1. 中间件开发概述

### 1.1 中间件概念

中间件（Middleware）是Koa.js框架的核心特性之一，它是一个函数，可以访问请求对象（ctx）、响应对象（ctx.response）和应用程序的请求-响应循环中的下一个中间件函数（next）。中间件函数可以执行以下任务：

1. **执行代码**：在请求处理过程中执行任意代码
2. **修改请求和响应对象**：添加属性或修改现有属性
3. **结束请求-响应循环**：直接返回响应而不调用后续中间件
4. **调用下一个中间件**：通过调用next()函数将控制权传递给下一个中间件

### 1.2 Koa中间件的特点

#### 1.2.1 洋葱圈模型

Koa的中间件执行遵循"洋葱圈模型"，这是一种独特的执行顺序：

```javascript
const Koa = require('koa');
const app = new Koa();

// 中间件1
app.use(async (ctx, next) => {
  console.log('1. 开始处理请求');
  await next();
  console.log('6. 请求处理完成');
});

// 中间件2
app.use(async (ctx, next) => {
  console.log('2. 执行中间件2');
  await next();
  console.log('5. 中间件2处理完成');
});

// 中间件3
app.use(async (ctx, next) => {
  console.log('3. 执行中间件3');
  ctx.body = 'Hello World';
  console.log('4. 中间件3处理完成');
});

app.listen(3000);
```

执行顺序：
```
1. 开始处理请求
2. 执行中间件2
3. 执行中间件3
4. 中间件3处理完成
5. 中间件2处理完成
6. 请求处理完成
```

#### 1.2.2 异步支持

Koa中间件原生支持async/await语法，使得异步操作更加简洁：

```javascript
app.use(async (ctx, next) => {
  try {
    // 异步操作
    const data = await fetchDataFromDatabase();
    ctx.state.data = data;
    await next();
  } catch (error) {
    ctx.status = 500;
    ctx.body = { error: 'Internal Server Error' };
  }
});
```

## 2. 自定义中间件开发

### 2.1 中间件基本结构

#### 2.1.1 函数式中间件

```javascript
// src/middleware/example.middleware.js
const exampleMiddleware = async (ctx, next) => {
  // 请求前处理
  console.log(`请求开始: ${ctx.method} ${ctx.url}`);
  const start = Date.now();
  
  try {
    // 调用下一个中间件
    await next();
    
    // 响应后处理
    const ms = Date.now() - start;
    console.log(`请求完成: ${ctx.method} ${ctx.url} - ${ms}ms`);
  } catch (error) {
    // 错误处理
    const ms = Date.now() - start;
    console.error(`请求失败: ${ctx.method} ${ctx.url} - ${ms}ms`, error);
    throw error;
  }
};

module.exports = exampleMiddleware;
```

#### 2.1.2 类式中间件

```javascript
// src/middleware/base.middleware.js
class BaseMiddleware {
  async execute(ctx, next) {
    throw new Error('Middleware execute method must be implemented');
  }
}

// src/middleware/auth.middleware.js
const BaseMiddleware = require('./base.middleware');
const jwt = require('jsonwebtoken');
const config = require('../config');

class AuthMiddleware extends BaseMiddleware {
  constructor() {
    super();
    this.secret = config.jwt.secret;
  }
  
  async execute(ctx, next) {
    const token = ctx.headers.authorization;
    
    if (!token) {
      ctx.status = 401;
      ctx.body = {
        success: false,
        message: '未提供认证令牌'
      };
      return;
    }
    
    try {
      const decoded = jwt.verify(token.replace('Bearer ', ''), this.secret);
      ctx.user = decoded;
      await next();
    } catch (error) {
      ctx.status = 401;
      ctx.body = {
        success: false,
        message: '无效的认证令牌'
      };
    }
  }
}

module.exports = new AuthMiddleware();
```

### 2.2 中间件参数化

#### 2.2.1 配置化中间件

```javascript
// src/middleware/rate-limit.middleware.js
const redis = require('../utils/redis.client');

const rateLimitMiddleware = (options = {}) => {
  const {
    windowMs = 60000, // 1分钟
    max = 100,        // 最多100次请求
    message = 'Too many requests, please try again later.',
    keyGenerator = (ctx) => ctx.ip
  } = options;
  
  return async (ctx, next) => {
    const key = keyGenerator(ctx);
    const redisKey = `rate_limit:${key}`;
    
    // 获取当前计数
    let current = await redis.get(redisKey);
    if (!current) {
      // 如果不存在，初始化并设置过期时间
      await redis.setex(redisKey, Math.ceil(windowMs / 1000), 1);
      current = 1;
    } else {
      // 增加计数
      current = await redis.incr(redisKey);
    }
    
    // 检查是否超过限制
    if (current > max) {
      ctx.status = 429;
      ctx.body = {
        success: false,
        message
      };
      return;
    }
    
    // 设置响应头
    ctx.set('X-RateLimit-Limit', max);
    ctx.set('X-RateLimit-Remaining', max - current);
    ctx.set('X-RateLimit-Reset', new Date(Date.now() + windowMs).toISOString());
    
    await next();
  };
};

module.exports = rateLimitMiddleware;
```

#### 2.2.2 使用参数化中间件

```javascript
// src/app.js
const Koa = require('koa');
const rateLimitMiddleware = require('./middleware/rate-limit.middleware');

const app = new Koa();

// 全局限流
app.use(rateLimitMiddleware({
  windowMs: 60000, // 1分钟
  max: 100,        // 最多100次请求
  message: '请求过于频繁，请稍后再试'
}));

// 特定路由限流
const strictRateLimit = rateLimitMiddleware({
  windowMs: 60000, // 1分钟
  max: 10,         // 最多10次请求
  message: '操作过于频繁，请稍后再试'
});

// 在特定路由使用严格限流
router.post('/api/users', strictRateLimit, userController.create);
```

### 2.3 中间件组合与复用

#### 2.3.1 中间件组合器

```javascript
// src/middleware/compose.middleware.js
const compose = (middlewares) => {
  return async (ctx, next) => {
    let index = -1;
    
    const dispatch = async (i) => {
      if (i <= index) {
        throw new Error('next() called multiple times');
      }
      
      index = i;
      
      if (i === middlewares.length) {
        return await next();
      }
      
      const middleware = middlewares[i];
      await middleware(ctx, () => dispatch(i + 1));
    };
    
    return await dispatch(0);
  };
};

module.exports = compose;
```

#### 2.3.2 条件中间件

```javascript
// src/middleware/conditional.middleware.js
const conditionalMiddleware = (condition, middleware) => {
  return async (ctx, next) => {
    // 检查条件
    if (typeof condition === 'function' ? condition(ctx) : condition) {
      // 如果条件满足，执行中间件
      await middleware(ctx, next);
    } else {
      // 否则直接调用下一个中间件
      await next();
    }
  };
};

module.exports = conditionalMiddleware;
```

#### 2.3.3 使用条件中间件

```javascript
// src/app.js
const conditionalMiddleware = require('./middleware/conditional.middleware');
const authMiddleware = require('./middleware/auth.middleware');
const adminMiddleware = require('./middleware/admin.middleware');

// 只对特定路径应用认证中间件
app.use(conditionalMiddleware(
  (ctx) => ctx.path.startsWith('/api/'),
  authMiddleware.execute
));

// 只对管理员路径应用管理员中间件
app.use(conditionalMiddleware(
  (ctx) => ctx.path.startsWith('/api/admin/'),
  adminMiddleware.execute
));
```

## 3. 日志中间件实现

### 3.1 日志系统设计

#### 3.1.1 日志级别

```javascript
// src/constants/log-levels.js
const LOG_LEVELS = {
  ERROR: 0,
  WARN: 1,
  INFO: 2,
  DEBUG: 3
};

module.exports = LOG_LEVELS;
```

#### 3.1.2 日志格式

```javascript
// src/utils/log-formatter.js
const moment = require('moment');

class LogFormatter {
  static format(level, message, meta = {}) {
    return {
      timestamp: moment().toISOString(),
      level: level.toUpperCase(),
      message,
      meta,
      pid: process.pid,
      hostname: require('os').hostname()
    };
  }
  
  static formatHttp(ctx, ms) {
    return {
      timestamp: moment().toISOString(),
      level: 'INFO',
      message: `${ctx.method} ${ctx.url} ${ctx.status}`,
      meta: {
        method: ctx.method,
        url: ctx.url,
        status: ctx.status,
        ip: ctx.ip,
        userAgent: ctx.headers['user-agent'],
        responseTime: ms,
        userId: ctx.user ? ctx.user.id : null
      },
      pid: process.pid,
      hostname: require('os').hostname()
    };
  }
}

module.exports = LogFormatter;
```

### 3.2 Winston日志库集成

#### 3.2.1 Winston配置

```javascript
// src/config/winston.js
const winston = require('winston');
const path = require('path');
const config = require('./index');

// 自定义格式
const customFormat = winston.format.printf(({ timestamp, level, message, meta }) => {
  return `${timestamp} [${level}]: ${message} ${meta ? JSON.stringify(meta) : ''}`;
});

const logger = winston.createLogger({
  level: config.log.level || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    customFormat
  ),
  defaultMeta: { service: 'ecommerce-api' },
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // 错误日志文件
    new winston.transports.File({
      filename: path.join(config.log.path || 'logs', 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    // 综合日志文件
    new winston.transports.File({
      filename: path.join(config.log.path || 'logs', 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

// 如果不是生产环境，也输出到控制台
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

module.exports = logger;
```

#### 3.2.2 应用日志中间件

```javascript
// src/middleware/logger.middleware.js
const logger = require('../config/winston');
const LogFormatter = require('../utils/log-formatter');

const loggerMiddleware = async (ctx, next) => {
  // 请求开始日志
  const start = Date.now();
  const requestLog = LogFormatter.format('INFO', 'Request started', {
    method: ctx.method,
    url: ctx.url,
    ip: ctx.ip,
    userAgent: ctx.headers['user-agent'],
    requestId: ctx.state.requestId || require('uuid').v4()
  });
  
  logger.info(requestLog);
  
  try {
    await next();
    
    // 响应完成日志
    const ms = Date.now() - start;
    const responseLog = LogFormatter.formatHttp(ctx, ms);
    logger.info(responseLog);
  } catch (error) {
    // 错误日志
    const ms = Date.now() - start;
    const errorLog = LogFormatter.format('ERROR', 'Request failed', {
      method: ctx.method,
      url: ctx.url,
      ip: ctx.ip,
      error: error.message,
      stack: error.stack,
      responseTime: ms
    });
    
    logger.error(errorLog);
    throw error;
  }
};

module.exports = loggerMiddleware;
```

### 3.3 结构化日志

#### 3.3.1 日志服务

```javascript
// src/services/log.service.js
const logger = require('../config/winston');

class LogService {
  // 记录用户行为日志
  static logUserAction(userId, action, details = {}) {
    const logData = {
      type: 'user_action',
      userId,
      action,
      details,
      timestamp: new Date().toISOString()
    };
    
    logger.info('User action logged', logData);
  }
  
  // 记录系统事件日志
  static logSystemEvent(event, details = {}) {
    const logData = {
      type: 'system_event',
      event,
      details,
      timestamp: new Date().toISOString()
    };
    
    logger.info('System event logged', logData);
  }
  
  // 记录安全事件日志
  static logSecurityEvent(event, userId, details = {}) {
    const logData = {
      type: 'security_event',
      event,
      userId,
      details,
      timestamp: new Date().toISOString()
    };
    
    logger.warn('Security event logged', logData);
  }
  
  // 记录错误日志
  static logError(error, context = {}) {
    const logData = {
      type: 'error',
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    };
    
    logger.error('Error occurred', logData);
  }
}

module.exports = LogService;
```

#### 3.3.2 在业务逻辑中使用日志服务

```javascript
// src/app/controllers/user.controller.js
const LogService = require('../services/log.service');

class UserController {
  async create(ctx) {
    try {
      // 创建用户逻辑
      const user = await userService.create(ctx.request.body);
      
      // 记录用户创建日志
      LogService.logUserAction(
        ctx.user ? ctx.user.id : null,
        'user_created',
        { userId: user.id, email: user.email }
      );
      
      ctx.status = 201;
      ctx.body = {
        success: true,
        data: user
      };
    } catch (error) {
      // 记录错误日志
      LogService.logError(error, {
        action: 'create_user',
        requestData: ctx.request.body
      });
      
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: '创建用户失败'
      };
    }
  }
  
  async login(ctx) {
    try {
      const { email, password } = ctx.request.body;
      const user = await userService.authenticate(email, password);
      
      if (user) {
        // 记录登录成功日志
        LogService.logUserAction(user.id, 'user_login', { ip: ctx.ip });
        
        const token = jwt.sign({ id: user.id }, config.jwt.secret);
        ctx.body = {
          success: true,
          data: { token, user }
        };
      } else {
        // 记录登录失败日志
        LogService.logSecurityEvent('login_failed', null, {
          email,
          ip: ctx.ip,
          userAgent: ctx.headers['user-agent']
        });
        
        ctx.status = 401;
        ctx.body = {
          success: false,
          message: '邮箱或密码错误'
        };
      }
    } catch (error) {
      LogService.logError(error, {
        action: 'user_login',
        requestData: ctx.request.body
      });
      
      ctx.status = 500;
      ctx.body = {
        success: false,
        message: '登录失败'
      };
    }
  }
}

module.exports = new UserController();
```

## 4. 异常处理中间件

### 4.1 统一异常处理

#### 4.1.1 自定义异常类

```javascript
// src/exceptions/base.exception.js
class BaseException extends Error {
  constructor(message, code, status = 500, details = {}) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.status = status;
    this.details = details;
    
    // 保证堆栈跟踪信息正确
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

module.exports = BaseException;
```

```javascript
// src/exceptions/validation.exception.js
const BaseException = require('./base.exception');

class ValidationException extends BaseException {
  constructor(errors, message = '参数验证失败') {
    super(message, 'VALIDATION_ERROR', 400, { errors });
  }
}

module.exports = ValidationException;
```

```javascript
// src/exceptions/not-found.exception.js
const BaseException = require('./base.exception');

class NotFoundException extends BaseException {
  constructor(resource = '资源') {
    super(`${resource}不存在`, 'NOT_FOUND', 404);
  }
}

module.exports = NotFoundException;
```

```javascript
// src/exceptions/unauthorized.exception.js
const BaseException = require('./base.exception');

class UnauthorizedException extends BaseException {
  constructor(message = '未授权访问') {
    super(message, 'UNAUTHORIZED', 401);
  }
}

module.exports = UnauthorizedException;
```

```javascript
// src/exceptions/forbidden.exception.js
const BaseException = require('./base.exception');

class ForbiddenException extends BaseException {
  constructor(message = '禁止访问') {
    super(message, 'FORBIDDEN', 403);
  }
}

module.exports = ForbiddenException;
```

#### 4.1.2 异常处理中间件

```javascript
// src/middleware/error.middleware.js
const logger = require('../config/winston');

const errorMiddleware = async (ctx, next) => {
  try {
    await next();
  } catch (error) {
    // 记录错误日志
    logger.error('Unhandled error occurred', {
      message: error.message,
      stack: error.stack,
      url: ctx.url,
      method: ctx.method,
      ip: ctx.ip,
      userAgent: ctx.headers['user-agent'],
      userId: ctx.user ? ctx.user.id : null
    });
    
    // 根据错误类型返回不同的响应
    if (error.name === 'BaseException') {
      // 自定义异常
      ctx.status = error.status;
      ctx.body = {
        success: false,
        code: error.code,
        message: error.message,
        details: error.details,
        timestamp: new Date().toISOString()
      };
    } else if (error.name === 'ValidationError') {
      // Joi验证错误
      ctx.status = 400;
      ctx.body = {
        success: false,
        code: 'VALIDATION_ERROR',
        message: '参数验证失败',
        errors: error.details.map(detail => ({
          field: detail.path.join('.'),
          message: detail.message
        })),
        timestamp: new Date().toISOString()
      };
    } else if (error.name === 'SequelizeUniqueConstraintError') {
      // 数据库唯一约束错误
      ctx.status = 409;
      ctx.body = {
        success: false,
        code: 'DUPLICATE_ENTRY',
        message: '数据已存在',
        details: error.errors.map(err => ({
          field: err.path,
          message: err.message
        })),
        timestamp: new Date().toISOString()
      };
    } else if (error.name === 'SequelizeForeignKeyConstraintError') {
      // 外键约束错误
      ctx.status = 400;
      ctx.body = {
        success: false,
        code: 'FOREIGN_KEY_VIOLATION',
        message: '关联数据不存在',
        timestamp: new Date().toISOString()
      };
    } else {
      // 未知错误
      ctx.status = 500;
      ctx.body = {
        success: false,
        code: 'INTERNAL_ERROR',
        message: process.env.NODE_ENV === 'production' ? '服务器内部错误' : error.message,
        ...(process.env.NODE_ENV !== 'production' && { stack: error.stack }),
        timestamp: new Date().toISOString()
      };
    }
  }
};

module.exports = errorMiddleware;
```

### 4.2 业务异常处理

#### 4.2.1 服务层异常处理

```javascript
// src/app/services/user.service.js
const { User } = require('../models');
const ValidationException = require('../../exceptions/validation.exception');
const NotFoundException = require('../../exceptions/not-found.exception');
const UnauthorizedException = require('../../exceptions/unauthorized.exception');

class UserService {
  async create(userData) {
    try {
      // 业务逻辑验证
      const existingUser = await User.findOne({
        where: { email: userData.email }
      });
      
      if (existingUser) {
        throw new ValidationException([
          {
            field: 'email',
            message: '邮箱已存在'
          }
        ]);
      }
      
      // 创建用户
      const user = await User.create(userData);
      return user;
    } catch (error) {
      // 重新抛出已知异常
      if (error.name === 'BaseException') {
        throw error;
      }
      
      // 包装未知异常
      throw new Error(`创建用户失败: ${error.message}`);
    }
  }
  
  async getById(id) {
    const user = await User.findByPk(id);
    
    if (!user) {
      throw new NotFoundException('用户');
    }
    
    return user;
  }
  
  async update(id, userData, currentUserId) {
    // 验证权限
    if (id !== currentUserId) {
      throw new UnauthorizedException('无权修改其他用户信息');
    }
    
    const user = await this.getById(id);
    
    try {
      await user.update(userData);
      return user;
    } catch (error) {
      throw new Error(`更新用户失败: ${error.message}`);
    }
  }
}

module.exports = new UserService();
```

#### 4.2.2 控制器层异常处理

```javascript
// src/app/controllers/user.controller.js
const userService = require('../services/user.service');
const ValidationException = require('../../exceptions/validation.exception');

class UserController {
  async create(ctx) {
    try {
      const user = await userService.create(ctx.request.body);
      
      ctx.status = 201;
      ctx.body = {
        success: true,
        data: user
      };
    } catch (error) {
      // 异常会被errorMiddleware捕获和处理
      throw error;
    }
  }
  
  async show(ctx) {
    try {
      const { id } = ctx.params;
      const user = await userService.getById(id);
      
      ctx.body = {
        success: true,
        data: user
      };
    } catch (error) {
      throw error;
    }
  }
  
  async update(ctx) {
    try {
      const { id } = ctx.params;
      const user = await userService.update(id, ctx.request.body, ctx.user.id);
      
      ctx.body = {
        success: true,
        data: user
      };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = new UserController();
```

## 5. 插件系统设计

### 5.1 插件架构

#### 5.1.1 插件接口定义

```javascript
// src/plugins/plugin.interface.js
class PluginInterface {
  // 插件名称
  get name() {
    throw new Error('Plugin must implement name getter');
  }
  
  // 插件版本
  get version() {
    return '1.0.0';
  }
  
  // 初始化插件
  async initialize(app) {
    throw new Error('Plugin must implement initialize method');
  }
  
  // 注册中间件
  registerMiddleware(app) {
    // 可选实现
  }
  
  // 注册路由
  registerRoutes(router) {
    // 可选实现
  }
  
  // 销毁插件
  async destroy() {
    // 可选实现
  }
}

module.exports = PluginInterface;
```

#### 5.1.2 插件管理器

```javascript
// src/plugins/plugin-manager.js
const fs = require('fs');
const path = require('path');

class PluginManager {
  constructor() {
    this.plugins = new Map();
    this.app = null;
  }
  
  // 设置应用实例
  setApp(app) {
    this.app = app;
  }
  
  // 加载插件
  async loadPlugin(pluginPath) {
    try {
      const PluginClass = require(pluginPath);
      const plugin = new PluginClass();
      
      // 验证插件接口
      if (!plugin.name) {
        throw new Error('Plugin must have a name');
      }
      
      // 初始化插件
      await plugin.initialize(this.app);
      
      // 存储插件
      this.plugins.set(plugin.name, plugin);
      
      console.log(`Plugin loaded: ${plugin.name} v${plugin.version}`);
      return plugin;
    } catch (error) {
      console.error(`Failed to load plugin from ${pluginPath}:`, error.message);
      throw error;
    }
  }
  
  // 加载目录中的所有插件
  async loadPluginsFromDirectory(directory) {
    const pluginDir = path.resolve(directory);
    
    if (!fs.existsSync(pluginDir)) {
      console.warn(`Plugin directory not found: ${pluginDir}`);
      return;
    }
    
    const files = fs.readdirSync(pluginDir);
    
    for (const file of files) {
      const filePath = path.join(pluginDir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory()) {
        // 检查目录中是否有index.js
        const indexPath = path.join(filePath, 'index.js');
        if (fs.existsSync(indexPath)) {
          await this.loadPlugin(indexPath);
        }
      } else if (file.endsWith('.js') && file !== 'index.js') {
        // 加载.js文件
        await this.loadPlugin(filePath);
      }
    }
  }
  
  // 注册所有插件的中间件
  registerMiddlewares(app) {
    for (const [name, plugin] of this.plugins) {
      try {
        if (typeof plugin.registerMiddleware === 'function') {
          plugin.registerMiddleware(app);
          console.log(`Middleware registered for plugin: ${name}`);
        }
      } catch (error) {
        console.error(`Failed to register middleware for plugin ${name}:`, error.message);
      }
    }
  }
  
  // 注册所有插件的路由
  registerRoutes(router) {
    for (const [name, plugin] of this.plugins) {
      try {
        if (typeof plugin.registerRoutes === 'function') {
          plugin.registerRoutes(router);
          console.log(`Routes registered for plugin: ${name}`);
        }
      } catch (error) {
        console.error(`Failed to register routes for plugin ${name}:`, error.message);
      }
    }
  }
  
  // 获取插件
  getPlugin(name) {
    return this.plugins.get(name);
  }
  
  // 获取所有插件
  getPlugins() {
    return Array.from(this.plugins.values());
  }
  
  // 卸载插件
  async unloadPlugin(name) {
    const plugin = this.plugins.get(name);
    if (plugin) {
      if (typeof plugin.destroy === 'function') {
        await plugin.destroy();
      }
      this.plugins.delete(name);
      console.log(`Plugin unloaded: ${name}`);
    }
  }
  
  // 卸载所有插件
  async unloadAllPlugins() {
    for (const name of this.plugins.keys()) {
      await this.unloadPlugin(name);
    }
  }
}

module.exports = new PluginManager();
```

### 5.2 插件实现示例

#### 5.2.1 日志插件

```javascript
// src/plugins/logging-plugin/index.js
const PluginInterface = require('../plugin.interface');
const loggerMiddleware = require('../../middleware/logger.middleware');

class LoggingPlugin extends PluginInterface {
  get name() {
    return 'logging';
  }
  
  get version() {
    return '1.0.0';
  }
  
  async initialize(app) {
    console.log('Logging plugin initialized');
  }
  
  registerMiddleware(app) {
    // 注册日志中间件
    app.use(loggerMiddleware);
  }
}

module.exports = LoggingPlugin;
```

#### 5.2.2 认证插件

```javascript
// src/plugins/auth-plugin/index.js
const PluginInterface = require('../plugin.interface');
const authMiddleware = require('../../middleware/auth.middleware');

class AuthPlugin extends PluginInterface {
  get name() {
    return 'auth';
  }
  
  get version() {
    return '1.0.0';
  }
  
  async initialize(app) {
    console.log('Auth plugin initialized');
  }
  
  registerMiddleware(app) {
    // 注册认证中间件
    app.use(authMiddleware.execute);
  }
}

module.exports = AuthPlugin;
```

#### 5.2.3 监控插件

```javascript
// src/plugins/monitoring-plugin/index.js
const PluginInterface = require('../plugin.interface');

class MonitoringPlugin extends PluginInterface {
  get name() {
    return 'monitoring';
  }
  
  get version() {
    return '1.0.0';
  }
  
  async initialize(app) {
    // 初始化监控服务
    this.metrics = {
      requestCount: 0,
      errorCount: 0,
      responseTime: []
    };
    
    // 监听应用事件
    app.on('error', (err) => {
      this.metrics.errorCount++;
    });
    
    console.log('Monitoring plugin initialized');
  }
  
  registerMiddleware(app) {
    // 注册监控中间件
    app.use(async (ctx, next) => {
      this.metrics.requestCount++;
      const start = Date.now();
      
      try {
        await next();
      } finally {
        const ms = Date.now() - start;
        this.metrics.responseTime.push(ms);
        
        // 保持最近1000个响应时间
        if (this.metrics.responseTime.length > 1000) {
          this.metrics.responseTime.shift();
        }
      }
    });
  }
  
  // 获取监控指标
  getMetrics() {
    const responseTimes = this.metrics.responseTime;
    const avgResponseTime = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
      : 0;
    
    return {
      requestCount: this.metrics.requestCount,
      errorCount: this.metrics.errorCount,
      avgResponseTime: Math.round(avgResponseTime * 100) / 100,
      uptime: process.uptime()
    };
  }
  
  async destroy() {
    console.log('Monitoring plugin destroyed');
  }
}

module.exports = MonitoringPlugin;
```

### 5.3 插件系统集成

```javascript
// src/app.js
const Koa = require('koa');
const Router = require('koa-router');
const pluginManager = require('./plugins/plugin-manager');

const app = new Koa();
const router = new Router();

// 设置插件管理器的应用实例
pluginManager.setApp(app);

// 加载插件
async function loadPlugins() {
  try {
    await pluginManager.loadPluginsFromDirectory('./src/plugins');
    
    // 注册插件中间件
    pluginManager.registerMiddlewares(app);
    
    // 注册插件路由
    pluginManager.registerRoutes(router);
  } catch (error) {
    console.error('Failed to load plugins:', error.message);
  }
}

// 初始化插件系统
loadPlugins().then(() => {
  // 注册路由
  app.use(router.routes());
  app.use(router.allowedMethods());
  
  // 启动服务器
  const port = process.env.PORT || 3000;
  app.listen(port, () => {
    console.log(`Server running on port ${port}`);
  });
});

// 优雅关闭
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully');
  await pluginManager.unloadAllPlugins();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, shutting down gracefully');
  await pluginManager.unloadAllPlugins();
  process.exit(0);
});
```

## 6. 中间件最佳实践

### 6.1 性能优化

#### 6.1.1 中间件顺序优化

```javascript
// src/app.js
const Koa = require('koa');
const app = new Koa();

// 1. 基础中间件（最先执行）
app.use(require('./middleware/request-id.middleware'));
app.use(require('./middleware/logger.middleware'));

// 2. 安全中间件
app.use(require('./middleware/security.middleware'));
app.use(require('./middleware/cors.middleware'));

// 3. 解析中间件
app.use(require('koa-bodyparser')());

// 4. 认证中间件
app.use(require('./middleware/auth.middleware'));

// 5. 业务中间件
app.use(require('./middleware/validation.middleware'));
app.use(require('./middleware/rate-limit.middleware'));

// 6. 错误处理中间件（最后注册，但最先捕获错误）
app.use(require('./middleware/error.middleware'));
```

#### 6.1.2 中间件缓存

```javascript
// src/middleware/cache.middleware.js
const redis = require('../utils/redis.client');

const cacheMiddleware = (ttl = 300) => {
  return async (ctx, next) => {
    // 只缓存GET请求
    if (ctx.method !== 'GET') {
      return await next();
    }
    
    const cacheKey = `cache:${ctx.url}`;
    
    // 尝试从缓存获取
    const cached = await redis.get(cacheKey);
    if (cached) {
      ctx.body = JSON.parse(cached);
      ctx.set('X-Cache', 'HIT');
      return;
    }
    
    // 执行后续中间件
    await next();
    
    // 缓存响应
    if (ctx.status === 200 && ctx.body) {
      await redis.setex(cacheKey, ttl, JSON.stringify(ctx.body));
      ctx.set('X-Cache', 'MISS');
    }
  };
};

module.exports = cacheMiddleware;
```

### 6.2 安全最佳实践

#### 6.2.1 安全中间件

```javascript
// src/middleware/security.middleware.js
const helmet = require('koa-helmet');

const securityMiddleware = async (ctx, next) => {
  // 应用Helmet安全头
  await helmet()(ctx, async () => {
    // 额外的安全检查
    // 1. 检查请求头
    const suspiciousHeaders = [
      'x-forwarded-for',
      'x-real-ip',
      'x-client-ip'
    ];
    
    for (const header of suspiciousHeaders) {
      if (ctx.headers[header] && !isValidIP(ctx.headers[header])) {
        ctx.status = 400;
        ctx.body = {
          success: false,
          message: 'Invalid request header'
        };
        return;
      }
    }
    
    // 2. 限制请求体大小
    const MAX_BODY_SIZE = 10 * 1024 * 1024; // 10MB
    if (ctx.request.length > MAX_BODY_SIZE) {
      ctx.status = 413;
      ctx.body = {
        success: false,
        message: 'Request entity too large'
      };
      return;
    }
    
    await next();
  });
};

function isValidIP(ip) {
  const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  const ipv6Pattern = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  return ipv4Pattern.test(ip) || ipv6Pattern.test(ip);
}

module.exports = securityMiddleware;
```

#### 6.2.2 CORS配置

```javascript
// src/middleware/cors.middleware.js
const cors = require('@koa/cors');

const corsMiddleware = cors({
  origin: (ctx) => {
    const whitelist = [
      'http://localhost:3000',
      'http://localhost:3001',
      'https://yourdomain.com'
    ];
    
    const origin = ctx.headers.origin;
    if (whitelist.includes(origin)) {
      return origin;
    }
    
    // 开发环境允许所有源
    if (process.env.NODE_ENV === 'development') {
      return origin;
    }
    
    return false;
  },
  credentials: true,
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  exposeHeaders: ['X-Total-Count', 'X-Cache']
});

module.exports = corsMiddleware;
```

## 7. 总结

本文档详细介绍了企业级电商系统的中间件与插件开发。通过自定义中间件开发、日志系统实现、异常处理机制和插件系统设计，我们能够构建出灵活、可扩展的应用架构。

### 7.1 关键要点

1. **中间件开发**：掌握Koa中间件的基本结构和洋葱圈模型
2. **日志系统**：实现结构化日志记录和统一日志管理
3. **异常处理**：建立完整的异常处理体系，提供友好的错误响应
4. **插件系统**：设计可扩展的插件架构，支持功能模块化
5. **最佳实践**：遵循性能优化和安全防护的最佳实践

### 7.2 下一步学习

- 实现缓存与性能优化方案
- 构建消息队列与异步处理机制
- 完善测试策略与实践
- 实施部署与运维方案

继续阅读后续文档，深入学习电商系统的其他核心功能模块！